<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Type-R 3.0 API Reference</title>

    <link rel="icon" href="images/logo-dark.png" />
    <link href="lib/stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="lib/stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <link href="lib/stylesheets/default.css" rel="stylesheet" type="text/css" />

    <style>
      .logo-section img {
        vertical-align: middle;
        margin: 15px;
        height: 48px;
      }

      .logo-section .logo-text {
        vertical-align: middle;
        color: white;
        display: inline-block;
      }

      .logo-section .logo-caption {
        font-size: 28px;
      }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="lib/javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          var langs = [];
            langs.push("javascript");
            langs.push("typescript");
          setupLanguages( langs );
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div class="logo-section">
        <img src="images/logo.png" />
        <div class="logo-text">
          <div class="logo-caption">Type-R 3.0</div>
          <div>universal state management</div>
        </div>
        
      </div>
        <div class="lang-selector">
              <a href="#" data-language-name="javascript">javascript</a>
              <a href="#" data-language-name="typescript">typescript</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
                <li><a href="https://github.com/Volicon/Type-R">GitHub repository</a></li>
                <li><a href="https://github.com/Volicon/Type-R/issues">Report the bug</a></li>
                <li><a href="https://groups.google.com/forum/#!forum/volicon-open-source">Ask the question</a></li>
                <li><a href="http://www.volicon.com/">Supported by <img style="vertical-align: middle" src="images/volicon_verizon_dm.png"/></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
        <div class="content">
          <h1 id="getting-started">Getting started</h1>
<h2 id="overview">Overview</h2>
<p>Type-R is the TypeScript and JavaScript model framework helping to define and manage the complex application state as a combination of reusable parts. Type-R cover the needs of business logic and data layers in 3-tier application architecture, providing the presentation layer with the unified technique to handle the UI and domain state. Type-R data structures look and feel (and, in some aspects, behaves) more like classes in the statically typed languages.</p>
<p>Type-R in unopinionated on the way how an application state should be managed (&quot;single source of truth&quot; or &quot;distributed state&quot;). It can support all approaches equally well being not dependent on singletons and having powerful capabilities for state synchronization.</p>
<p><img src="images/3-layer-client.png" alt="overview"></p>
<p>A state is defined as a superposition of typed records and collections. A record is a class with a known set of attributes of predefined types possibly holding other records and collections in its attributes, describing the data structure of arbitrary complexity. Record with its attributes forms an aggregation tree with deeply observable attributes changes. Attribute types are checked on assignments and invalid changes are being rejected, therefore it is guaranteed that the application state will preserve the valid shape.</p>
<p>Application state defined with Type-R is serializable to JSON by default. Aggregation tree of records and collections is mapped in JSON as a tree of plain objects and arrays. Normalized data represented as a set of collections of records cross-referencing each other are supported as first-class serialization scenario.</p>
<p>A record may have an associated IOEndpont representing the I/O protocol for CRUD and collection fetch operations which enables the persistence API for the particular record/collection class pair. Some useful endpoints (<code>restfulIO</code>, <code>localStorageIO</code>, etc) are provided by <code>type-r/endpoints/*</code> packages, and developers can define their own I/O endpoints implementing any particular persistence transport or API.</p>
<p>Record attributes may have custom validation rules attached to them. Validation is being triggered transparently on demand and its result is cached across the record/collection aggregation tree, making subsequent calls to the validation API extremely cheap.</p>
<p>All aspects of record behavior including serialization and validation can be controlled on attribute level with declarative definitions combining attribute types with metadata. Attribute definitions (&quot;metatypes&quot;) can be reused across different models forming the domain-specific language of model declarations. Some useful attribute metatypes (<code>Email</code>, <code>Url</code>, <code>MicrosoftDate</code>, etc) are provided by <code>type-r/ext-types</code> package.</p>
<h2 id="how-type-r-compares-to-x-">How Type-R compares to X?</h2>
<p>Type-R (former &quot;NestedTypes&quot;) project was started in 2014 in Volicon as a modern successor to BackboneJS models, which would match Ember Data in its capabilities to work with a complex state while retaining the BackboneJS simplicity, modularity, and some degree of backward API compatibility. It replaced BackboneJS in the model layer of Volicon products, and it became the key technology in Volicon&#39;s strategy to gradually move from BackboneJS Views to React in the view layer.</p>
<p><a href="https://guides.emberjs.com/v2.2.0/models/">Ember Data</a> is the closest thing to Type-R by its capabilities, with <a href="http://backbonejs.org/#Model">BackboneJS models and collections</a> being the closest thing by the API, and <a href="https://github.com/mobxjs/mobx">mobx</a> being pretty close in the way how the UI state is managed.</p>
<p>Type-R, however, takes a very different approach to all of them:</p>
<ul>
<li>Type-R models look and feel more like classes in a statically typed language with the majority of features being controlled by attribute metadata.</li>
<li>Type-R is built around the concept of <em>aggregation trees</em> formed by nested records and collections and it knows how to clone, serialize, and validate complex objects with cross-references properly.</li>
<li>In contrast to BackboneJS, Record is <em>not an object hash</em> but the class with statically typed and dynamically checked attributes.</li>
<li>In contrast to mobx, Type-R detects <em>deeply nested changes</em>.</li>
<li>In contrast to Ember Data, Type-R doesn&#39;t require the singleton global store. In Type-R, stores are a special kind of records and there might be as many dynamically created and disposed of stores as you need, starting with no stores at all.</li>
</ul>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Type-R</th>
<th>Backbone Models</th>
<th>Ember Data</th>
<th>mobx</th>
</tr>
</thead>
<tbody>
<tr>
<td>Observable changes in object graph</td>
<td>✓</td>
<td>-</td>
<td>-</td>
<td>✓</td>
</tr>
<tr>
<td>JSON Serialization</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Validation</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Dynamic Type Safety</td>
<td>✓</td>
<td>-</td>
<td>for serialization only</td>
<td>-</td>
</tr>
<tr>
<td>Aggregation</td>
<td>✓</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Relations by id</td>
<td>✓</td>
<td>-</td>
<td>✓</td>
<td>- </td>
</tr>
<tr>
<td>Generalized I/O</td>
<td>✓</td>
<td>sync function</td>
<td>✓</td>
<td>- </td>
</tr>
</tbody>
</table>
<h2 id="features-by-example">Features by example</h2>
<p>Here&#39;s the brief overview of features groped by application purpose.</p>
<h3 id="persistent-domain-state">Persistent domain state</h3>
<p>The basic building block is the <code>Record</code> class. To fetch data from the server, a developer creates the subclass of the <code>Record</code> describing its attribute types and attaches the <code>restfulIO</code> endpoint. It enables the persistence API allowing the developer to fetch the collection from the server. <code>restfulIO</code> expects the server to implement the standard RESTful API expected by BackboneJS models.</p>
<ul>
<li><code>GET /api/users</code> - fetch all the users</li>
<li><code>POST /api/users</code> - create the user</li>
<li><code>GET /api/users/:id</code> - fetch the user with a given id</li>
<li><code>PUT /api/users/:id</code> - update the user with a given id</li>
<li><code>DELETE /api/users/:id</code> - delete the user with a given id</li>
</ul>
<p>Record and collection are serializable to and can be parsed from JSON with no additional effort. A mapping to JSON can be customized for collections, records, and individual attributes. The Record validates all updates casting attribute values to declared attribute types to protect the state structure from the protocol incompatibilities and improper assignments.</p>
<pre><code class="highlight javascript">@define User extends Record {
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">email</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">createdAt</span> : <span class="hljs-built_in">Date</span>
    }
}

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection();
<span class="hljs-keyword">await</span> users.fetch();

expect( users.first().createdAt ).toBeInstanceOf( <span class="hljs-built_in">Date</span> );
expect( <span class="hljs-keyword">typeof</span> users.toJSON()[ <span class="hljs-number">0</span> ].createdAt ).toBe( <span class="hljs-string">"string"</span> );
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );

    <span class="hljs-comment">// Type-R can infer attribute types from TypeScript type annotations.</span>
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span> email : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span> createdAt : <span class="hljs-built_in">Date</span>
}

<span class="hljs-keyword">const</span> users : Collection&lt;User&gt; = <span class="hljs-keyword">new</span> User.Collection();
<span class="hljs-keyword">await</span> users.fetch();

expect( users.first().createdAt ).toBeInstanceOf( <span class="hljs-built_in">Date</span> );
expect( <span class="hljs-keyword">typeof</span> users.toJSON()[ <span class="hljs-number">0</span> ].createdAt ).toBe( <span class="hljs-string">"string"</span> );
</code></pre>
<h3 id="ui-state-and-observable-changes">UI state and observable changes</h3>
<p>Type-R provides the universal technique to working with the UI and domain state. To define the UI state, a developer creates the subclass of the <code>Record</code> with attributes holding all the necessary state data possibly along with the persistent data which can become the part of the same local UI state. The UI state itself can be a part of some particular view or UI component, it can be managed as a singleton (&quot;single source of truth&quot;), or both at the same time. Type-R is unopinionated on the application state structure leaving this decision to the developer.</p>
<p>Records and collections form an aggregation tree with deeply observable changes, so it&#39;s enough to subscribe to the single <code>change</code> event from the <code>UIState</code> to get updates on both data arrival and local changes of the state attributes. Records and collections can be indefinitely nested to describe a state of arbitrary complexity. The developer can attach reactions on changes to the records, their individual attributes, and collections. Additional changes made in reactions will be executed in the scope of the same &quot;change transaction&quot; and won&#39;t trigger additional change events.</p>
<pre><code class="highlight javascript">@define UIState extends Record {
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">selectedUser</span> : <span class="hljs-keyword">from</span>( <span class="hljs-string">'users'</span> )
    }
}

<span class="hljs-keyword">const</span> uiState = <span class="hljs-keyword">new</span> UIState();

uiState.on( <span class="hljs-string">'change'</span>, () =&gt; {
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Something is changed'</span> );
    updateUI();
});

uiState.users.fetch();
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> UIState <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// For collections and more complex types attribute type must be provided explicitly</span>
    <span class="hljs-meta">@type</span>( User.Collection ).as users : Collection&lt;User&gt;

    <span class="hljs-meta">@from</span>( <span class="hljs-string">'users'</span> ).as selectedUser : User
}

<span class="hljs-keyword">const</span> uiState = <span class="hljs-keyword">new</span> UIState();

uiState.on( <span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Something is changed'</span> );
    updateUI();
});

uiState.users.fetch();
</code></pre>
<h3 id="validation">Validation</h3>
<p>Type-R supports validation as attribute-level checks attached to attribute definitions as metadata. Attribute type together with checks forms an &quot;attribute metatype&quot;, which can be defined separately and reused across multiple record definitions.</p>
<p>Validation rules are evaluated recursively on the aggregation tree on first access to the validation API, and validations results are cached in records and collections across the tree till the next update. The validation is automatic, subsequent calls to the validation API are cheap, and the developer doesn&#39;t need to manually trigger the validation on data changes.</p>
<p>The majority of checks in a real application will be a part of attribute &quot;metatypes&quot;, while the custom validation can be also defined on the <code>Record</code> and <code>Collection</code> level to check data integrity and cross-attributes dependencies.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> Email = type( <span class="hljs-built_in">String</span> )
    .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !x || x.indexOf( <span class="hljs-string">'@'</span> ) &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Doesn't look like an email"</span> );

@define User extends Record {
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : type( <span class="hljs-built_in">String</span> ).required,
        <span class="hljs-attr">email</span> : type( Email ).required,
        <span class="hljs-attr">createdAt</span> : type( <span class="hljs-built_in">Date</span> ).check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.getTime() &lt;= <span class="hljs-built_in">Date</span>.now() )
    }
}

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection();
users.add({ <span class="hljs-attr">email</span> : <span class="hljs-string">'john'</span> });
expect( users.isValid() ).toBe( <span class="hljs-literal">false</span> );
expect( users.first().isValid() ).toBe( <span class="hljs-literal">false</span> );

users.first().name = <span class="hljs-string">"John"</span>;
users.first().email = <span class="hljs-string">"john@ny.com"</span>;
expect( users.isValid() ).toBe( <span class="hljs-literal">true</span> );
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-keyword">const</span> Email = <span class="hljs-keyword">type</span>( <span class="hljs-built_in">String</span> )
    .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !x || x.indexOf( <span class="hljs-string">'@'</span> ) &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Doesn't look like an email"</span> );

<span class="hljs-meta">@define</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );

    <span class="hljs-comment">// @type(...).as converts Type-R attribute type definition to the TypeScript decorator.</span>
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">String</span> ).required.as
        name : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@type</span>( Email ).required.as
        email : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">Date</span> ).check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.getTime() &lt;= <span class="hljs-built_in">Date</span>.now() ).as
        createdAt : <span class="hljs-built_in">Date</span>
}

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection();
users.add({ email : <span class="hljs-string">'john'</span> });
expect( users.isValid() ).toBe( <span class="hljs-literal">false</span> );
expect( users.first().isValid() ).toBe( <span class="hljs-literal">false</span> );

users.first().name = <span class="hljs-string">"John"</span>;
users.first().email = <span class="hljs-string">"john@ny.com"</span>;
expect( users.isValid() ).toBe( <span class="hljs-literal">true</span> );
</code></pre>
<h2 id="installation-and-requirements">Installation and requirements</h2>
<p>Is packed as UMD and ES6 module. No peer dependencies are required.</p>
<p><code>npm install type-r --save-dev</code></p>
<aside class="success">IE10+, Edge, Safari, Chrome, and Firefox are supported</aside>

<aside class="warning">IE9 and Opera may work but has not been tested. IE8 won't work.</aside>

<h2 id="reactjs-bindings">ReactJS bindings</h2>
<p><a href="https://volicon.github.io/React-MVx/">React-MVx</a> is a glue framework which uses Type-R to manage the UI state in React and the <a href="https://github.com/Volicon/NestedLink">NestedLink</a> library to implement two-way data binding. React-MVx provides the complete MVVM solution on top of ReactJS, featuring:</p>
<ul>
<li>Type-R <a href="https://volicon.github.io/Type-R/#record">Record</a> to manage the local <a href="https://volicon.github.io/React-MVx/#state">component&#39;s state</a>.</li>
<li><a href="https://volicon.github.io/React-MVx/#link">two-way data binding</a> for UI and domain state.</li>
<li>Hassle-free form validation (due to the combination of features of Type-R and NestedLink).</li>
<li><a href="https://volicon.github.io/Type-R/#definition">Type-R type annotation</a> used to define component <a href="https://volicon.github.io/React-MVx/#props">props</a> and <a href="https://volicon.github.io/React-MVx/#context">context</a>.</li>
</ul>
<h2 id="usage-with-nodejs">Usage with NodeJS</h2>
<p>Type-R can be used at the server side to build the business logic layer by defining the custom I/O endpoints to store data in a database. Type-R dynamic type safety features are particularly advantageous when schema-less JSON databases (like Couchbase) are being used.</p>
<p><img src="images/3-layer-server.png" alt="server"></p>

<h1 id="record">Record</h1>
<p>Record is an optionally persistent class having the predefined set of attributes. Each attribute is the property of known type which is protected from improper assigments at run-time, is serializable to JSON by default, has deeply observable changes, and may have custom validation rules attached.</p>
<p>Records may have other records and collections of records stored in its attributes describing an application state of an arbitrary complexity. These nested records and collections are considered to be an integral part of the parent record forming an <em>aggregation tree</em> which can be serialized to JSON, cloned, and disposed of as a whole.</p>
<p>All aspects of an attribute behavior are controlled with attribute metadata, which (taken together with its type) is called <em>attribite metatype</em>. Metatypes can be declared separately and reused across multiple records definitions.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, type, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-comment">// ⤹ required to make magic work  </span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-comment">// ⤹ attribute's declaration</span>
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">firstName</span> : <span class="hljs-string">''</span>, <span class="hljs-comment">// ⟵ String type is inferred from the default value</span>
        lastName  : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// ⟵ Or you can just mention its constructor</span>
        email     : type(<span class="hljs-built_in">String</span>).value(<span class="hljs-literal">null</span>), <span class="hljs-comment">//⟵ Or you can provide both</span>
        createdAt : <span class="hljs-built_in">Date</span>, <span class="hljs-comment">// ⟵ And it works for any constructor.</span>
        <span class="hljs-comment">// And you can attach ⤹ metadata to fine-tune attribute's behavior</span>
        lastLogin : type(<span class="hljs-built_in">Date</span>).value(<span class="hljs-literal">null</span>).toJSON(<span class="hljs-literal">false</span>) <span class="hljs-comment">// ⟵ not serializable</span>
    }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User();
<span class="hljs-built_in">console</span>.log( user.createdAt ); <span class="hljs-comment">// ⟵ this is an instance of Date created for you.</span>

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection(); <span class="hljs-comment">// ⟵ Collections are defined automatically.</span>
users.on( <span class="hljs-string">'changes'</span>, () =&gt; updateUI( users ) ); <span class="hljs-comment">// ⟵ listen to the changes.</span>

users.set( json, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span> } ); <span class="hljs-comment">// ⟵ parse raw JSON from the server.</span>
users.updateEach( <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.firstName = <span class="hljs-string">''</span> ); <span class="hljs-comment">// ⟵ bulk update triggering 'changes' once</span>
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-keyword">import</span> { define, attr, <span class="hljs-keyword">type</span>, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"reflect-metadata"</span> <span class="hljs-comment">// Required for @auto without arguments</span>

<span class="hljs-comment">// ⤹ required to make the magic work  </span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// ⤹ attribute's declaration</span>
    <span class="hljs-comment">// IMPORTANT: attributes will be initialized even if no default value is provided.</span>
    <span class="hljs-meta">@auto</span> lastName  : <span class="hljs-built_in">string</span> <span class="hljs-comment">// ⟵ @auto decorator extracts type from the Reflect metadata</span>
    <span class="hljs-meta">@auto</span> createdAt : <span class="hljs-built_in">Date</span> <span class="hljs-comment">// ⟵ It works for any constructor.</span>
    <span class="hljs-meta">@auto</span>(<span class="hljs-string">'somestring'</span>) firstName : <span class="hljs-built_in">string</span> <span class="hljs-comment">//⟵ The custom default value must be passed to @auto decorator.</span>
    <span class="hljs-meta">@auto</span>(<span class="hljs-literal">null</span>) updatedAt : <span class="hljs-built_in">Date</span> 

    <span class="hljs-comment">// You have to pass the type explicitly if reflect-metadata is not used.</span>
    <span class="hljs-meta">@type</span>(<span class="hljs-built_in">String</span>).as email : <span class="hljs-built_in">string</span>

    <span class="hljs-comment">// Or, you can tell Type-R to infer type from the default value.</span>
    <span class="hljs-meta">@value</span>(<span class="hljs-string">''</span>).as email2 : <span class="hljs-built_in">string</span>

    <span class="hljs-comment">// Type cannot be inferred from null default values, and needs to be specified explicitly</span>
    <span class="hljs-meta">@type</span>(<span class="hljs-built_in">String</span>).value(<span class="hljs-literal">null</span>).as email3 : <span class="hljs-built_in">string</span> 

    <span class="hljs-comment">// You can attach ⤹ metadata to fine-tune attribute's behavior</span>
    <span class="hljs-meta">@type</span>(<span class="hljs-built_in">Date</span>).toJSON(<span class="hljs-literal">false</span>).as
        lastLogin : <span class="hljs-built_in">Date</span><span class="hljs-comment">// ⟵ not serializable</span>
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User();
<span class="hljs-built_in">console</span>.log(user.createdAt); <span class="hljs-comment">// ⟵ this is an instance of Date created for you.</span>

<span class="hljs-keyword">const</span> users : Collection&lt;User&gt; = <span class="hljs-keyword">new</span> User.Collection(); <span class="hljs-comment">// ⟵ Collections are defined automatically.</span>
users.on(<span class="hljs-string">'changes'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> updateUI(users)); <span class="hljs-comment">// ⟵ listen to the changes.</span>

users.set(json, { parse : <span class="hljs-literal">true</span> }); <span class="hljs-comment">// ⟵ parse raw JSON from the server.</span>
users.updateEach( <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.firstName = <span class="hljs-string">''</span> ); <span class="hljs-comment">// ⟵ bulk update triggering 'changes' once</span>
</code></pre>
<h2 id="definition">Definition</h2>
<p>Record definition is ES6 class extending <code>Record</code> preceeded by <code>@define</code> class decorator. </p>
<p>Unlike in the majority of the JS state management framework, Record is <b>not the key-value hash</b>. Record has typed attributes with metadata controlling different aspects of attribute beavior. Therefore, developer needs to create the Record subclass to describe the data structure of specific shape, in a similar way as it&#39;s done in statically typed languages. The combination of an attribute type and metadata is called <em>metatype</em> and can be reused across record definitions.</p>
<p>The minimal record definition looks like this:</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRecord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> MyRecord <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
}
</code></pre>
<h3 id="static-attributes-name-attrdef-"><code>static</code> attributes = { name : <code>attrDef</code>, ... }</h3>
<p>Record&#39;s attributes definition. Lists attribute names along with their types, default values, and metadata controlling different aspects of attribute behavior.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span>    : type( <span class="hljs-built_in">String</span> ).value( <span class="hljs-string">'John Dow'</span> ),
        <span class="hljs-attr">email</span>   : <span class="hljs-string">'john.dow@mail.com'</span>, <span class="hljs-comment">// Same as type( String ).value( 'john.dow@mail.com' )</span>
        address : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// Same as type( String ).value( '' )</span>
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// You should not use `static attributes` in TypeScript. Use decorators instead.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// Complete form of an attribute definition.</span>
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">String</span> ).value( <span class="hljs-string">'John Dow'</span> ).as name : <span class="hljs-built_in">string</span>,

    <span class="hljs-comment">// Attribute type is inferred from the default value.</span>
    <span class="hljs-meta">@value</span>( <span class="hljs-string">'john.dow@mail.com'</span> ).as email : <span class="hljs-built_in">string</span> , <span class="hljs-comment">// Same as @type( String ).value( 'john.dow@mail.com' ).as</span>

    <span class="hljs-comment">// Attribute type is inferred from the TypeScript type declaration.</span>
    <span class="hljs-meta">@auto</span> address : <span class="hljs-built_in">string</span>, <span class="hljs-comment">// Same as @type( String ).value( '' )</span>

    <span class="hljs-comment">// Same as above, but with a custom default value.</span>
    <span class="hljs-meta">@auto</span>( <span class="hljs-string">'john.dow@mail.com'</span> ) email2 : <span class="hljs-built_in">string</span> <span class="hljs-comment">// Same as @value( 'john.dow@mail.com' ).as</span>
}

</code></pre>
<p>The Record guarantee that <em>every attribute will retain the value of the declared type</em>. Whenever an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: <code>new Type( value )</code> (primitive types are treated specially).</p>
<h3 id="static-idattribute-attrname-"><code>static</code> idAttribute = &#39;attrName&#39;</h3>
<p>A record&#39;s unique identifier is stored under the pre-defined <code>id</code> attribute.
If you&#39;re directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record&#39;s <code>idAttribute</code> to transparently map from that key to id.</p>
<p>Record&#39;s <code>id</code> property will still be linked to Record&#39;s id, no matter which value <code>idAttribute</code> has.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
  <span class="hljs-keyword">static</span> idAttribute =  <span class="hljs-string">"_id"</span>;
  <span class="hljs-keyword">static</span> attributes = {
      <span class="hljs-attr">_id</span> : <span class="hljs-built_in">Number</span>,
      <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
  }
}

<span class="hljs-keyword">const</span> cake = <span class="hljs-keyword">new</span> Meal({ <span class="hljs-attr">_id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"Cake"</span> });
alert(<span class="hljs-string">"Cake id: "</span> + cake.id);
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Meal <span class="hljs-keyword">extends</span> Record {
  <span class="hljs-keyword">static</span> idAttribute =  <span class="hljs-string">"_id"</span>;

  <span class="hljs-meta">@auto</span> _id : <span class="hljs-built_in">number</span>
  <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> cake = <span class="hljs-keyword">new</span> Meal({ _id: <span class="hljs-number">1</span>, name: <span class="hljs-string">"Cake"</span> });
alert(<span class="hljs-string">"Cake id: "</span> + cake.id);
</code></pre>
<h3 id="attrdef-constructor"><code>attrDef</code> : Constructor</h3>
<p>Constructor function is the simplest form of attribute definition. Any constructor function which behaves as <em>converting constructor</em> (like <code>new Date( msecs )</code>) may be used as an attribute type.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// String attribute which is "" by default.</span>
        createdAt : <span class="hljs-built_in">Date</span>, <span class="hljs-comment">// Date attribute</span>
        ...
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// In typescript, @auto decorator will extract constructor function from the TypeScript type</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Person <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span> <span class="hljs-comment">// String attribute which is "" by default.</span>
    <span class="hljs-meta">@auto</span> createdAt : <span class="hljs-built_in">Date</span> <span class="hljs-comment">// Date attribute</span>

    <span class="hljs-comment">// Or, it can be specified explicitly with @type decorator.</span>
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">Date</span> ).as updatedAt : <span class="hljs-built_in">Date</span> <span class="hljs-comment">// Date attribute</span>
    ...
}
</code></pre>
<h3 id="attrdef-defaultvalue"><code>attrDef</code> : defaultValue</h3>
<p>Any non-function value used as attribute definition is treated as an attribute&#39;s default value. Attribute&#39;s type is being inferred from the value.</p>
<p>Type cannot be properly inferred from the <code>null</code> values and functions.
Use the general form of attribute definition in such cases: <code>value( theFunction )</code>, <code>type( Boolean ).value( null )</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GridColumn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>, <span class="hljs-comment">// String attribute which is '' by default.</span>
        render : value( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ), <span class="hljs-comment">// Infer Function type from the default value.</span>
        ...
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// In typescript, @value decorator will extract constructor function from the default value.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> GridColumn <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@value</span>( <span class="hljs-string">''</span> ).as name : <span class="hljs-built_in">string</span> <span class="hljs-comment">// String attribute which is '' by default.</span>
    <span class="hljs-meta">@value</span>( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ).as render : <span class="hljs-built_in">Function</span>
    ...
}
</code></pre>
<h3 id="attrdef-type-constructor-value-defaultvalue-"><code>attrDef</code> : type(Constructor).value(defaultValue)</h3>
<p>Declare an attribute with type T having the custom <code>defaultValue</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">phone</span> : type( <span class="hljs-built_in">String</span> ).value( <span class="hljs-literal">null</span> ) <span class="hljs-comment">// String attribute which is null by default.</span>
        ...
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Person <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">String</span> ).value( <span class="hljs-literal">null</span> ).as phone : <span class="hljs-built_in">string</span> <span class="hljs-comment">// String attribute which is null by default.</span>

    <span class="hljs-comment">// There's an easy way of doing that in TypeScript.</span>
    <span class="hljs-meta">@auto</span>( <span class="hljs-literal">null</span> ).as phone : <span class="hljs-built_in">string</span>
    ...
}
</code></pre>
<p>If record needs to reference itself in its attributes definition, <code>@predefine</code> decorator with subsequent <code>MyRecord.define()</code> needs to be used.</p>
<h3 id="attrdef-date"><code>attrDef</code> : Date</h3>
<p>Date attribute initialized as <code>new Date()</code>, and represented in JSON as UTC ISO string.</p>
<p>There are other popular Date serialization options available in <code>type-r/ext-types</code> package.</p>
<ul>
<li><code>MicrosoftDate</code> - Date serialized as Microsoft&#39;s <code>&quot;/Date(msecs)/&quot;</code> string.</li>
<li><code>Timestamp</code> - Date serializaed as UNIX integer timestamp (<code>date.getTime()</code>).</li>
</ul>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Person <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> justDate : <span class="hljs-built_in">Date</span>
    <span class="hljs-comment">// MicrosoftDate is an attribute metatype, not a real type, so you must pass it explictly.</span>
    <span class="hljs-meta">@type</span>( Timestamp ).as createdAt : <span class="hljs-built_in">Date</span>
    ...
}
</code></pre>
<h3 id="static-collection"><code>static</code> Collection</h3>
<p>The default record&#39;s collection class automatically defined for every Record subclass. Can be referenced as <code>Record.Collection</code>.</p>
<p>May be explicitly assigned in record&#39;s definition with custom collection class.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Declare the collection class.</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comments</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{
    <span class="hljs-keyword">static</span> Collection = Comments; <span class="hljs-comment">// Make it the default Comment collection.</span>

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">text</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">replies</span> : Comments
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// Declare the collection class.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Comments <span class="hljs-keyword">extends</span> Collection&lt;Comment&gt; {}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Comment <span class="hljs-keyword">extends</span> Record{
    <span class="hljs-keyword">static</span> Collection = Comments; <span class="hljs-comment">// Make it the default Comment collection.</span>

    <span class="hljs-meta">@auto</span> text : <span class="hljs-built_in">String</span>
    <span class="hljs-meta">@auto</span> replies : Comments
}
</code></pre>
<h3 id="attrdef-type-type-"><code>attrDef</code> type(Type)</h3>
<p>Attribute definition can have different metadata attached which affects various aspects of attribute&#39;s behavior. Metadata is attached with
a chain of calls after the <code>type( Ctor )</code> call. Attribute&#39;s default value is the most common example of such a metadata and is the single option which can be applied to the constructor function directly.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, type, Record }

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dummy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : type( <span class="hljs-built_in">String</span> ).value( <span class="hljs-string">"a"</span> )
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-keyword">import</span> { define, <span class="hljs-keyword">type</span>, Record }

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Dummy <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">String</span> ).value( <span class="hljs-string">"a"</span> ).as a : <span class="hljs-built_in">string</span>
}
</code></pre>
<h2 id="definitions-in-typescript">Definitions in TypeScript</h2>
<p>Type-R supports several options to define record attributes.</p>
<h3 id="decorator-auto"><code>decorator</code> @auto</h3>
<p>Turns TypeScript class property definition to the record&#39;s attribute, automatically extracting attribute type from the TypeScript type annotation. Requires <code>reflect-metadata</code> npm package and <code>emitDecoratorMetadata</code> option set to true in the <code>tsconfig.json</code>.</p>
<p><code>@auto</code> may take a single parameter as an attribute default value. No other attribute metadata can be attached.</p>
<pre><code class="highlight typescript"><span class="hljs-keyword">import</span> { define, auto, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span>( <span class="hljs-string">"john@verizon.com"</span> ) email : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span>( <span class="hljs-literal">null</span> ) updatedAt : <span class="hljs-built_in">Date</span>
}
</code></pre>
<h3 id="decorator-attrdef-as"><code>decorator</code> @<code>attrDef</code>.as</h3>
<p>Attribute definition creates the TypeScript property decorator when being appended with <code>.as</code> suffix. It&#39;s an alternative syntax to <code>@auto</code>.</p>
<pre><code class="highlight typescript"><span class="hljs-keyword">import</span> { define, <span class="hljs-keyword">type</span>, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@value</span>( <span class="hljs-string">"5"</span> ).as name : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@type</span>( <span class="hljs-built_in">String</span> ).toJSON( <span class="hljs-literal">false</span> ).as email : <span class="hljs-built_in">string</span>
}
</code></pre>
<h2 id="create-and-dispose">Create and dispose</h2>
<p>Record behaves as regular ES6 class with attributes accessible as properties.</p>
<h3 id="new-record-">new Record()</h3>
<p>Create an instance of the record with default attribute values taken from the attributes definition.</p>
<p>When no default value is explicitly provided for an attribute, it&#39;s initialized as <code>new Type()</code> (just <code>Type()</code> for primitives). When the default value is provided and it&#39;s not compatible with the attribute type, it&#39;s converted with <code>new Type( defaultValue )</code> call.</p>
<h3 id="new-record-attrname-value-options-">new Record({ attrName : value, ... }, options?)</h3>
<p>When creating an instance of a record, you can pass in the initial attribute values to override the defaults.</p>
<p>If <code>{parse: true}</code> option is used, <code>attrs</code> is assumed to be the JSON.</p>
<p>If the value of the particular attribute is not compatible with its type, it&#39;s converted to the declared type invoking the constructor <code>new Type( value )</code> (just <code>Type( value )</code> for primitives).</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span>  : <span class="hljs-string">''</span>,
        <span class="hljs-attr">author</span> : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book({
  <span class="hljs-attr">title</span>: <span class="hljs-string">"One Thousand and One Nights"</span>,
  <span class="hljs-attr">author</span>: <span class="hljs-string">"Scheherazade"</span>
});
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Book <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> title : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span> author : <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book({
  title: <span class="hljs-string">"One Thousand and One Nights"</span>,
  author: <span class="hljs-string">"Scheherazade"</span>
});
</code></pre>
<h3 id="record-clone-">record.clone()</h3>
<p>Create the deep copy of the aggregation tree, recursively cloning all aggregated records and collections. References to shared members will be copied, but not shared members themselves.</p>
<h3 id="callback-record-initialize-attrs-options-"><code>callback</code> record.initialize(attrs?, options?)</h3>
<p>Called at the end of the <code>Record</code> constructor when all attributes are assigned and the record&#39;s inner state is properly initialized. Takes the same arguments as
a constructor.</p>
<h3 id="record-dispose-">record.dispose()</h3>
<p>Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It&#39;s crucial to prevent memory leaks in SPA.</p>
<p>The whole aggregation tree will be recursively disposed, shared members won&#39;t.</p>
<h2 id="read-and-update">Read and Update</h2>
<h3 id="record-cid">record.cid</h3>
<p>Read-only client-side record&#39;s identifier. Generated upon creation of the record and is unique for every record&#39;s instance. Cloned records will have different <code>cid</code>.</p>
<h3 id="record-id">record.id</h3>
<p>Predefined record&#39;s attribute, the <code>id</code> is an arbitrary string (integer id or UUID). <code>id</code> is typically generated by the server. It is used in JSON for id-references.</p>
<p>Records can be retrieved by <code>id</code> from collections, and there can be just one instance of the record with the same <code>id</code> in the particular collection.</p>
<h3 id="record-isnew-">record.isNew()</h3>
<p>Has this record been saved to the server yet? If the record does not yet have an <code>id</code>, it is considered to be new.</p>
<h3 id="record-attrname">record.attrName</h3>
<p>Record&#39;s attributes may be directly accessed as <code>record.name</code>.</p>
<aside class="warning">Please note, that you *have to declare all attributes* in `static attributes` declaration.</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">balance</span> : <span class="hljs-built_in">Number</span>
    }
}

<span class="hljs-keyword">const</span> myAccount = <span class="hljs-keyword">new</span> Account({ <span class="hljs-attr">name</span> : <span class="hljs-string">'mine'</span> });
myAccount.balance += <span class="hljs-number">1000000</span>; <span class="hljs-comment">// That works. Good, eh?</span>
</code></pre>
<h3 id="record-attrname-value">record.attrName = value</h3>
<p>Assign the record&#39;s attribute. If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types;</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place);</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events on changes:</p>
<ul>
<li><code>change:attrName</code> <em>( record, value )</em>.</li>
<li><code>change</code> <em>( record )</em>.</li>
</ul>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">author</span> : <span class="hljs-built_in">String</span>
        price : <span class="hljs-built_in">Number</span>,
        <span class="hljs-attr">publishedAt</span> : <span class="hljs-built_in">Date</span>,
        <span class="hljs-attr">available</span> : <span class="hljs-built_in">Boolean</span>
    }
}

<span class="hljs-keyword">const</span> myBook = <span class="hljs-keyword">new</span> Book({ <span class="hljs-attr">title</span> : <span class="hljs-string">"State management with Type-R"</span> });
myBook.author = <span class="hljs-string">'Vlad'</span>; <span class="hljs-comment">// That works.</span>
myBook.price = <span class="hljs-string">'Too much'</span>; <span class="hljs-comment">// Converted with Number( 'Too much' ), resulting in NaN.</span>
myBook.price = <span class="hljs-string">'123'</span>; <span class="hljs-comment">// = Number( '123' ).</span>
myBook.publishedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// Type is compatible, no conversion.</span>
myBook.publishedAt = <span class="hljs-string">'1678-10-15 12:00'</span>; <span class="hljs-comment">// new Date( '1678-10-15 12:00' )</span>
myBook.available = some &amp;&amp; weird || condition; <span class="hljs-comment">// Will always be Boolean. Or null.</span>
</code></pre>
<h3 id="record-set-attrname-value-options-options-">record.set({ attrName : value, ... }, options? : <code>options</code>)</h3>
<p>Bulk assign record&#39;s attributes, possibly taking options.</p>
<p>If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types.</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place).</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events after all changes are applied:</p>
<ol>
<li><code>change:attrName</code> <em>( record, val, options )</em> for any changed attribute.</li>
<li><code>change</code> <em>(record, options)</em>, if there were changed attributes.</li>
</ol>
<h3 id="recordclass-from-attrs-options-">RecordClass.from(attrs, options?)</h3>
<p>Create <code>RecordClass</code> from attributes. Similar to direct record creation, but supports additional option for strict data validation.
If <code>{ strict : true }</code> option is passed the validation will be performed and an exception will be thrown in case of an error.</p>
<p>Please note, that Type-R always perform type checks on assignments, convert types, and reject improper updates reporting it as error. It won&#39;t, however, execute custom validation
rules on every updates as they are evaluated lazily. <code>strict</code> option will invoke custom validators and will throw on every error or warning instead of reporting them and continue.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Fetch record with a given id.</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> Book.from({ <span class="hljs-attr">id</span> : <span class="hljs-number">5</span> }).fetch();

<span class="hljs-comment">// Validate the body of an incoming HTTP request.</span>
<span class="hljs-comment">// Throw an exception if validation fails.</span>
<span class="hljs-keyword">const</span> body = MyRequestBody.from( ctx.request.body, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span>, <span class="hljs-attr">strict</span> : <span class="hljs-literal">true</span> });
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// Fetch record with a given id.</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> Book.from({ id : <span class="hljs-number">5</span> }).fetch();

<span class="hljs-comment">// Validate the body of an incoming HTTP request.</span>
<span class="hljs-comment">// Throw an exception if validation fails.</span>
<span class="hljs-keyword">const</span> body = MyRequestBody.from( ctx.request.body, { parse : <span class="hljs-literal">true</span>, strict : <span class="hljs-literal">true</span> });
</code></pre>
<h3 id="record-assignfrom-otherrecord-">record.assignFrom(otherRecord)</h3>
<p>Makes an existing <code>record</code> to be the full clone of <code>otherRecord</code>, recursively assigning all attributes.
In contracts to <code>record.clone()</code>, the record is updated in place.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.assignFrom(bestSeller);
</code></pre>
<h3 id="record-transaction-fun-">record.transaction(fun)</h3>
<p>Execute the all changes made to the record in <code>fun</code> as single transaction triggering the single <code>change</code> event.</p>
<p>All record updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>change</code> event.
Transaction can be opened either manually or implicitly with calling <code>set()</code> or assigning an attribute.
Any additional changes made to the record in <code>change:attr</code> event handler will be executed in the scope of the original transaction, and won&#39;t trigger additional <code>change</code> events.</p>
<pre><code class="highlight javascript">some.record.transaction( <span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> {
    record.a = <span class="hljs-number">1</span>; <span class="hljs-comment">// `change:a` event is triggered.</span>
    record.b = <span class="hljs-number">2</span>; <span class="hljs-comment">// `change:b` event is triggered.</span>
}); <span class="hljs-comment">// `change` event is triggered.</span>
</code></pre>
<p>Manual transactions with attribute assignments are superior to <code>record.set()</code> in terms of both performance and flexibility.</p>
<h3 id="attrdef-type-type-get-hook-"><code>attrDef</code> : type(Type).get(<code>hook</code>)</h3>
<p>Attach get hook to the record&#39;s attribute. <code>hook</code> is the function of signature <code>( value, attr ) =&gt; value</code> which is used to transform the attribute&#39;s value <em>before it will be read</em>. Hook is executed in the context of the record.</p>
<h3 id="attrdef-type-type-set-hook-"><code>attrDef</code> : type(Type).set(<code>hook</code>)</h3>
<p>Attach the set hook to the record&#39;s attribute. <code>hook</code> is the function of signature <code>( value, attr ) =&gt; value</code> which is used to transform the attribute&#39;s value <em>before it will be assigned</em>. Hook is executed in the context of the record.</p>
<p>If set hook will return <code>undefined</code>, it will cancel attribute update.</p>
<h2 id="nested-records-and-collections">Nested records and collections</h2>
<p>Record&#39;s attributes can hold other Records and Collections, forming indefinitely nested data structures of arbitrary complexity.
To create nested record or collection you should just mention its constructor function in attribute&#39;s definition.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">email</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">isActive</span> : <span class="hljs-literal">true</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection
    }
}
</code></pre>
<p>All nested records and collections are <em>aggregated</em> by default and behave as integral parts of the containing record. Aggregated attributes are <em>exclusively owned</em> by the record, and taken with it together form an <em>ownership tree</em>. Many operations are performed recursively on aggregated elements:</p>
<ul>
<li>They are created when the owner record is created.</li>
<li>They are cloned when the record is cloned.</li>
<li>They are disposed when the record is disposed.</li>
<li>They are validated as part of the record.</li>
<li>They are serialized as nested JSON.</li>
</ul>
<p>The nature of aggregation relationship in OO is explained in this <a href="https://medium.com/@gaperton/nestedtypes-2-0-meet-an-aggregation-and-the-rest-of-oo-animals-a9fca7c36ecf">article</a>.</p>
<h3 id="attrdef-recordorcollection"><code>attrDef</code> : RecordOrCollection</h3>
<p>Aggregated record or collection. Represented as nested object or array in record&#39;s JSON. Aggregated members are owned by the record and treated as its <em>integral part</em> (recursively created, cloned, serialized, validated, and disposed).
One object can have single owner. The record with its aggregated attributes forms an <em>aggregation tree</em>.</p>
<p>All changes in aggregated record or collections are detected and cause change events on the containing record.</p>
<h3 id="record-getowner-">record.getOwner()</h3>
<p>Return the record which is an owner of the current record, or <code>null</code> there are no one.</p>
<p>Due to the nature of <em>aggregation</em>, an object may have one and only one owner.</p>
<h3 id="record-collection">record.collection</h3>
<p>Return the collection which aggregates the record, or <code>null</code> if there are no one.</p>
<h3 id="attrdef-shared-recordorcollection-"><code>attrDef</code> : shared(RecordOrCollection)</h3>
<p>Non-serializable reference to the record or collection possibly from the different aggregation tree. Initialized with <code>null</code>. Is not recursively cloned, serialized, validated, or disposed.</p>
<p>All changes in shared records or collections are detected and cause change events of the containing record.</p>
<aside class="notice">The type of <code>attrDef</code>{ name : defaultValue } is inferred as `shared( Type )` if it extends Record or Collection</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">selected</span> : shared( User ) <span class="hljs-comment">// Can be assigned with the user from this.users</span>
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> UsersListState <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@type</span>( User.Collection ).as users : Collection&lt;User&gt;,
    <span class="hljs-meta">@shared</span>( User ).as selected : User <span class="hljs-comment">// Can be assigned with the user from this.users</span>
}
</code></pre>
<h3 id="attrdef-collection-refs"><code>attrDef</code> : Collection.Refs</h3>
<p>Non-aggregating collection. Collection of references to shared records which itself is <em>aggregated</em> by the record, but <em>does not aggregate</em> its elements. In contrast to the <code>shared( Collection )</code>, <code>Collection.Refs</code> is an actual constructor and creates an instance of collection which <em>is the part the parent record</em>.</p>
<p>The collection itself is recursively created and cloned. However, its records are not aggregated by the collection thus they are not recursively cloned, validated, serialized, or disposed.</p>
<p>All changes in the collection and its elements are detected and cause change events of the containing record.</p>
<aside class="notice"><code>Collection.Refs</code> is the constructor and can be used to create non-aggregating collection with `new` operator.</aside>

<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRecord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        <span class="hljs-keyword">static</span> attributes = {
            <span class="hljs-attr">notCloned</span> : shared( SomeCollection ), <span class="hljs-comment">// Reference to the _shared collection_ object.</span>
            cloned : SomeCollection.Refs <span class="hljs-comment">// _Aggregated_ collection of references to the _shared records_.</span>
        }
    }
</code></pre>
<pre><code class="highlight typescript">    <span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> MyRecord <span class="hljs-keyword">extends</span> Record {
        <span class="hljs-comment">// Reference to the _shared collection_ object.</span>
        <span class="hljs-meta">@shared</span>( SomeCollection ).as notCloned : Collection&lt;Some&gt;

        <span class="hljs-comment">// _Aggregated_ collection of references to the _shared records_.</span>
        <span class="hljs-meta">@type</span>( SomeCollection.Refs ).as cloned : SomeCollection
    }
</code></pre>
<h3 id="decorator-predefine"><code>decorator</code> @predefine</h3>
<p>Make forward declaration for the record to define its attributes later with <code>RecordClass.define()</code>. Used instead of <code>@define</code> for recursive record definitions.</p>
<p>Creates the default <code>RecordClass.Collection</code> type which can be referenced in attribute definitions.</p>
<h3 id="static-define-attributes-name-attrdef-"><code>static</code> define({ attributes : { name : <code>attrDef</code>, ... }})</h3>
<p>May be called to define attributes in conjunction with <code>@predefine</code> decorator to make recursive record definitions.</p>
<pre><code class="highlight javascript">@predefine <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{}

Comment.define({
    <span class="hljs-attr">attributes</span> : {
        <span class="hljs-attr">text</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">replies</span> : Comment.Collection
    }
});
</code></pre>
<h1 id="collection">Collection</h1>
<p>Collections are ordered sets of records. The collection is an array-like object exposing ES6 Array and BackboneJS Collection interface. It encapsulates JS Array of records (<code>collection.models</code>) and a hashmap for a fast O(1) access by the record <code>id</code> and <code>cid</code> (<code>collection.get( id )</code>).</p>
<p>Collactions are deeply observable. You can bind &quot;changes&quot; events to be notified when the collection has been modified, listen for the record &quot;add&quot;,  &quot;remove&quot;, and &quot;change&quot; events.</p>
<p>Every <code>Record</code> class has an implicitly defined <code>Collection</code> accessible as a static member of a record&#39;s constructor. In a most cases, you don&#39;t need to define the custom collection class.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span> : <span class="hljs-built_in">String</span>
        author : Author
    }
}

<span class="hljs-comment">// Implicitly defined collection.</span>
<span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> Book.Collection();
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Book <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> title : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@auto</span> author : Author

    <span class="hljs-comment">// Tell TypeScript the proper type.</span>
    <span class="hljs-keyword">static</span> Collection : CollectionConstructor&lt;Book&gt;
}

<span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> Book.Collection();
</code></pre>
<p>You can define custom collection classes extending <code>Record.Collection</code> or any other collection class. It can either replace the default Collection type, or </p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define custom collection class.</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{
    doSomething(){ ... }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-comment">// Override the default collection.</span>
    <span class="hljs-keyword">static</span> Collection = Library;
}

<span class="hljs-comment">// Define another custom collection class.</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherLibrary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{
    <span class="hljs-comment">// Specify the record so the collection will be able to restore itself from JSON.</span>
    <span class="hljs-keyword">static</span> model = Book; 
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// Define custom collection class.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Library <span class="hljs-keyword">extends</span> Collection&lt;Book&gt; {
    doSomething(){ ... }
}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Book <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// Override the default collection.</span>
    <span class="hljs-keyword">static</span> Collection = Library;
}

<span class="hljs-comment">// Define another custom collection class.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> OtherLibrary <span class="hljs-keyword">extends</span> Collection&lt;Book&gt; {
    <span class="hljs-comment">// Specify the record so the collection will be able to restore itself from JSON.</span>
    <span class="hljs-keyword">static</span> model = Book;
}

<span class="hljs-comment">// An alternative way of overriding the default collection class in TypeScript.</span>
<span class="hljs-keyword">namespace</span> Book {
    <span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Collection <span class="hljs-keyword">extends</span> Collection&lt;Book&gt; {
        <span class="hljs-keyword">static</span> model = Book;
    }
}
</code></pre>
<aside class="notice">
The collection must know the type of its records to restore its elements from JSON properly. When the `model` is not specified, the collection can hold any Record subclass but it cannot deserialize itself.
</aside>

<h2 id="collection-types">Collection types</h2>
<h3 id="constructor-collectionclass-records-options-"><code>constructor</code> CollectionClass( records?, options? )</h3>
<p>The most common collection type is an <strong>aggregating serializable collection</strong>. By default, collection aggregates its elements which are treated as an integral part of the collection (serialized, cloned, disposed, and validated recursively). An aggregation means the <em>single owner</em>, as the single object cannot be an integral part of two distinct things. The collection will take ownership on its records and will put an error in the console if it can&#39;t.</p>
<p>When creating a Collection, you may choose to pass in the initial array of records.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>
    }
}

<span class="hljs-keyword">const</span> roles = <span class="hljs-keyword">new</span> Role.Collection( json, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span> } );
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Role <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// In typescript, you have to specify record's Collection type expicitly.</span>
    <span class="hljs-keyword">static</span> Collection : CollectionConstructor&lt;Role&gt;

    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>

    <span class="hljs-comment">// Type-R cannot infer a Collection metatype from the TypeScript type automatically.</span>
    <span class="hljs-comment">// Full attribute type annotation is required.</span>
    <span class="hljs-meta">@type</span>( Role.Collection ).as roles : Collection&lt;User&gt;
}
</code></pre>
<h3 id="constructor-collectionclass-refs-records-options-"><code>constructor</code> CollectionClass.Refs( records?, options? )</h3>
<p>Collection of record references is a <strong>non-aggregating non-serializable collection</strong>. <code>Collection.Refs</code> doesn&#39;t aggregate its elements, which means that containing records are not considered as an integral part of the enclosing collection and not being validated, cloned, disposed, and serialized recursively.</p>
<p>It is useful for a local non-persistent application state.</p>
<h3 id="attrdef-subsetof-masterref-collectionclass-"><code>attrDef</code> subsetOf(masterRef, CollectionClass?)</h3>
<p>The subset of other collections are <strong>non-aggregating serializable collection</strong>. Subset-of collection is serialized as an array of record ids and used to model many-to-many relationships. The collection object itself is recursively created and cloned, however, its records are not aggregated by the collection thus they are not recursively cloned, validated, or disposed. <code>CollectionClass</code> argument may be omitted unless you need the record&#39;s attribute to be an instance of the particular collection class.</p>
<aside class="notice">
<b>subsetOf</b> collections are not deeply observable.
</aside>

<aside class="notice">
Since its an attribute <i>metatype</i> (combination of type and attribute metadata), it's not a real constructor and cannot be used with <b>new</b>. Use <b>collection.createSubset()</b> method to create subset-of collection instances.
</aside>

<p>Must have a reference to the master collection which is used to resolve record ids to records. <code>masterRef</code> may be:</p>
<ul>
<li>direct reference to a singleton collection.</li>
<li>function, returning the reference to the collection.</li>
<li>symbolic dot-separated path to the master collection resolved relative to the record&#39;s <code>this</code>. You may use <code>owner</code> and <code>store</code> macro in path:<ul>
<li><code>owner</code> is the reference to the record&#39;s owner. <code>owner.some.path</code> works as <code>() =&gt; this.getOwner().some.path</code>.</li>
<li><code>store</code> is the reference to the closes store. <code>store.some.path</code> works as <code>() =&gt; this.getStore().some.path</code>.</li>
</ul>
</li>
</ul>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">roles</span> : subsetOf( <span class="hljs-string">'owner.roles'</span>, Role.Collection )
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersDirectory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">roles</span> : Role.Collection,
        <span class="hljs-attr">users</span> : User.Collection <span class="hljs-comment">// `~roles` references will be resolved against this.roles</span>
    }
}
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Role <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-keyword">static</span> Collection : CollectionConstructor&lt;Role&gt;

    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
    ...
}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-keyword">static</span> Collection : CollectionConstructor&lt;User&gt;

    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
    <span class="hljs-meta">@subsetOf</span>(<span class="hljs-string">'store.roles'</span>).as roles : Collection&lt;Role&gt;
}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> UsersDirectory <span class="hljs-keyword">extends</span> Store {
    <span class="hljs-meta">@type</span>(Role.Collection).as roles : Collection&lt;Role&gt;,
    <span class="hljs-meta">@type</span>(User.Collection).as users : Collection&lt;User&gt; <span class="hljs-comment">// &lt;- `store.roles` references will be resolved against this.roles</span>
}
</code></pre>
<h2 id="array-api">Array API</h2>
<p>A collection class is an array-like object implementing ES6 Array methods and properties.</p>
<h3 id="collection-length">collection.length</h3>
<p>Like an array, a Collection maintains a length property, counting the number of records it contains.</p>
<h3 id="collection-slice-begin-end-">collection.slice( begin, end )</h3>
<p>Return a shallow copy of the <code>collection.models</code>, using the same options as native Array#slice.</p>
<h3 id="collection-indexof-recordorid-any-number">collection.indexOf( recordOrId : any ) : number</h3>
<p>Return an index of the record in the collection, and -1 if there is no such a record in the collection.</p>
<p>Can take the record itself as an argument, <code>id</code>, or <code>cid</code> of the record.</p>
<h3 id="collection-foreach-iteratee-val-record-index-void-context-">collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Iterate through the elements of the collection.</p>
<aside class="notice">Use <code>collection.updateEach( iteratee, index )</code> method to update records in a loop.</aside>

<h3 id="collection-map-iteratee-val-record-index-t-context-">collection.map( iteratee : ( val : Record, index ) =&gt; T, context? )</h3>
<p>Map elements of the collection. Similar to <code>Array.map</code>.</p>
<h3 id="collection-filter-iteratee-predicate-context-">collection.filter( iteratee : Predicate, context? )</h3>
<p>Return the filtered array of records matching the predicate.</p>
<p>The predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record&#39;s attributes.</p>
<h3 id="collection-every-iteratee-predicate-context-boolean">collection.every( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if all records match the predicate.</p>
<h3 id="collection-some-iteratee-predicate-context-boolean">collection.some( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if at least one record matches the predicated.</p>
<h3 id="collection-push-record-options-">collection.push( record, options? )</h3>
<p>Add a record at the end of a collection. Takes the same options as <code>add()</code>.</p>
<h3 id="collection-pop-options-">collection.pop( options? )</h3>
<p>Remove and return the last record from a collection. Takes the same options as <code>remove()</code>.</p>
<h3 id="collection-unshift-record-options-">collection.unshift( record, options? )</h3>
<p>Add a record at the beginning of a collection. Takes the same options as <code>add()</code>.</p>
<h3 id="collection-shift-options-">collection.shift( options? )</h3>
<p>Remove and return the first record from a collection. Takes the same options as <code>remove()</code>.</p>
<h2 id="backbone-api">Backbone API</h2>
<p>Common options used by Backbone API methods:</p>
<ul>
<li><code>{ sort : false }</code> - do not sort the collection.</li>
<li><code>{ parse : true }</code> - parse raw JSON (used to set collection with data from the server).</li>
</ul>
<h3 id="callback-collection-initialize-records-options-"><code>callback</code> collection.initialize( records?, options? )</h3>
<p>Initialization function which is called at the end of the constructor.</p>
<h3 id="collection-clone-">collection.clone()</h3>
<p>Clone the collection. An aggregating collection will be recursively cloned, non-aggregated collections will be shallow cloned.</p>
<h3 id="collection-models">collection.models</h3>
<p>Raw access to the JavaScript array of records inside of the collection. Usually, you&#39;ll want to use <code>get</code>, <code>at</code>, or the other methods to access record objects, but occasionally a direct reference to the array is desired.</p>
<h3 id="collection-get-id-">collection.get( id )</h3>
<p>Get a record from a collection, specified by an <code>id</code>, a <code>cid</code>, or by passing in a record.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> book = library.get(<span class="hljs-number">110</span>);
</code></pre>
<h3 id="collection-at-index-">collection.at( index )</h3>
<p>Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn&#39;t sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection.</p>
<h3 id="collection-add-records-options-">collection.add( records, options? )</h3>
<p>Add a record (or an array of records) to the collection. If this is the <code>Record.Collection</code>, you may also pass raw attributes objects, and have them be vivified as instances of the <code>Record</code>. Returns the added (or preexisting, if duplicate) records.</p>
<p>Pass <code>{at: index}</code> to splice the record into the collection at the specified index. If you&#39;re adding records to the collection that are already in the collection, they&#39;ll be ignored, unless you pass <code>{merge: true}</code>, in which case their attributes will be merged into the corresponding records.</p>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>change</code>(record, options) for each record changed (if the <code>{merge: true}</code> option is passed).</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<h3 id="collection-remove-records-options-">collection.remove( records, options? )</h3>
<p>Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get.</p>
<ol>
<li>Trigger <code>remove</code>(record, collection, options) for each record removed.</li>
<li>If any records were removed, trigger:<ul>
<li><code>update</code>(collection, options)</li>
<li><code>changes</code>(collection, options).</li>
</ul>
</li>
</ol>
<h3 id="collection-set-records-options-">collection.set( records, options? )</h3>
<p>The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn&#39;t yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren&#39;t present in the list, they&#39;ll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you&#39;d like to customize the behavior, you can disable it with options: <code>{remove: false}</code>, or <code>{merge: false}</code>.</p>
<h4 id="events">Events</h4>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>remove</code>(record, collection, options) for each record removed.</li>
<li><code>change</code>(record, options) for each record changed.</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> vanHalen = <span class="hljs-keyword">new</span> Man.Collection([ eddie, alex, stone, roth ]);

vanHalen.set([ eddie, alex, stone, hagar ]);

<span class="hljs-comment">// Fires a "remove" event for roth, and an "add" event for hagar.</span>
<span class="hljs-comment">// Updates any of stone, alex, and eddie's attributes that may have</span>
<span class="hljs-comment">// changed over the years.</span>
</code></pre>
<h3 id="collection-reset-records-options-">collection.reset(records, options?)</h3>
<p>Replace the collection&#39;s content with the new records. More efficient than <code>collection.set</code>, but does not send record-level events.</p>
<p>Calling <code>collection.reset()</code> without passing any records as arguments will empty the entire collection.</p>
<ol>
<li>Trigger event <code>reset</code>(collection, options).</li>
<li>Trigger event <code>changes</code>(collection, options).</li>
</ol>
<h3 id="collection-pluck-attribute-">collection.pluck(attribute)</h3>
<p>Pluck an attribute from each model in the collection. Equivalent to calling map and returning a single attribute from the iterator.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> UserCollection([
  {<span class="hljs-attr">name</span>: <span class="hljs-string">"Curly"</span>},
  {<span class="hljs-attr">name</span>: <span class="hljs-string">"Larry"</span>},
  {<span class="hljs-attr">name</span>: <span class="hljs-string">"Moe"</span>}
]);

<span class="hljs-keyword">const</span> names = users.pluck(<span class="hljs-string">"name"</span>);

alert(<span class="hljs-built_in">JSON</span>.stringify(names));
</code></pre>
<h2 id="sorting">Sorting</h2>
<p>Type-R implements BackboneJS Collection sorting API with some extensions.</p>
<h3 id="collection-sort-options-">collection.sort(options?)</h3>
<p>Force a collection to re-sort itself. You don&#39;t need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a record is added. To disable sorting when adding a record, pass <code>{sort: false}</code> to add. Calling sort triggers a &quot;sort&quot; event on the collection.</p>
<p>By default, there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in <code>collection.models</code>.</p>
<p>Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound.</p>
<p>Collections with a comparator will not automatically re-sort if you later change record attributes, so you may wish to call sort after changing record attributes that would affect the order.</p>
<h3 id="static-comparator-attrname-"><code>static</code> comparator = &#39;attrName&#39;</h3>
<p>Maintain the collection in sorted order by the given record&#39;s attribute.</p>
<h3 id="static-comparator-x-number-string"><code>static</code> comparator = x =&gt; number | string</h3>
<p>Maintain the collection in sorted order according to the &quot;sortBy&quot; comparator function.</p>
<p>&quot;sortBy&quot; comparator functions take a record and return a numeric or string value by which the record should be ordered relative to others.</p>
<h3 id="static-comparator-x-y-1-0-1"><code>static</code> comparator = (x, y) =&gt; -1 | 0 | 1</h3>
<p>Maintain the collection in sorted order according to the &quot;sort&quot; comparator function.</p>
<p>&quot;sort&quot; comparator functions take two records and return -1 if the first record should come before the second, 0 if they are of the same rank and 1 if the first record should come after.</p>
<p>Note how even though all of the chapters in this example are added backward, they come out in the proper order:</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">page</span> : <span class="hljs-built_in">Number</span>,
        <span class="hljs-attr">title</span> : <span class="hljs-built_in">String</span>
    }
}

<span class="hljs-keyword">var</span> chapters = <span class="hljs-keyword">new</span> Chapter.Collection();

chapters.comparator = <span class="hljs-string">'page'</span>;

chapters.add({<span class="hljs-attr">page</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The End"</span>});
chapters.add({<span class="hljs-attr">page</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The Middle"</span>});
chapters.add({<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">"The Beginning"</span>});

alert(chapters.map( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.title ));
</code></pre>
<h2 id="other-methods">Other methods</h2>
<h3 id="collectionclass-from-models-options-">CollectionClass.from( models, options? )</h3>
<p>Create <code>CollectionClass</code> from the array of models. Similar to direct collection creation, but supports additional option for strict data validation.
If <code>{ strict : true }</code> option is passed the validation will be performed and an exception will be thrown in case of an error.</p>
<p>Please note, that Type-R always performs type checks on assignments, convert types, and reject improper updates reporting it as an error. It won&#39;t, however, execute custom validation
rules on every update as they are evaluated lazily. <code>strict</code> option will invoke custom validators and will throw on every error or warning instead of reporting them and continue.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Validate the body of an incoming HTTP request.</span>
<span class="hljs-comment">// Throw an exception if validation fails.</span>
<span class="hljs-keyword">const</span> body = MyRequestBody.from( ctx.request.body, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span>, <span class="hljs-attr">strict</span> : <span class="hljs-literal">true</span> });
</code></pre>
<pre><code class="highlight typescript"><span class="hljs-comment">// Validate the body of an incoming HTTP request.</span>
<span class="hljs-comment">// Throw an exception if validation fails.</span>
<span class="hljs-keyword">const</span> body = MyRequestBody.from( ctx.request.body, { parse : <span class="hljs-literal">true</span>, strict : <span class="hljs-literal">true</span> });
</code></pre>
<h3 id="collection-createsubset-records-options-">collection.createSubset( records?, options? )</h3>
<p>Create the collection which is a subset of a source collection serializable as an array of record ids. Takes the same arguments as the collection&#39;s constructor.</p>
<p>The created collection is an instance of <code>subsetOf( sourceCollection, CollectionCtor )</code> attribute type (non-aggregating serializable collection). </p>
<aside class="notice">
Records in the collection must have an `id` attribute populated to work properly with subsets.
</aside>

<h3 id="collection-assignfrom-othercollection-">collection.assignFrom( otherCollection )</h3>
<p>Synchronize the state of the collection and its aggregation tree with other collection of the same type. Updates existing objects in place. Record in the collection is considered to be &quot;existing&quot; if it has the same <code>id</code>.</p>
<p>Equivalent to <code>collection.set( otherCollection.models, { merge : true } )</code> and triggers similar events on change.</p>
<h3 id="collection-dispose-">collection.dispose()</h3>
<p>Dispose of the collection. An aggregating collection will recursively dispose of its records.</p>
<h1 id="observable-changes">Observable Changes</h1>
<h2 id="overview">Overview</h2>
<p>Type-R implements <em>deeply observable changes</em> on the object graph constructed of records and collection.</p>
<p>All of the record and collection updates happens in a scope of the transaction followed by the change event. Every record or collection update operation opens <em>implicit</em> transaction. Several update operations can be groped to the single <em>explicit</em> transaction if executed in the scope of the <code>obj.transaction()</code> or <code>col.updateEach()</code> call.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">datePublished</span> : <span class="hljs-built_in">Date</span>,
        <span class="hljs-attr">author</span> : Author
    }
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.on( <span class="hljs-string">'change'</span>, () =&gt; <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Book is changed'</span>) );

<span class="hljs-comment">// Implicit transaction, prints to the console</span>
book.author.name = <span class="hljs-string">'John Smith'</span>;
</code></pre>
<h2 id="record">Record</h2>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Record implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="event-change-record-"><code>event</code> &quot;change&quot; ( record )</h3>
<p>Triggered by the record at the end of the attributes update transaction in case if there were any changes applied.</p>
<h3 id="event-change-attrname-record-value-"><code>event</code> &quot;change:attrName&quot; ( record, value )</h3>
<p>Triggered by the record during the attributes update transaction for every changed attribute.</p>
<h3 id="attrdef-type-type-watcher-watcher-"><code>attrDef</code> : type( Type ).watcher( watcher )</h3>
<p>Attach <code>change:attr</code> event listener to the particular record&#39;s attribute. <code>watcher</code> can either be the record&#39;s method name or the function <code>( newValue, attr ) =&gt; void</code>. Watcher is always executed in the context of the record.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : type( <span class="hljs-built_in">String</span> ).watcher( <span class="hljs-string">'onNameChange'</span> ),
        <span class="hljs-attr">isAdmin</span> : <span class="hljs-built_in">Boolean</span>,
    }

    onNameChange(){
        <span class="hljs-comment">// Cruel. But we need it for the purpose of the example.</span>
        <span class="hljs-keyword">this</span>.isAdmin = <span class="hljs-keyword">this</span>.name.indexOf( <span class="hljs-string">'Admin'</span> ) &gt;= <span class="hljs-number">0</span>;
    }
}
</code></pre>
<h3 id="attrdef-type-type-changeevents-false-"><code>attrDef</code> : type( Type ).changeEvents( false )</h3>
<p>Turn off changes observation for nested records or collections.</p>
<p>Record automatically listens to change events of all nested records and collections, triggering appropriate change events for its attributes. This declaration turns it off for the specific attribute.</p>
<h3 id="attrdef-type-type-events-eventname-handler-"><code>attrDef</code> : type( Type ).events({ eventName : handler, ... })</h3>
<p>Automatically manage custom event subscription for the attribute. <code>handler</code> is either the method name or the handler function.</p>
<h3 id="record-changed">record.changed</h3>
<p>The <code>changed</code> property is the internal hash containing all the attributes that have changed during its last transaction.
Please do not update <code>changed</code> directly since its state is internally maintained by <code>set()</code>.
A copy of <code>changed</code> can be acquired from <code>changedAttributes()</code>.</p>
<h3 id="record-changedattributes-attrs-">record.changedAttributes( attrs? )</h3>
<p>Retrieve a hash of only the record&#39;s attributes that have changed during the last transaction,
or false if there are none. Optionally, an external attributes hash can be passed in,
returning the attributes in that hash which differ from the record.
This can be used to figure out which portions of a view should be updated,
or what calls need to be made to sync the changes to the server.</p>
<h3 id="record-previous-attr-">record.previous( attr )</h3>
<p>During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> bill = <span class="hljs-keyword">new</span> Person({
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Bill Smith"</span>
});

bill.on(<span class="hljs-string">"change:name"</span>, ( record, name ) =&gt; {
  alert( <span class="hljs-string">`Changed name from <span class="hljs-subst">${ bill.previous(<span class="hljs-string">'name'</span>) }</span> to <span class="hljs-subst">${ name }</span>`</span>);
});

bill.name = <span class="hljs-string">"Bill Jones"</span>;
</code></pre>
<h3 id="record-previousattributes-">record.previousAttributes()</h3>
<p>Return a copy of the record&#39;s previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.</p>
<h2 id="collection">Collection</h2>
<p>All changes in the records cause change events in the collections they are contained in.</p>
<p>Subset collections is an exception; they don&#39;t observe changes of its elements by default.</p>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Collection implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="collection-transaction-fun-">collection.transaction( fun )</h3>
<p>Execute the sequence of updates in <code>fun</code> function in the scope of the transaction.</p>
<p>All collection updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>changes</code> event.</p>
<p>Transaction can be opened either manually or implicitly with calling any of collection update methods.
Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won&#39;t trigger an additional <code>changes</code> events.</p>
<h3 id="collection-updateeach-iteratee-val-record-index-void-context-">collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Similar to the <code>collection.each</code>, but wraps an iteration in a transaction. The single <code>changes</code> event will be emitted for the group of changes to the records made in <code>updateEach</code>.</p>
<h3 id="static-itemevents-eventname-handler-"><code>static</code> itemEvents = { eventName : <code>handler</code>, ... }</h3>
<p>Subscribe for events from records. The <code>hander</code> is either the collection&#39;s method name, the handler function, or <code>true</code>.</p>
<p>When <code>true</code> is passed as a handler, the corresponding event will be triggered on the collection.</p>
<h3 id="event-changes-collection-options-"><code>event</code> &quot;changes&quot; (collection, options)</h3>
<p>When collection has changed. Single event triggered when the collection has been changed.</p>
<h3 id="event-reset-collection-options-"><code>event</code> &quot;reset&quot; (collection, options)</h3>
<p>When the collection&#39;s entire contents have been reset (<code>reset()</code> method was called).</p>
<h3 id="event-update-collection-options-"><code>event</code> &quot;update&quot; (collection, options)</h3>
<p>Single event triggered after any number of records have been added or removed from a collection.</p>
<h3 id="event-sort-collection-options-"><code>event</code> &quot;sort&quot; (collection, options)</h3>
<p>When the collection has been re-sorted.</p>
<h3 id="event-add-record-collection-options-"><code>event</code> &quot;add&quot; (record, collection, options)</h3>
<p>When a record is added to a collection.</p>
<h3 id="event-remove-record-collection-options-"><code>event</code> &quot;remove&quot; (record, collection, options)</h3>
<p>When a record is removed from a collection.</p>
<h3 id="event-change-record-options-"><code>event</code> &quot;change&quot; (record, options)</h3>
<p>When a record inside of the collection is changed.</p>
<h2 id="events-mixin">Events mixin</h2>
<p>Type-R uses an efficient synchronous events implementation which is backward compatible with Backbone 1.1 Events API but is about twice faster in all major browsers. It comes in form of <code>Events</code> mixin and the <code>Messenger</code> base class.</p>
<p><code>Events</code> is a <a href="#mixins">mixin</a> giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments.</p>
<p>Both <code>source</code> and <code>listener</code> mentioned in method signatures must implement Events methods.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@mixins( Events )
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventfulClass</span> </span>{
    ...
}
</code></pre>
<aside class="notice">There's the <code>Messenger</code> abstract base class with Events mixed in.</aside>

<h3 id="source-trigger-event-arg1-arg2-">source.trigger(event, arg1, arg2, ... )</h3>
<p>Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks.</p>
<h3 id="listener-listento-source-event-callback-">listener.listenTo(source, event, callback)</h3>
<p>Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context.</p>
<pre><code class="highlight javascript">    view.listenTo(record, <span class="hljs-string">'change'</span>, view.render );
</code></pre>
<aside class="success">Subscriptions made with <code>listenTo()</code> will be stopped automatically if an object is properly disposed (<code>dispose()</code> method is called).</aside>

<h3 id="listener-stoplistening-source-event-callback-">listener.stopListening([source], [event], [callback])</h3>
<p>Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it&#39;s listening to on a specific object, or a specific event, or just a specific callback.</p>
<pre><code class="highlight javascript">    view.stopListening(); <span class="hljs-comment">// Unsubscribe from all events</span>

    view.stopListening(record); <span class="hljs-comment">// Unsubscribe from all events from the record</span>
</code></pre>
<aside class="notice">Messenger, Record, Collection, and Store execute <code>this.stopListening()</code> from their <code>dispose()</code> method. You don't have to unsubscribe from events explicitly if you are using <code>listenTo()</code> method and disposing your objects properly.</aside>

<h3 id="listener-listentoonce-source-event-callback-">listener.listenToOnce(source, event, callback)</h3>
<p>Just like <code>listenTo()</code>, but causes the bound callback to fire only once before being automatically removed.</p>
<h3 id="source-on-event-callback-context-">source.on(event, callback, [context])</h3>
<p>Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: <code>poll:start</code>, or <code>change:selection</code>. The event string may also be a space-delimited list of several events...</p>
<pre><code class="highlight javascript">    book.on(<span class="hljs-string">"change:title change:author"</span>, ...);
</code></pre>
<p>Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:</p>
<pre><code class="highlight javascript">    proxy.on(<span class="hljs-string">"all"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName</span>) </span>{
        object.trigger(eventName);
    });
</code></pre>
<p>All event methods also support an event map syntax, as an alternative to positional arguments:</p>
<pre><code class="highlight javascript">    book.on({
        <span class="hljs-string">"change:author"</span>: authorPane.update,
        <span class="hljs-string">"change:title change:subtitle"</span>: titleView.update,
        <span class="hljs-string">"destroy"</span>: bookView.remove
    });
</code></pre>
<p>To supply a context value for this when the callback is invoked, pass the optional last argument: <code>record.on(&#39;change&#39;, this.render, this)</code> or <code>record.on({change: this.render}, this)</code>.</p>
<aside class="warning">Event subscription with <code>source.on()</code> may create memory leaks if it's not stopped properly with <code>source.off()</code></aside>

<h3 id="source-off-event-callback-context-">source.off([event], [callback], [context])</h3>
<p>Remove a previously bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.</p>
<pre><code class="highlight javascript">    <span class="hljs-comment">// Removes just the `onChange` callback.</span>
    object.off(<span class="hljs-string">"change"</span>, onChange);

    <span class="hljs-comment">// Removes all "change" callbacks.</span>
    object.off(<span class="hljs-string">"change"</span>);

    <span class="hljs-comment">// Removes the `onChange` callback for all events.</span>
    object.off(<span class="hljs-literal">null</span>, onChange);

    <span class="hljs-comment">// Removes all callbacks for `context` for all events.</span>
    object.off(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, context);

    <span class="hljs-comment">// Removes all callbacks on `object`.</span>
    object.off();
</code></pre>
<p>Note that calling <code>record.off()</code>, for example, will indeed remove all events on the record — including events that Backbone uses for internal bookkeeping.</p>
<h3 id="source-once-event-callback-context-">source.once(event, callback, [context])</h3>
<p>Just like <code>on()</code>, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events</p>
<h3 id="built-in-events">Built-in events</h3>
<p>All Type-R objects implement Events mixin and use events to notify listeners on changes.</p>
<p>Record and Store change events:</p>
<table>
<thead>
<tr>
<th>Event name</th>
<th>Handler arguments</th>
<th>When triggered</th>
</tr>
</thead>
<tbody>
<tr>
<td>change</td>
<td>(record, options)</td>
<td>At the end of any changes.</td>
</tr>
<tr>
<td>change:attrName</td>
<td>(record, value, options)</td>
<td>The record&#39;s attribute has been changed.</td>
</tr>
</tbody>
</table>
<p>Collection change events:</p>
<table>
<thead>
<tr>
<th>Event name</th>
<th>Handler arguments</th>
<th>When triggered</th>
</tr>
</thead>
<tbody>
<tr>
<td>changes</td>
<td>(collection, options)</td>
<td>At the end of any changes.</td>
</tr>
<tr>
<td>reset</td>
<td>(collection, options)</td>
<td><code>reset()</code> method was called.</td>
</tr>
<tr>
<td>update</td>
<td>(collection, options)</td>
<td>Any records added or removed.</td>
</tr>
<tr>
<td>sort</td>
<td>(collection, options)</td>
<td>Order of records is changed. </td>
</tr>
<tr>
<td>add</td>
<td>(record, collection, options)</td>
<td>The record is added to a collection.</td>
</tr>
<tr>
<td>remove</td>
<td>(record, collection, options)</td>
<td>The record is removed from a collection.</td>
</tr>
<tr>
<td>change</td>
<td>(record, options)</td>
<td>The record is changed inside of collection.</td>
</tr>
</tbody>
</table>
<h2 id="messenger-class">Messenger class</h2>
<p>Messenger is an abstract base class implementing Events mixin and some convenience methods.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Messenger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessenger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Messenger</span> </span>{

}
</code></pre>
<h3 id="events-mixin-methods-7-">Events mixin methods (7)</h3>
<p>Messenger implements <a href="#events-mixin">Events</a> mixin.</p>
<h3 id="messenger-cid">messenger.cid</h3>
<p>Unique run-time only messenger instance id (string).</p>
<h3 id="callback-messenger-initialize-"><code>callback</code> messenger.initialize()</h3>
<p>Callback which is called at the end of the constructor.</p>
<h3 id="messenger-dispose-">messenger.dispose()</h3>
<p>Executes <code>messenger.stopListening()</code> and <code>messenger.off()</code>.</p>
<p>Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons.</p>
<h1 id="type-safety-and-validation">Type Safety and Validation</h1>
<p>Type-R records and collections are <em>dynamically type safe</em>. It&#39;s guaranteed that Type-R data structures will always conform to the declared shape.
Records and collections convert values to the declared types on assignment, and reject an update (logging an error in a console) if it cannot be done.</p>
<p>In addition to that, Type-R supports validation API allowing developer to attach custom validation rules to attributes, records, and collections. Type-R validation mechanics based on following principles:</p>
<ul>
<li>Validation happens transparently on the first access to the validation error. There&#39;s no special API to trigger the validation.</li>
<li>Validation is performed recursively on the aggregation tree formed by nested records and collections. If an element at the bottom of the tree is not valid, the whole object tree is not valid.</li>
<li>Validation results are cached across the aggregation tree, thus consequent validation error reads are cheap. Only changed parts of aggregation tree will be revalidated when necessary.</li>
</ul>
<h2 id="attribute-level-checks">Attribute-level checks</h2>
<h3 id="attrdef-type-type-check-predicate-errormsg-"><code>attrDef</code> : type( Type ).check( predicate, errorMsg? )</h3>
<p>Attribute-level validator.</p>
<ul>
<li><code>predicate : value =&gt; boolean</code> is the function taking attribute&#39;s value and returning <code>true</code> whenever the value is valid.</li>
<li>optional <code>errorMsg</code> is the error message which will be passed in case if the validation fail.</li>
</ul>
<p>If <code>errorMsg</code> is omitted, error message will be taken from <code>predicate.error</code>. It makes possible to define reusable validation functions.</p>
<pre><code class="highlight javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAge</span>(<span class="hljs-params"> years </span>)</span>{
    <span class="hljs-keyword">return</span> years &gt;= <span class="hljs-number">0</span> &amp;&amp; years &lt; <span class="hljs-number">200</span>;
}

isAge.error = <span class="hljs-string">"Age must be between 0 and 200"</span>;
</code></pre>
<p>Attribute may have any number of checks attached which are being executed in a sequence. Validation stops when first check in sequence fails.
It can be used to define reusable attribute types as demonstrated below:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define new attribute metatypes encapsulating validation checks.</span>
<span class="hljs-keyword">const</span> Age = type( <span class="hljs-built_in">Number</span> )
                .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x == <span class="hljs-literal">null</span> || x &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">'I guess you are a bit older'</span> )
                .check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x == <span class="hljs-literal">null</span> || x &lt; <span class="hljs-number">200</span>, <span class="hljs-string">'No way man can be that old'</span> );

<span class="hljs-keyword">const</span> Word = type( <span class="hljs-built_in">String</span> ).check( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> indexOf( <span class="hljs-string">' '</span> ) &lt; <span class="hljs-number">0</span>, <span class="hljs-string">'No spaces allowed'</span> );

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">firstName</span> : Word,
        <span class="hljs-attr">lastName</span> : Word,
        <span class="hljs-attr">age</span> : Age
    }
}
</code></pre>
<h3 id="attrdef-type-type-required"><code>attrDef</code> : type( Type ).required</h3>
<p>The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, <code>&quot;Required&quot;</code> is used as validation error.</p>
<p><code>isRequired</code> is the first validator to check, no matter in which order validators were attached.</p>
<h2 id="record">Record</h2>
<h3 id="rec-isvalid-attrname-">rec.isValid( attrName )</h3>
<p>Returns <code>true</code> if the specified record&#39;s attribute is valid.</p>
<h3 id="rec-getvalidationerror-attrname-">rec.getValidationError( attrName )</h3>
<p>Return the validation error for the given attribute or <code>null</code> if it&#39;s valid.</p>
<h2 id="record-and-collection">Record and Collection</h2>
<p>Record and Collection share the same validation API. <code>key</code> is the attribute name for the record and record&#39;s id/cid for the collection.</p>
<h3 id="callback-obj-validate-"><code>callback</code> obj.validate()</h3>
<p>Override this method in subclass to define object-level validation rules. Whatever is returned from <code>validate()</code> is treated as validation error.</p>
<aside class="notice">Do not call this method directly, that's not the way how validation works.</aside>

<h3 id="obj-isvalid-">obj.isValid()</h3>
<p>Returns <code>true</code> if the object is valid. Has same effect as <code>!object.validationError</code>.</p>
<h3 id="obj-isvalid-key-">obj.isValid( key )</h3>
<p>Returns <code>true</code> if the specified record&#39;s attribute or collection element is valid. <code>key</code> is an attribute&#39;s name for the record or record&#39;s id/cid for the collection.</p>
<h3 id="obj-validationerror">obj.validationError</h3>
<p><code>null</code> if an object is valid, or the the ValidationError object with detailed information on validation results.</p>
<p>ValidationError object has following shape:</p>
<pre><code class="highlight javascript">{
    <span class="hljs-attr">error</span> : <span class="hljs-comment">/* as returned from collection.validate() */</span>,

    <span class="hljs-comment">// Members validation errors.</span>
    nested : {
        <span class="hljs-comment">// key is an attrName for the record, and record.cid for the collcation</span>
        key : validationError,
        ...
    }
}
</code></pre>
<h3 id="obj-getvalidationerror-key-">obj.getValidationError( key )</h3>
<p>Return the validation error for the given attribute or collection&#39;s item.
<code>key</code> is an attribute&#39;s name for the record or record&#39;s id/cid for the collection.</p>
<h3 id="obj-eachvalidationerror-iteratee-error-key-obj-void-">obj.eachValidationError( iteratee : ( error, key, obj ) =&gt; void )</h3>
<p>Recursively traverse aggregation tree validation errors. <code>key</code> is <code>null</code> for the object-level validation error returned by <code>obj.validate()</code>.
<code>obj</code> is the reference to the current object.</p>
<h1 id="i-o-and-serialization">I/O and Serialization</h1>
<h2 id="overview">Overview</h2>
<p>Type-R implements generalized IO on top of the <code>IOEndpoint</code> interface,  with JSON serialization handled by Record and Collection classes.</p>
<p>IOEndpoint defines the set of CRUD + list methods operating on raw JSON.
Attachment of an endpoint to the record or collection enables I/O API.  There are few endpoints bundled with Type-R, for instance <code>memoryIO()</code> which can be used for mock testing.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">email</span> : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">new</span> User.Collection();
users
    .add({ <span class="hljs-attr">name</span> : <span class="hljs-string">'John'</span> })
    .save()
    .then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log( user.id );
</code></pre>
<h2 id="i-o-api">I/O API</h2>
<h3 id="static-endpoint"><code>static</code> endpoint</h3>
<p>I/O endpoint declaration which should be used in Record or Collection definition to enable I/O API.</p>
<p>If an endpoint is defined for the <code>MyRecord</code>, it&#39;s automatically defined for the corresponding <code>MyRecord.Collection</code> as well.</p>
<h3 id="attrdef-type-type-endpoint-endpoint-"><code>attrDef</code> : type( Type ).endpoint( <code>endpoint</code> )</h3>
<p>Override or define an I/O endpoint for the specific record&#39;s attribute.</p>
<h3 id="obj-getendpoint-">obj.getEndpoint()</h3>
<p>Returns an object&#39;s IO endpoint. Normally, this is an endpoint which is defined in object&#39;s <code>static endpoint = ...</code> declaration, but it might be overridden by the parent&#39;s record using <code>type( Type ).endpoint( ... )</code> attribute declaration.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );
    ...
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRole</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/roles'</span> );
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-comment">// Use the relative path '/api/roles/:id/users'</span>
        users : type( User.Collection ).endpoint( restfulIO( <span class="hljs-string">'./users'</span> ) ),
        ...
    }
}
</code></pre>
<h3 id="record-fetch-options-">record.fetch( options? )</h3>
<p>Asynchronously fetch the record using <code>endpoint.read()</code> method. Returns an abortable ES6 promise.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="record-save-options-">record.save( options? )</h3>
<p>Asynchronously save the record using <code>endpoint.create()</code> (if there are no id) or <code>endpoint.update()</code> (if id is present) method. Returns an abortable ES6 promise.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="record-destroy-options-">record.destroy( options? )</h3>
<p>Asynchronously destroy the record using <code>endpoint.destroy()</code> method. Returns an abortable ES6 promise. The record is removed from the aggregating collection upon the completion of the I/O request.</p>
<p>An endpoint must be defined for the record in order to use that method.</p>
<h3 id="collection-fetch-options-">collection.fetch( options? )</h3>
<p>Fetch the collection. Returns an abortable promise.</p>
<p><code>options</code> accepts an optional <code>liveUpdates</code> parameter. When <code>true</code>, collection subscribes for the live updates when I/O is finished.</p>
<h3 id="collection-liveupdates-true-false-">collection.liveUpdates( true | false )</h3>
<p>Subscribe for the live data updates if an I/O endpoint supports it (<code>subscribe()</code>/<code>unsubscribe()</code> IOEndpoint methods).</p>
<aside class="notice">
No built-in I/O enpoints support that functionality yet.
</aside>

<h3 id="obj-haspendingio-">obj.hasPendingIO()</h3>
<p>Returns an abortable promise if there&#39;s any I/O pending with the object, or <code>null</code> otherwise.</p>
<p>Can be used to check for active I/O in progress or to abort pending I/O operation. Please note, that all pending I/O is aborted automatically when new I/O operation is started or an object is disposed. When I/O is aborted, the promise is rejected.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> promise = users.hasPendingIO();
<span class="hljs-keyword">if</span>( promise &amp;&amp; promise.abort ) promise.abort();
</code></pre>
<h2 id="i-o-endpoints">I/O endpoints</h2>
<h3 id="restfulio-url-options-">restfulIO( url, options? )</h3>
<p>HTTP REST client endpoint. Requires <code>window.fetch</code> available natively or through the polyfill. Implements standard BackboneJS REST semantic.</p>
<p>All I/O methods append an optional <code>options.params</code> object to the URL parameters translating them to string with <code>JSON.stringify()</code>.</p>
<ul>
<li><code>record.save()</code> makes:<ul>
<li><code>POST url</code>, if the model has no id. Expects to receive <code>{ id : recordId }</code>.</li>
<li><code>PUT url/:id</code>, if the model has an id.</li>
</ul>
</li>
<li><code>collection.fetch()</code> makes <code>GET url</code>.</li>
<li><code>record.destroy()</code> makes <code>DELETE url</code>.</li>
</ul>
<p>Supports URI relative to owner (<code>./relative/url</code> resolves as <code>/owner/:id/relative/url/:id</code> ).</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { restfulIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/restful'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/roles'</span> );
    ...
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );

    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-comment">// Roles collection here has relative url /api/users/:user_id/roles/</span>
        roles : type( Role.Collection ).endpoint( restfulIO( <span class="hljs-string">'./roles'</span> ) ), 
        ...
    }
}
</code></pre>
<h3 id="memoryio-mockdata-delay-">memoryIO( mockData?, delay? )</h3>
<p>Endpoint for mock testing. Takes optional array with mock data, and optional <code>delay</code> parameter which is the simulated I/O delay in milliseconds.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { memoryIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/memory'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();
    ...
}
</code></pre>
<h3 id="localstorageio-key-">localStorageIO( key )</h3>
<p>Endpoint for localStorage. Takes <code>key</code> parameter which must be unique for the persistent record&#39;s collection.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { localStorageIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/localStorage'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = localStorageIO( <span class="hljs-string">'/users'</span> );
    ...
}
</code></pre>
<h3 id="attributesio-">attributesIO()</h3>
<p>Endpoint for I/O composition. Redirects record&#39;s <code>fetch()</code> request to its attributes and returns the combined abortable promise. Does not enable any other I/O methods and can be used with <code>record.fetch()</code> only.</p>
<p>It&#39;s common pattern to use attributesIO endpoint in conjunction with Store to fetch all the data required by SPA page.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { localStorageIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoints/attributes'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : UserRole.Collection,
    }
}
...
const store = <span class="hljs-keyword">new</span> PageStore();
store.fetch().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> renderUI() );
</code></pre>
<h3 id="proxyio-recordctor-">proxyIO( RecordCtor )</h3>
<p>Create IO endpoint from the Record class. This endpoint is designed for use on the server side with a data layer managed by Type-R.</p>
<p>Assuming that you have Type-R records with endpoints working with the database, you can create an endpoint which will use
an existing Record subclass as a transport. This endpoint can be connected to the RESTful endpoint API on the server side which will serve JSON to the restfulIO endpoint on the client.</p>
<p>An advantage of this approach is that JSON schema will be transparently validated on the server side by the Type-R.</p>
<pre><code class="highlight javascript">    <span class="hljs-keyword">import</span> { proxyIO } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r/endpoint/proxy'</span>

    ...

    const usersIO = proxyIO( User );
</code></pre>
<h2 id="ioendpoint-interface">IOEndpoint Interface</h2>
<p>An IO endpoint is an &quot;plug-in&quot; abstraction representing the persistent collection of JSON objects, which is required to enable records and collections I/O API. There are several pre-defined endpoints included in Type-R package which can be used for HTTP REST I/O, mock testing, working with localStorage, and IO composition.</p>
<p>You will need to define custom endpoint if you would like to implement or customize serialization transport for Type-R objects. Use built-in endpoints as an example and the starting boilerplate.</p>
<p>All IOEndpoint methods might return standard Promises or abortable promises (created with <code>createIOPromise()</code>). An IOEndpoint instance is shared by all of the class instances it&#39;s attached to and therefore it&#39;s normally <em>must be stateless</em>.</p>
<h3 id="endpoint-read-id-options-record-">endpoint.read( id, options, record )</h3>
<p>Reads an object with a given id. Used by <code>record.fetch()</code> method. Must return JSON wrapped in abortable promise.</p>
<h3 id="endpoint-update-id-json-options-record-">endpoint.update( id, json, options, record )</h3>
<p>Updates or creates an object with a given id. Used by <code>record.save()</code> method when record <em>already has</em> an id. Must return abortable promise.</p>
<h3 id="endpoint-create-json-options-record-">endpoint.create( json, options, record )</h3>
<p>Creates an object. Used by <code>record.save()</code> method when record <em>does not</em> have an id. Must return abortable promise.</p>
<h3 id="endpoint-destroy-id-options-record-">endpoint.destroy( id, options, record )</h3>
<p>Destroys the object with the given id. Used by <code>record.destroy()</code> method. Must return abortable promise.</p>
<h3 id="endpoint-list-options-collection-">endpoint.list( options, collection )</h3>
<p>Fetch an array of objects. Used by <code>collection.fetch()</code> method. Must returns abortable promise.</p>
<h3 id="endpoint-subscribe-callbacks-collection-">endpoint.subscribe( <code>callbacks</code>, collection )</h3>
<p>Optional method to enable the live updates subscription. Used by <code>collection.liveUpdates( true )</code> method. Must returns abortable promise.</p>
<p>Method <code>callbacks</code> argument is an object of the following shape:</p>
<pre><code class="highlight javascript">{
    <span class="hljs-comment">// Endpoint must call it when an object is created or updated.</span>
    updated( json ){}

    <span class="hljs-comment">// Endpoint must call it when an object is removed.</span>
    removed( json ){}
}
</code></pre>
<h3 id="endpoint-unsubscribe-callbacks-collection-">endpoint.unsubscribe( <code>callbacks</code>, collection )</h3>
<p>Unsubscribe from the live updates. Used by <code>collection.liveUpdates( false )</code> method. Takes the same <code>callbacks</code> object as <code>subscribe()</code>.</p>
<h3 id="createiopromise-init-">createIOPromise( init )</h3>
<p>Service function to create an abortable version of ES6 promise (with <code>promise.abort()</code> which meant to stop pending I/O and reject the promise).</p>
<p><code>init</code> function takes the third <code>onAbort</code> argument to register an optional abort handler. If no handler is registered, the default implementation of <code>promise.abort()</code> will just reject the promise.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { createIOPromise } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-keyword">const</span> abortablePromise = createIOPromise( <span class="hljs-function">(<span class="hljs-params"> resolve, reject, onAbort </span>) =&gt;</span>{
    ...
    onAbort( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        reject( <span class="hljs-string">'I/O Aborted'</span> );
    });
});
</code></pre>
<h2 id="serialization">Serialization</h2>
<p>Record and Collection has a portion of common API related to the I/O and serialization.</p>
<h3 id="obj-tojson-options-">obj.toJSON( options? )</h3>
<p>Serialize record or collection to JSON. Used internally by I/O methods. Can be overridden to customize serialization.</p>
<p>Produces the JSON for the given record or collection and its aggregated members. Aggregation tree is serialized as nested JSON. Record corresponds to an object in JSON, while the collection is represented as an array of objects.</p>
<p>If you override <code>toJSON()</code>, it usually means that you must override <code>parse()</code> as well, and vice versa.</p>
<aside class="notice">
Serialization can be controlled on per-attribute level with <b>type( Type ).toJSON()</b> declaration.
</aside>

<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">body</span> : <span class="hljs-string">''</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">title</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">body</span> : <span class="hljs-string">''</span>,
        <span class="hljs-attr">comments</span> : Comment.Collection
    }
}

<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> BlogPost({
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Type-R is cool!"</span>,
    <span class="hljs-attr">comments</span> : [ { <span class="hljs-attr">body</span> : <span class="hljs-string">"Agree"</span> }]
});

<span class="hljs-keyword">const</span> rawJSON = post.toJSON()
<span class="hljs-comment">// { title : "Type-R is cool!", body : "", comments : [{ body : "Agree" }] }</span>
</code></pre>
<h3 id="option-parse-true-"><code>option</code> { parse : true }</h3>
<p><code>obj.set()</code> and constructor&#39;s option to force parsing of the raw JSON. Is used internally by I/O methods to parse the data received from the server.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-comment">// Amazingly, this is guaranteed to work by default.</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.set( bestSeller.toJSON(), { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span> } );
</code></pre>
<h3 id="callback-obj-parse-json-"><code>callback</code> obj.parse( json )</h3>
<p>Optional hook called to transform the JSON when it&#39;s passes to the record or collection with <code>set( json, { parse : true })</code> call. Used internally by I/O methods.</p>
<p>If you override <code>toJSON()</code>, it usually means that you must override <code>parse()</code> as well, and vice versa.</p>
<aside class="notice">
Parsing can be controlled on per-attribute level with <b>type( Type ).parse()</b> declaration.
</aside>

<h3 id="attrdef-type-type-tojson-false-"><code>attrDef</code> : type( Type ).toJSON( false )</h3>
<p>Do <em>not</em> serialize the specific attribute.</p>
<h3 id="attrdef-type-type-tojson-value-name-options-json-"><code>attrDef</code> : type( Type ).toJSON( ( value, name, options ) =&gt; json )</h3>
<p>Override the default serialization for the specific record&#39;s attribute.</p>
<p>Attribute is not serialized when the function return <code>undefined</code>.</p>
<h3 id="attrdef-type-type-parse-json-name-value-"><code>attrDef</code> : type( Type ).parse( ( json, name ) =&gt; value )</h3>
<p>Transform the data before it will be assigned to the record&#39;s attribute.</p>
<p>Invoked when the <code>{ parse : true }</code> option is set.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define custom boolean attribute type which is serialized as 0 or 1.</span>
<span class="hljs-keyword">const</span> MyWeirdBool = type( <span class="hljs-built_in">Boolean</span> )
                      .parse( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-number">1</span> )
                      .toJSON( <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> );
</code></pre>
<h3 id="static-create-attrs-options-"><code>static</code> create( attrs, options )</h3>
<p>Static factory function used internally by Type-R to create instances of the record.</p>
<p>May be redefined in the abstract Record base class to make it serializable type.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-built_in">String</span>
    }

    <span class="hljs-keyword">static</span> create( attrs, options ){
        <span class="hljs-keyword">switch</span>( attrs.type ){
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeA"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeA( attrs, options );
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeB"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeB( attrs, options );
        }
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-string">"typeA"</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">type</span> : <span class="hljs-string">"typeB"</span>,
        ...
    }
}
</code></pre>
<h2 id="normalized-data">Normalized data</h2>
<p>Type-R has first-class support for working with normalized data represented as a set of collections with cross-references by record id. References are represented as record ids in JSON, and being transparently resolved to record instances on the first access.</p>
<p><code>Store</code> class is the special record class which serves as a placeholder for the set of interlinked collections of normalized records. Id-references are defined as record attributes of the special type representing the serializable reference to the records from the specified master collection.</p>
<h3 id="attrdef-memberof-sourcecollection-"><code>attrDef</code> : memberOf( <code>sourceCollection</code> )</h3>
<p>Serializable reference to the record from the particular collection.
Initialized as <code>null</code> and serialized as <code>record.id</code>. Is not recursively cloned, validated, or disposed. Used to model one-to-many relationships.</p>
<p>Changes in shared record are not detected.</p>
<p><code>sourceCollection</code> may be:</p>
<ul>
<li>the JS variable pointing to the collection singleton;</li>
<li>the function returning the collection;</li>
<li>the string with the dot-separated <em>relative object path</em> to the collection. It is resolved dynamically relative to the record&#39;s <code>this</code>. Following shortcuts may be used in path:<ul>
<li><code>owner.path</code> (or <code>^path</code>) works as <code>() =&gt; this.getOwner().path</code>.</li>
<li><code>store.path</code> (or <code>~path</code>) works as <code>() =&gt; this.getStore().path</code>.</li>
</ul>
</li>
</ul>
<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        <span class="hljs-keyword">static</span> attributes = {
            <span class="hljs-attr">items</span> : Item.Collection,
            <span class="hljs-attr">selected</span> : memberOf( <span class="hljs-string">'items'</span> ) <span class="hljs-comment">// Will resolve to `this.items`</span>
        }
    }
</code></pre>
<pre><code class="highlight typescript">    <span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> State <span class="hljs-keyword">extends</span> Record {
        <span class="hljs-meta">@type</span>( Item.Collection ).as items : Collection&lt;Item&gt;;
        <span class="hljs-meta">@memberOf</span>( <span class="hljs-string">'items'</span> ).as selected : Item
    }
</code></pre>
<aside class="info">It's recommended to use ~paths and stores instead of ^paths.</aside>

<h3 id="attrdef-subsetof-sourcecollection-collectionctor-"><code>attrDef</code> : subsetOf( <code>sourceCollection</code>, CollectionCtor? )</h3>
<p>Serializable non-aggregating collection which is the subset of the existing collection. Serialized as an array of record ids. Used to model many-to-many relationships. <code>CollectionCtor</code> argument may be omitted unless you need it to be a sublass of the particular collection type.</p>
<p>The collection object itself is recursively created and cloned. However, its records are not aggregated by the collection thus they are not recursively cloned, validated, or disposed.</p>
<p><code>sourceCollection</code> is the same reference as used by <code>memberOf( sourceCollection )</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">roles</span> : subsetOf( <span class="hljs-string">'~roles'</span>, Role.Collection )
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersDirectory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">roles</span> : Role.Collection,
        <span class="hljs-attr">users</span> : User.Collection <span class="hljs-comment">// `~roles` references will be resolved against this.roles</span>
    }
}
</code></pre>
<h3 id="sourcecollection-createsubset-records-options-">sourceCollection.createSubset( records?, options? )</h3>
<p>Create an instance of <code>subsetOf( sourceCollection, CollectionCtor )</code> type (non-aggregating serializable collection) which is the subset of the given collection. Takes the same arguments as the collection&#39;s constructor.</p>
<aside class="notice">
Records in the collection must have an `id` attribute populated to work properly with subsets.
</aside>

<h3 id="class-store"><code>class</code> Store</h3>
<p><code>Store</code> is the special kind of record which serves as a root for id references.</p>
<p>For all records inside of the store&#39;s aggregation tree <code>~attrName</code> will resolve to the attribute of the store class found with <code>record.getStore()</code> method. If there are no such an attribute in the store, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the default store if there are no one.</p>
<aside class="notice">Stores in Type-R is _very different_ to stores in other framework. Pay attention.</aside>

<p>Store is the subclass of the Record. It&#39;s defined extending the <code>Store</code> abstract base class. It behaves as a regular record in most aspects.</p>
<h3 id="store-_defaultstore">store._defaultStore</h3>
<p>Reference to the master store used for lookups if the current store doesn&#39;t have the required attribute and there are no other store found upper in the ownership chain.</p>
<p>Defaults to the <code>Store.global</code>. May be explicitly defined to create custom store lookup chains across the ownership hierarchy.</p>
<h3 id="static-store-global"><code>static</code> Store.global</h3>
<p>The default singleton store class. Is always the last store to lookup when resolving ~reference.</p>
<p>Use the default store for the <em>globally shared data only</em>. Each application page must have its local store.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : Role.Collection
    }
}

Store.global = <span class="hljs-keyword">new</span> MyStore();

<span class="hljs-comment">// Now the reference '~users` will point to users collection from the MyStore.</span>
</code></pre>
<h3 id="recordorcollection-getstore-">recordOrCollection.getStore()</h3>
<p>Return the closest store. Used internally to resolve symbolic <code>~reference</code> relative to the store.</p>
<p>Method looks for the <code>Store</code> subclass traversing the ownership chain of current aggregation tree upwards. If there are no store found this way, default Store from <code>Store.global</code> is returned.</p>
<h3 id="recordorcollection-clone-pinstore-true-">recordOrCollection.clone({ pinStore : true })</h3>
<p>Make the cloned object to preserve the reference to its original store.</p>
<p>Cloned objects don&#39;t have an owner by default, thus they loose the reference to their store as no ownership chain can be traversed. <code>pinStore</code> option should be used in such a cases.</p>
<h1 id="tools">Tools</h1>
<h2 id="logging">Logging</h2>
<p>Type-r doesn&#39;t attempt to manage logs. Instead, it treat logs as an event stream and uses the <code>logger</code> singleton as a log router.</p>
<p>By default, the <code>logger</code> has the default listener writing events to the console.</p>
<h3 id="log-level-topic-msg-props-">log( level, topic, msg, props? )</h3>
<p>Method used to trigger the log event. Same as <code>logger.trigger( level, topic, msg, props? )</code>.</p>
<p>The <code>level</code> corresponds to the logging methods of the <code>console</code> object: <code>error</code>, <code>warn</code>, <code>info</code>, <code>log</code>, <code>debug</code>.</p>
<p><code>topic</code> is the short string used to denote the log source source and functional area. Type-R topics are prefixed with <code>TR</code>, and looks like <code>TR:TypeError</code>.
If you want to use Type-R</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { log } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

log( <span class="hljs-string">'error'</span>, <span class="hljs-string">'client-api:users'</span>, <span class="hljs-string">'No user with the given id'</span>, { user } );
</code></pre>
<h3 id="logger-off-">logger.off()</h3>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-comment">// Remove all the listeners</span>
logger.off();

<span class="hljs-comment">// Remove specific log level listeners (corresponds to the console methods, like console.log, console.warn, etc)</span>
logger.off( <span class="hljs-string">'warn'</span> );
</code></pre>
<h3 id="logger-throwon-level-">logger.throwOn( level )</h3>
<p>Sometimes (for instance, in a test suite) developer would like Type-R to throw exceptions on type errors instead of the console warnings.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

logger.off().throwOn( <span class="hljs-string">'error'</span> ).throwOn( <span class="hljs-string">'warn'</span> );
</code></pre>
<p>Or, there might be a need to throw exceptions on error in the specific situation (e.g. throw if the incoming HTTP request is not valid to respond with 500 HTTP code).</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processRequest</span>(<span class="hljs-params"> ... </span>)</span>{
    <span class="hljs-comment">// Create an empty logger</span>
    <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger();

    <span class="hljs-comment">// Tell it to throw exceptions.</span>
    logger.throwOn( <span class="hljs-string">'error'</span> ).throwOn( <span class="hljs-string">'warn'</span> );

    <span class="hljs-comment">// Override the default logger with option. Constructor will throw on error or warning.</span>
    <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> RequestBody( json, { <span class="hljs-attr">parse</span> : <span class="hljs-literal">true</span>, logger });
    ...
}
</code></pre>
<h3 id="logger-on-level-handler-">logger.on( level, handler )</h3>
<p>Type-R log message is the regular event. It&#39;s easy to attach custom listeners to integrate third-party log management libraries.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

logger
    .off()
    .on( <span class="hljs-string">'error'</span>, ( topic, msg, props ) =&gt; {
        <span class="hljs-comment">// Log errors with bunyan</span>
    } );
</code></pre>
<h2 id="class-definitions">Class Definitions</h2>
<p>Type-R mechanic is based on class transformations at the moment of module load. These transformations are controlled by <em>definitions</em> in static class members.</p>
<h3 id="decorator-definitions-propname-rule-"><code>decorator</code> @definitions({ propName : <code>rule</code>, ... })</h3>
<p>Treat specified static class members as <em>definitions</em>. When <code>@define</code> decorator is being called, definitions are extracted from static class members and mixins and passed as an argument to the <code>Class.onDefine( definition )</code>.</p>
<p>Class definitions are intended to use in the abstract base classes and they are inherited by subclasses. You don&#39;t need to add any new definitions to existing Type-R classes unless you want to extend the library, which you&#39;re welcome to do.</p>
<h3 id="rule-mixinrules-value"><code>rule</code> mixinRules.value</h3>
<p>Merge rule used to mark class definitions. The same rule is also applied to all mixin members if other rule is not specified.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">urlRoot</span> : mixinRules.value
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> urlRoot = <span class="hljs-string">'/api'</span>;

    <span class="hljs-keyword">static</span> onDefine( definition ){
        <span class="hljs-keyword">this</span>.prototype.urlRoot = definition.urlRoot;
    }
}
</code></pre>
<h3 id="rule-mixinrules-protovalue"><code>rule</code> mixinRules.protoValue</h3>
<p>Same as <code>mixinRules.value</code>, but the value is being assigned to the class prototype.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">urlRoot</span> : mixinRules.protoValue
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> urlRoot = <span class="hljs-string">'/api'</span>;
}

assert( X.prototype.urlRoot === <span class="hljs-string">'/api'</span> );
</code></pre>
<h3 id="rule-mixinrules-merge"><code>rule</code> mixinRules.merge</h3>
<p>Assume the property to be the key-value hash. Properties with the same name from mixins are merged.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> M = {
    <span class="hljs-attr">attributes</span> : {
        <span class="hljs-attr">b</span> : <span class="hljs-number">1</span>
    }
};

@define
@mixins( M )
@definitions({
    <span class="hljs-attr">attributes</span> : mixinRules.merge
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : <span class="hljs-number">1</span>
    };

    onDefine( definitions ){
        <span class="hljs-keyword">const</span> { attributes } = definitions;
        assert( attributes.a === attributes.b === <span class="hljs-number">1</span> );
    }
}
</code></pre>
<h3 id="decorator-define"><code>decorator</code> @define</h3>
<p>Extract class definitions, call class definition hooks, and apply mixin merge rules to inherited class members.</p>
<ol>
<li>Call static <code>onExtend( BaseClass )</code> hook.</li>
<li>Extract definitions from static class members and all the mixins applied, and pass them to <code>onDefine( definitions, BaseClass )</code> hook.</li>
<li>Apply <em>merge rules</em> for overriden class methods.</li>
</ol>
<p>All Type-R class definitions must be precedeed with the <code>@define</code> (or <code>@predefine</code>) decorator.</p>
<pre><code class="highlight javascript">@define
@definitions({
    <span class="hljs-attr">attributes</span> : mixinRules.merge
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> onDefine( definitions, BaseClass ){
        definitions.attributes &amp;&amp; <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">JSON</span>.stringify( definitions.attributes ) );
    }
}

<span class="hljs-comment">// Will print "{ "a" : 1 }"</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">a</span> : <span class="hljs-number">1</span>
    }
}

<span class="hljs-comment">// Will print "{ "b" : 1 }"</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">b</span> : <span class="hljs-number">1</span>
    }
}
</code></pre>
<h3 id="decorator-define-mixin-"><code>decorator</code> @define( mixin )</h3>
<p>When called with an argument, <code>@define</code> decorator applies the given mixin as if it would be the first mixin applied.
In other aspects, it behaves the same as the <code>@default</code> decorator without argument.</p>
<h3 id="static-class-onextend-baseclass-"><code>static</code> Class.onExtend( BaseClass )</h3>
<p>Called from the <code>@predefine</code> or as the first action of the <code>@define</code>. Takes base class constructor as an argument.</p>
<h3 id="static-class-ondefine-definition-baseclass-"><code>static</code> Class.onDefine( definition, BaseClass )</h3>
<p>Called from the <code>@define</code> or <code>Class.define()</code> method. Takes class definition (see the <code>@definitions</code> decorator) as the first argument.</p>
<h3 id="decorator-predefine"><code>decorator</code> @predefine</h3>
<p>The sequence of <code>@predefine</code> with the following <code>Class.define()</code> call is equivalent to <code>@define</code> decorator. It should be used in the case if the class definition must reference itself, or multiple definitions contain circular dependency. </p>
<p>It calls static <code>onExtend( BaseClass )</code> function if it&#39;s defined. It assumes that the <code>Class.define( definitions )</code> method will be called later, and attaches <code>Class.define</code> method to the class if it was not defined.</p>
<h3 id="static-class-define-definitions-"><code>static</code> Class.define( definitions? )</h3>
<p>Finalized the class definition started with <code>@predefine</code> decorator. Has the same effect as the <code>@define</code> decorator excepts it assumes that <code>Class.onExtend()</code> static function was called already.</p>
<h2 id="mixins">Mixins</h2>
<h3 id="decorator-mixins-mixina-mixinb-class-x-"><code>decorator</code> @mixins( mixinA, mixinB, ... ) class X ...</h3>
<p>Merge specified mixins to the class definition. Both plain JS object and class constructor may be used as mixin. In the case of the class constructor, missing static members will copied over as well.</p>
<pre><code class="highlight javascript">    <span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>
    ...

    @define
    @mixins( Events, plainObject, MyClass, ... )
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>{
        ...
    }
</code></pre>
<h3 id="static-class-mixins"><code>static</code> Class.mixins</h3>
<p>Class member holding the state of the class mixins.</p>
<aside class="warning">
This is an experimental API which may change in future.
</aside>

<h2 id="merge-rules">Merge rules</h2>
<h3 id="decorator-mixinrules-propname-rule-"><code>decorator</code> @mixinRules({ propName : <code>rule</code>, ... })</h3>
<p>The <code>rule</code> is the reducer function which is applied when there are several values for the particular class members are defined in different mixins or the class, or if the class member is overriden by the subclass.</p>
<aside class="warning">
This is an experimental feature to support React-style mixins. Should be used with an extreme care.
</aside>

<h3 id="rule-mixinrules-classfirst"><code>rule</code> mixinRules.classFirst</h3>
<p>Assume the property to be the function. Call functions from mixins in sequence: <code>f1.apply( this, arguments ); f2.apply( this, arguments );...</code></p>
<h3 id="rule-mixinrules-classlast"><code>rule</code> mixinRules.classLast</h3>
<p>Same as sequence, but functions are called in the reverse sequence.</p>
<pre><code class="highlight javascript">@define
@mixinRules({
    <span class="hljs-attr">componentWillMount</span> : mixinRules.classLast
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }
}

<span class="hljs-keyword">const</span> M = {
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    }
}

@define
@mixins( M )
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }
}

<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> X();
x.componentWillMount();
<span class="hljs-comment">// Will print 1, 2, 3</span>

</code></pre>
<h3 id="rule-mixinrules-pipe"><code>rule</code> mixinRules.pipe</h3>
<p>Assume the property to be the function with a signature <code>( x : T ) =&gt; T</code>. Join functions from mixins in a pipe: <code>f1( f2( f3( x ) ) )</code>.</p>
<h3 id="rule-mixinrules-defaults"><code>rule</code> mixinRules.defaults</h3>
<p>Assume the property to be the function returning object. Merge objects returned by functions from mixins, executing them in sequence.</p>
<h3 id="rule-mixinrules-every"><code>rule</code> mixinRules.every</h3>
<p>Assume property to be the function returning boolean. Return <code>true</code> if all functions from mixins return truthy values.</p>
<h3 id="rule-mixinrules-some"><code>rule</code> mixinRules.some</h3>
<p>Same as <code>every</code>, but return true when at least one function from mixins returns true.</p>
<h1 id="release-notes">Release Notes</h1>
<h2 id="3-0-0">3.0.0</h2>
<h3 id="breaking-changes">Breaking changes</h3>
<p>Changed semantic which needs to be refactored:</p>
<table>
<thead>
<tr>
<th></th>
<th>2.x</th>
<th>3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>Typeless attribute</td>
<td><code>value(x)</code></td>
<td><code>type(null).value(x)</code></td>
</tr>
<tr>
<td>Infer type from the value</td>
<td><code>x</code> (except functions)</td>
<td><code>value(x)</code>, or <code>x</code> (except functions)</td>
</tr>
<tr>
<td>record.parse() override</td>
<td><code>record._parse(json)</code></td>
<td>no such a method, remove it</td>
</tr>
<tr>
<td>record attributes iteration</td>
<td><code>record.forEachAttr(obj, iteratee)</code></td>
<td><code>record.forEach(iteratee)</code></td>
</tr>
<tr>
<td>Shared object</td>
<td><code>User.shared</code></td>
<td><code>shared( User )</code></td>
</tr>
<tr>
<td>one-to-many relationship</td>
<td><code>RecordClass.from( ref )</code></td>
<td><code>memberOf( ref )</code></td>
</tr>
<tr>
<td>many-to-many relationship</td>
<td><code>CollectionClass.from( ref )</code></td>
<td><code>subsetOf( ref, CollectionClass? )</code></td>
</tr>
<tr>
<td>construct from object/array</td>
<td>-</td>
<td><code>RecordOrCollectionClass.from( json, options? )</code></td>
</tr>
</tbody>
</table>
<h3 id="new-attribute-definition-notation">New attribute definition notation</h3>
<p>Starting from version 3.X, Type-R does not modify built-in global JS objects. New <code>type(T)</code> attribute definition notation is introduced to replace <code>T.has.</code></p>
<p>There&#39;s <code>type-r/globals</code> package for compatibility with version 2.x which must be imported once with <code>import &#39;type-r/globals&#39;</code>.
If this package is not used, the code must be refactored according to the rules below.</p>
<table>
<thead>
<tr>
<th></th>
<th>2.x</th>
<th>3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNIX Timestamp</td>
<td><code>Date.timestamp</code></td>
<td><code>import { Timestamp } from &#39;type-r/ext-types&#39;</code></td>
</tr>
<tr>
<td>Microsoft date</td>
<td><code>Date.microsoft</code></td>
<td><code>import { MicrosoftDate } from &#39;type-r/ext-types&#39;</code></td>
</tr>
<tr>
<td>Integer</td>
<td><code>Integer</code> and <code>Number.integer</code></td>
<td><code>import { Integer } from &#39;type-r/ext-types&#39;</code></td>
</tr>
<tr>
<td>Create metatype from constructor</td>
<td><code>Ctor.has</code></td>
<td><code>type(Ctor)</code></td>
</tr>
<tr>
<td>Typed attribute with default value</td>
<td><code>Ctor.value(default)</code></td>
<td><code>type(Ctor).value(default)</code></td>
</tr>
<tr>
<td>Attribute &quot;Required&quot; check</td>
<td><code>Ctor.isRequired</code></td>
<td><code>type(Ctor).required</code></td>
</tr>
</tbody>
</table>
<h3 id="first-class-typescript-support">First-class TypeScript support</h3>
<ul>
<li><code>Infer&lt;typeof Metatype&gt;</code> infers TypeScript type from the Type-R attribute metatype.</li>
<li><code>InferAttrs&lt;typeof attributes&gt;</code> infers TypeScript type for the Type-R attributes definitions.</li>
<li><code>attributes({ attrDefs })</code> returns the properly typed TypeScript Record class.</li>
</ul>
<p>TypeScript attributes definitions:</p>
<table>
<thead>
<tr>
<th></th>
<th>2.x</th>
<th>3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>Extract Type-R type with Reflect.metadata</td>
<td><code>@attr name : T</code></td>
<td><code>@auto name : T</code></td>
</tr>
<tr>
<td>Extract Type-R type &amp; specify the default value</td>
<td>not possible</td>
<td><code>@auto(default) name : T</code></td>
</tr>
<tr>
<td>Explicitly specify the type</td>
<td><code>@attr(T) name : T</code></td>
<td><code>@type(T).as name : T</code></td>
</tr>
<tr>
<td>Infer Type-R type from default value</td>
<td><code>@attr(default) name : T</code></td>
<td><code>@value(default).as name : T</code></td>
</tr>
<tr>
<td>Specify type and default value</td>
<td><code>@attr(T.value(default)) name : T</code></td>
<td><code>@type(T).value(default).as name : T</code></td>
</tr>
</tbody>
</table>
<h3 id="other-improvements">Other improvements</h3>
<ul>
<li><code>Collection</code> class now proxies ES6 Array methods</li>
<li>New logger API which easy to override or turn off.</li>
<li>Improved error messages.</li>
<li><code>Type.from( json, options? )</code> method to restore object from JSON with a strict type check and validation.</li>
</ul>
<pre><code class="highlight typescript"><span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-comment">// There's an HTTP REST enpoint for users.</span>
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/users'</span> );

    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>

    <span class="hljs-comment">// Collection of Role records represented as an array of role.id in JSON.</span>
    <span class="hljs-comment">// When the "roles" attribute will be accessed for the first time,</span>
    <span class="hljs-comment">// User will look-up for a 'roles' attribute of the nearest store to resolve ids to actual Users.</span>
    <span class="hljs-meta">@subsetOf</span>( <span class="hljs-string">'~roles'</span> ).as roles : Collection&lt;Role&gt;
}

<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> Role <span class="hljs-keyword">extends</span> Record {
    <span class="hljs-keyword">static</span> endpoint = restfulIO( <span class="hljs-string">'/api/roles'</span> );
    <span class="hljs-meta">@auto</span> name : <span class="hljs-built_in">string</span>
}

<span class="hljs-comment">// Store is the regular Record, nothing special.</span>
<span class="hljs-meta">@define</span> <span class="hljs-keyword">class</span> UsersDirectory <span class="hljs-keyword">extends</span> Store {
    <span class="hljs-comment">// When this record is fetched, fetch all the attributes instead.</span>
    <span class="hljs-keyword">static</span> endpoint = attributesIO();

    <span class="hljs-comment">// '~roles' references from all aggregated collections</span>
    <span class="hljs-comment">// will point to here, because this is the nearest store.</span>
    <span class="hljs-meta">@type</span>( User.Collection ).as users : Collection&lt;User&gt;
    <span class="hljs-meta">@type</span>( Role.Collection ).as roles : Collection&lt;Role&gt;
}

<span class="hljs-keyword">const</span> directory = <span class="hljs-keyword">new</span> UsersDirectory();
<span class="hljs-keyword">await</span> directory.fetch();

<span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> user of directory.users ){
    assert( user.roles.first().users.first() instanceOf User );
}
</code></pre>
<h2 id="2-1-0">2.1.0</h2>
<p>This release adds long-awaited HTTP REST endpoint.</p>
<ul>
<li>IO endpoints moved outside of the man sources tree. Creation of the custom endpoints is easier than ever.</li>
<li>Added HTTP REST endpoint <code>restfulIO</code> with relative urls support (<a href="https://volicon.github.io/Type-R/#endpoint-restfulio-url-options-)">https://volicon.github.io/Type-R/#endpoint-restfulio-url-options-)</a>.</li>
<li>Added proxyIO endpoint for creating endpoints from records on the server side (<a href="https://volicon.github.io/Type-R/#endpoint-proxyio-recordctor-)">https://volicon.github.io/Type-R/#endpoint-proxyio-recordctor-)</a>.</li>
</ul>
<h2 id="2-0-0">2.0.0</h2>
<p>This release brings new features which fixes problems with component&#39;s inheritance in React bindings and implements long-awaited generic IO implementation based on ES6 promises.</p>
<p>There shouldn&#39;t be breaking changes <em>unless</em> you&#39;re using custom logger or React bindings (formerly known as React-MVx, with a name changed to React-R in new release).</p>
<h3 id="generic-io-support">Generic IO support</h3>
<p>New <a href="">IOEndpoint</a> concept is introduced, making it easy to create IO abstractions. To enable <code>Record</code> and <code>Collection</code> IO API, you need to assign IO endpoint in the class definition.</p>
<p>Endpoint is the class defining CRUD and list operations on JSON data, as well as the methods to subscribe for the data changes. There are two endpoints included with 2.0 release, <code>memoryIO</code> which is suitable for mock testing and <code>localStorageIO</code> which could be used in demos and prototypes. They can be used as a references as starting points to define your own IO endpoints.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = memoryIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">name</span> : <span class="hljs-built_in">String</span>,
        ...
    }
}
</code></pre>
<p>There are three Record IO methods (<code>save()</code>, <code>fetch()</code>, and <code>destroy()</code>) and two collection IO method (<code>fetch()</code> and <code>liveUpdates()</code>) ). All IO methods returns ES6 promises, so you either must have the runtime supporting ES6 or use the ES6 promise polyfill. The promises are modified to be <em>abortable</em> (all of them have <code>abort()</code> method).</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">name</span> : <span class="hljs-string">'John'</span> });
user.save().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">`new user is added <span class="hljs-subst">${ user.id }</span>`</span> )
});
</code></pre>
<p>There&#39;s the special <code>attributesIO()</code> endpoint to fetch all of attributes independently and return the combined promise. This is the recommended way of fetching the data required by SPA page.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : User.Collection,
        <span class="hljs-attr">roles</span> : UserRole.Collection,
        ...
    }
}

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> PageStore();
store.fetch().then( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>{
    <span class="hljs-comment">// render your page</span>
});
</code></pre>
<p>It&#39;s possible to define or override the defined endpoint for the nested model or collection using <code>type().endpoint()</code> type-R attribute annotation.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">static</span> endpoint = attributesIO();
    <span class="hljs-keyword">static</span> attributes = {
        <span class="hljs-attr">users</span> : type( User.Collection ).endpoint( restful( <span class="hljs-string">'/api/users'</span> ) ),
        <span class="hljs-attr">roles</span> : type( UserRole.Collection ).endpoint( restful( <span class="hljs-string">'/api/userroles'</span> ) ),
        ...
    }
}
</code></pre>
<aside class="notice">
Please note, that `restful` endpoint is not included with 2.0 release but is planned for the future 2.x releases.
</aside>

<h3 id="new-mixins-engine">New mixins engine</h3>
<p>Type-R metaprogramming system built on powerful mixins composition with configurable member merge rules. In 2.0 release, mixins engine was rewritten to properly apply merge rules on inheritance. This feature is heavily used in Type-R React&#39;s bindings and is crucial to prevent errors when extending the <code>React.Component</code> subclasses.</p>
<p>An example illustrating the principle:</p>
<pre><code class="highlight javascript">@define
<span class="hljs-comment">// Define the class with </span>
@mixinRules({
    <span class="hljs-attr">componentWillMount</span> : mixinRules.classLast,
    <span class="hljs-attr">componentWillUnmount</span> : mixinRules.classFirst
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }
}

@define
@mixins({
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    },

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );
    }
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    componentWillMount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">3</span> );
    }

    componentWillUnmount(){
        <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );
    }
}
</code></pre>
<p>In this example, all of the methods defined in the mixin, base class, and subclass will be called in the order specified in the <code>console.log</code>.</p>
<h3 id="other-changes">Other changes</h3>
<ul>
<li>Update pipeline was rewritten to improve record&#39;s initialization speed (collection&#39;s fetch speed is improved by 30%).</li>
<li>Fixed bug causing dynamic type checks to be disabled in records constructors.</li>
<li>New implementation of the <code>Collection.subsetOf</code> which both fixes some edge case bugs and is more efficient.</li>
<li>New logger handling NODE_ENV variable setting.</li>
</ul>
        </div>
    </div>
  </body>
</html>
