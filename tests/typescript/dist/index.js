(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('util'), require('encoding'), require('stream'), require('http'), require('url'), require('https'), require('zlib'), require('tty'), require('events'), require('timers'), require('fs'), require('assert'), require('path')) :
    typeof define === 'function' && define.amd ? define(['util', 'encoding', 'stream', 'http', 'url', 'https', 'zlib', 'tty', 'events', 'timers', 'fs', 'assert', 'path'], factory) :
    (factory(global.util,global.encoding,global.stream,global.http,global.url,global.https,global.zlib,global.tty,global.events,global.timers,global.fs,global.assert,global.path));
}(this, (function (util,encoding,stream,http,url,https,zlib,tty,events,timers,fs,assert,path) { 'use strict';

    util = util && util.hasOwnProperty('default') ? util['default'] : util;
    encoding = encoding && encoding.hasOwnProperty('default') ? encoding['default'] : encoding;
    stream = stream && stream.hasOwnProperty('default') ? stream['default'] : stream;
    http = http && http.hasOwnProperty('default') ? http['default'] : http;
    url = url && url.hasOwnProperty('default') ? url['default'] : url;
    https = https && https.hasOwnProperty('default') ? https['default'] : https;
    zlib = zlib && zlib.hasOwnProperty('default') ? zlib['default'] : zlib;
    tty = tty && tty.hasOwnProperty('default') ? tty['default'] : tty;
    events = events && events.hasOwnProperty('default') ? events['default'] : events;
    timers = timers && timers.hasOwnProperty('default') ? timers['default'] : timers;
    fs = fs && fs.hasOwnProperty('default') ? fs['default'] : fs;
    assert = assert && assert.hasOwnProperty('default') ? assert['default'] : assert;
    path = path && path.hasOwnProperty('default') ? path['default'] : path;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function defaults(dest, source) {
        for (var name in source) {
            if (source.hasOwnProperty(name) && !dest.hasOwnProperty(name)) {
                dest[name] = source[name];
            }
        }
        if (arguments.length > 2) {
            for (var i = 2; i < arguments.length; i++) {
                var other = arguments[i];
                other && defaults(dest, other);
            }
        }
        return dest;
    }
    var levelToNumber = {
        none: 0, error: 1, warn: 2, info: 3, log: 4, debug: 5
    };
    var log = function (a_level, a_msg, a_props) {
        var levelAsNumber = levelToNumber[a_level], msg, props, level;
        if (levelAsNumber === void 0 && !a_props) {
            levelAsNumber = 4;
            msg = a_level;
            props = a_msg;
            level = 'log';
        }
        else {
            msg = a_msg, level = a_level, props = a_props;
        }
        if (levelAsNumber <= log.level) {
            if (levelAsNumber <= log.throw || !log.logger) {
                var error = new Error(msg);
                error.props = props;
                throw error;
            }
            else {
                log.logger(level, msg, props);
                if (levelAsNumber <= log.stop) {
                    debugger;
                }
            }
        }
    };
    log.level = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production' ? 1 : 2;
    log.throw = 0;
    log.stop = 0;
    var toString = typeof window === 'undefined' ?
        function toString(something) {
            if (something && typeof something === 'object') {
                var value = something.__inner_state__ || something, isTransactional = Boolean(something.__inner_state__), isArray = Array.isArray(value);
                var keys_1 = Object.keys(value).join(', '), body = isArray ? "[ length = " + value.length + " ]" : "{ " + keys_1 + " }";
                return something.constructor.name + ' ' + body;
            }
            return something;
        } : function toString(x) { return x; };
    if (typeof console !== 'undefined') {
        log.logger = function _console(level, error, props) {
            var args = [error];
            for (var name_1 in props) {
                args.push("\n\t" + name_1 + ":", toString(props[name_1]));
            }
            console[level].apply(console, args);
        };
    }
    function isValidJSON(value) {
        if (value === null) {
            return true;
        }
        switch (typeof value) {
            case 'number':
            case 'string':
            case 'boolean':
                return true;
            case 'object':
                var proto = Object.getPrototypeOf(value);
                if (proto === Object.prototype || proto === Array.prototype) {
                    return every(value, isValidJSON);
                }
        }
        return false;
    }
    function getBaseClass(Class) {
        return Object.getPrototypeOf(Class.prototype).constructor;
    }
    function isEmpty(obj) {
        if (obj) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
        }
        return true;
    }
    function someArray(arr, fun) {
        var result;
        for (var i = 0; i < arr.length; i++) {
            if (result = fun(arr[i], i)) {
                return result;
            }
        }
    }
    function someObject(obj, fun) {
        var result;
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (result = fun(obj[key], key)) {
                    return result;
                }
            }
        }
    }
    function some(obj, fun) {
        if (Object.getPrototypeOf(obj) === ArrayProto) {
            return someArray(obj, fun);
        }
        else {
            return someObject(obj, fun);
        }
    }
    function every(obj, predicate) {
        return !some(obj, function (x) { return !predicate(x); });
    }
    function omit(source) {
        var dest = {}, discard = {};
        for (var i = 1; i < arguments.length; i++) {
            discard[arguments[i]] = true;
        }
        for (var name in source) {
            if (!discard.hasOwnProperty(name) && source.hasOwnProperty(name)) {
                dest[name] = source[name];
            }
        }
        return dest;
    }
    function transform(dest, source, fun) {
        for (var name in source) {
            if (source.hasOwnProperty(name)) {
                var value = fun(source[name], name);
                value === void 0 || (dest[name] = value);
            }
        }
        return dest;
    }
    function assign(dest, source) {
        for (var name in source) {
            if (source.hasOwnProperty(name)) {
                dest[name] = source[name];
            }
        }
        if (arguments.length > 2) {
            for (var i = 2; i < arguments.length; i++) {
                var other = arguments[i];
                other && assign(dest, other);
            }
        }
        return dest;
    }
    function once(func) {
        var memo, first = true;
        return function () {
            if (first) {
                first = false;
                memo = func.apply(this, arguments);
                func = null;
            }
            return memo;
        };
    }
    var ArrayProto = Array.prototype, DateProto = Date.prototype, ObjectProto = Object.prototype;
    function notEqual(a, b) {
        if (a === b)
            return false;
        if (a && b && typeof a == 'object' && typeof b == 'object') {
            var protoA = Object.getPrototypeOf(a);
            if (protoA !== Object.getPrototypeOf(b))
                return true;
            switch (protoA) {
                case DateProto: return +a !== +b;
                case ArrayProto: return arraysNotEqual(a, b);
                case ObjectProto:
                case null:
                    return objectsNotEqual(a, b);
            }
        }
        return true;
    }
    function objectsNotEqual(a, b) {
        var keysA = Object.keys(a);
        if (keysA.length !== Object.keys(b).length)
            return true;
        for (var i = 0; i < keysA.length; i++) {
            var key = keysA[i];
            if (!b.hasOwnProperty(key) || notEqual(a[key], b[key])) {
                return true;
            }
        }
        return false;
    }
    function arraysNotEqual(a, b) {
        if (a.length !== b.length)
            return true;
        for (var i = 0; i < a.length; i++) {
            if (notEqual(a[i], b[i]))
                return true;
        }
        return false;
    }
    var HashProto = Object.create(null);
    HashProto.hasOwnProperty = ObjectProto.hasOwnProperty;
    function hashMap(obj) {
        var hash = Object.create(HashProto);
        return obj ? assign(hash, obj) : hash;
    }

    var Mixable = (function () {
        function Mixable() {
        }
        Mixable.define = function (protoProps, staticProps) {
            if (protoProps === void 0) { protoProps = {}; }
            var BaseClass = getBaseClass(this);
            staticProps && assign(this, staticProps);
            var mixins = protoProps.mixins, defineMixin = __rest(protoProps, ["mixins"]);
            mixins && this.mixins.merge(mixins);
            this.mixins.mergeObject(this.prototype, defineMixin, true);
            this.mixins.mergeObject(this.prototype, this.mixins.getStaticDefinitions(BaseClass), true);
            this.onDefine && this.onDefine(this.mixins.definitions, BaseClass);
            this.mixins.mergeInheritedMembers(BaseClass);
            return this;
        };
        Mixable.extend = function (spec, statics) {
            var TheSubclass;
            if (spec && spec.hasOwnProperty('constructor')) {
                TheSubclass = spec.constructor;
                __extends(TheSubclass, this);
            }
            else {
                TheSubclass = (function (_super) {
                    __extends(Subclass, _super);
                    function Subclass() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return Subclass;
                }(this));
            }
            predefine(TheSubclass);
            spec && TheSubclass.define(spec, statics);
            return TheSubclass;
        };
        return Mixable;
    }());
    function predefine(Constructor) {
        var BaseClass = getBaseClass(Constructor);
        Constructor.__super__ = BaseClass.prototype;
        Constructor.define || MixinsState.get(Mixable).populate(Constructor);
        MixinsState.get(Constructor);
        Constructor.onExtend && Constructor.onExtend(BaseClass);
    }
    function define(ClassOrDefinition) {
        if (typeof ClassOrDefinition === 'function') {
            predefine(ClassOrDefinition);
            ClassOrDefinition.define();
        }
        else {
            return function (Ctor) {
                predefine(Ctor);
                Ctor.define(ClassOrDefinition);
            };
        }
    }
    function definitions(rules) {
        return function (Class) {
            var mixins = MixinsState.get(Class);
            mixins.definitionRules = defaults(hashMap(), rules, mixins.definitionRules);
        };
    }
    function definitionDecorator(definitionKey, value) {
        return function (proto, name) {
            var _a, _b;
            MixinsState
                .get(proto.constructor)
                .mergeObject(proto, (_a = {},
                _a[definitionKey] = (_b = {},
                    _b[name] = value,
                    _b),
                _a));
        };
    }
    var MixinsState = (function () {
        function MixinsState(Class) {
            this.Class = Class;
            this.definitions = {};
            var mixins = getBaseClass(Class).mixins;
            this.mergeRules = (mixins && mixins.mergeRules) || hashMap();
            this.definitionRules = (mixins && mixins.definitionRules) || hashMap();
            this.appliedMixins = (mixins && mixins.appliedMixins) || [];
        }
        MixinsState.get = function (Class) {
            var mixins = Class.mixins;
            return mixins && Class === mixins.Class ? mixins :
                Class.mixins = new MixinsState(Class);
        };
        MixinsState.prototype.getStaticDefinitions = function (BaseClass) {
            var definitions = hashMap(), Class = this.Class;
            return transform(definitions, this.definitionRules, function (rule, name) {
                if (BaseClass[name] !== Class[name]) {
                    return Class[name];
                }
            });
        };
        MixinsState.prototype.merge = function (mixins) {
            var proto = this.Class.prototype, mergeRules = this.mergeRules;
            var appliedMixins = this.appliedMixins = this.appliedMixins.slice();
            for (var _i = 0, mixins_1 = mixins; _i < mixins_1.length; _i++) {
                var mixin = mixins_1[_i];
                if (Array.isArray(mixin)) {
                    this.merge(mixin);
                }
                else if (appliedMixins.indexOf(mixin) < 0) {
                    appliedMixins.push(mixin);
                    if (typeof mixin === 'function') {
                        this.mergeObject(this.Class, mixin);
                        var sourceMixins = mixin.mixins;
                        if (sourceMixins) {
                            this.mergeRules = defaults(hashMap(), this.mergeRules, sourceMixins.mergeRules);
                            this.definitionRules = defaults(hashMap(), this.definitionRules, sourceMixins.definitionRules);
                            this.appliedMixins = this.appliedMixins.concat(sourceMixins.appliedMixins);
                        }
                        this.mergeObject(proto, mixin.prototype);
                    }
                    else {
                        this.mergeObject(proto, mixin);
                    }
                }
            }
        };
        MixinsState.prototype.populate = function () {
            var ctors = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ctors[_i] = arguments[_i];
            }
            for (var _a = 0, ctors_1 = ctors; _a < ctors_1.length; _a++) {
                var Ctor = ctors_1[_a];
                MixinsState.get(Ctor).merge([this.Class]);
            }
        };
        MixinsState.prototype.mergeObject = function (dest, source, unshift) {
            var _this = this;
            forEachOwnProp(source, function (name) {
                var sourceProp = Object.getOwnPropertyDescriptor(source, name);
                var rule;
                if (rule = _this.definitionRules[name]) {
                    assignProperty(_this.definitions, name, sourceProp, rule, unshift);
                }
                if (!rule || rule === mixinRules.protoValue) {
                    assignProperty(dest, name, sourceProp, _this.mergeRules[name], unshift);
                }
            });
        };
        MixinsState.prototype.mergeInheritedMembers = function (BaseClass) {
            var _a = this, mergeRules = _a.mergeRules, Class = _a.Class;
            if (mergeRules) {
                var proto = Class.prototype, baseProto = BaseClass.prototype;
                for (var name_1 in mergeRules) {
                    var rule = mergeRules[name_1];
                    if (proto.hasOwnProperty(name_1) && name_1 in baseProto) {
                        proto[name_1] = resolveRule(proto[name_1], baseProto[name_1], rule);
                    }
                }
            }
        };
        return MixinsState;
    }());
    var dontMix = {
        function: hashMap({
            length: true,
            prototype: true,
            caller: true,
            arguments: true,
            name: true,
            __super__: true
        }),
        object: hashMap({
            constructor: true
        })
    };
    function forEachOwnProp(object, fun) {
        var ignore = dontMix[typeof object];
        for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
            var name_2 = _a[_i];
            ignore[name_2] || fun(name_2);
        }
    }
    var mixins = function () {
        var list = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            list[_i] = arguments[_i];
        }
        return (function (Class) { return MixinsState.get(Class).merge(list); });
    };
    var mixinRules = (function (rules) { return (function (Class) {
        var mixins = MixinsState.get(Class);
        mixins.mergeRules = defaults(rules, mixins.mergeRules);
    }); });
    mixinRules.value = function (a, b) { return a; };
    mixinRules.protoValue = function (a, b) { return a; };
    mixinRules.merge = function (a, b) { return defaults({}, a, b); };
    mixinRules.pipe = function (a, b) { return (function (x) {
        return a.call(this, b.call(this, x));
    }); };
    mixinRules.defaults = function (a, b) { return (function () {
        return defaults(a.apply(this, arguments), b.apply(this, arguments));
    }); };
    mixinRules.classFirst = function (a, b) { return (function () {
        a.apply(this, arguments);
        b.apply(this, arguments);
    }); };
    mixinRules.classLast = function (a, b) { return (function () {
        b.apply(this, arguments);
        a.apply(this, arguments);
    }); };
    mixinRules.every = function (a, b) { return (function () {
        return a.apply(this, arguments) && b.apply(this, arguments);
    }); };
    mixinRules.some = function (a, b) { return (function () {
        return a.apply(this, arguments) || b.apply(this, arguments);
    }); };
    function assignProperty(dest, name, sourceProp, rule, unshift) {
        if (dest.hasOwnProperty(name)) {
            var destProp = Object.getOwnPropertyDescriptor(dest, name);
            if (destProp.configurable && 'value' in destProp) {
                dest[name] = unshift ?
                    resolveRule(sourceProp.value, destProp.value, rule) :
                    resolveRule(destProp.value, sourceProp.value, rule);
            }
        }
        else {
            Object.defineProperty(dest, name, sourceProp);
        }
    }
    function resolveRule(dest, source, rule) {
        if (dest === void 0)
            return source;
        if (!rule || source === void 0)
            return dest;
        return rule(dest, source);
    }

    var EventMap = (function () {
        function EventMap(map) {
            this.handlers = [];
            if (map) {
                if (map instanceof EventMap) {
                    this.handlers = map.handlers.slice();
                }
                else {
                    map && this.addEventsMap(map);
                }
            }
        }
        EventMap.prototype.merge = function (map) {
            this.handlers = this.handlers.concat(map.handlers);
        };
        EventMap.prototype.addEventsMap = function (map) {
            for (var names in map) {
                this.addEvent(names, map[names]);
            }
        };
        EventMap.prototype.bubbleEvents = function (names) {
            for (var _i = 0, _a = names.split(eventSplitter); _i < _a.length; _i++) {
                var name_1 = _a[_i];
                this.addEvent(name_1, getBubblingHandler(name_1));
            }
        };
        EventMap.prototype.addEvent = function (names, callback) {
            var handlers = this.handlers;
            for (var _i = 0, _a = names.split(eventSplitter); _i < _a.length; _i++) {
                var name_2 = _a[_i];
                handlers.push(new EventDescriptor(name_2, callback));
            }
        };
        EventMap.prototype.subscribe = function (target, source) {
            for (var _i = 0, _a = this.handlers; _i < _a.length; _i++) {
                var event_1 = _a[_i];
                on(source, event_1.name, event_1.callback, target);
            }
        };
        EventMap.prototype.unsubscribe = function (target, source) {
            for (var _i = 0, _a = this.handlers; _i < _a.length; _i++) {
                var event_2 = _a[_i];
                off(source, event_2.name, event_2.callback, target);
            }
        };
        return EventMap;
    }());
    var EventDescriptor = (function () {
        function EventDescriptor(name, callback) {
            this.name = name;
            if (callback === true) {
                this.callback = getBubblingHandler(name);
            }
            else if (typeof callback === 'string') {
                this.callback =
                    function localCallback() {
                        var handler = this[callback];
                        handler && handler.apply(this, arguments);
                    };
            }
            else {
                this.callback = callback;
            }
        }
        return EventDescriptor;
    }());
    var _bubblingHandlers = {};
    function getBubblingHandler(event) {
        return _bubblingHandlers[event] || (_bubblingHandlers[event] = function (a, b, c, d, e) {
            if (d !== void 0 || e !== void 0)
                trigger5(this, event, a, b, c, d, e);
            if (c !== void 0)
                trigger3(this, event, a, b, c);
            else
                trigger2(this, event, a, b);
        });
    }
    var EventHandler = (function () {
        function EventHandler(callback, context, next) {
            if (next === void 0) { next = null; }
            this.callback = callback;
            this.context = context;
            this.next = next;
        }
        return EventHandler;
    }());
    function listOff(_events, name, callback, context) {
        var head = _events[name];
        var filteredHead, prev;
        for (var ev = head; ev; ev = ev.next) {
            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                (context && context !== ev.context)) {
                prev = ev;
                filteredHead || (filteredHead = ev);
            }
            else {
                if (prev)
                    prev.next = ev.next;
            }
        }
        if (head !== filteredHead)
            _events[name] = filteredHead;
    }
    function listSend2(head, a, b) {
        for (var ev = head; ev; ev = ev.next)
            ev.callback.call(ev.context, a, b);
    }
    function listSend3(head, a, b, c) {
        for (var ev = head; ev; ev = ev.next)
            ev.callback.call(ev.context, a, b, c);
    }
    function listSend4(head, a, b, c, d) {
        for (var ev = head; ev; ev = ev.next)
            ev.callback.call(ev.context, a, b, c, d);
    }
    function listSend5(head, a, b, c, d, e) {
        for (var ev = head; ev; ev = ev.next)
            ev.callback.call(ev.context, a, b, c, d, e);
    }
    function listSend6(head, a, b, c, d, e, f) {
        for (var ev = head; ev; ev = ev.next)
            ev.callback.call(ev.context, a, b, c, d, e, f);
    }
    function on(source, name, callback, context) {
        if (callback) {
            var _events = source._events || (source._events = Object.create(null));
            _events[name] = new EventHandler(callback, context, _events[name]);
        }
    }
    function once$1(source, name, callback, context) {
        if (callback) {
            var once_1 = once(function () {
                off(source, name, once_1);
                callback.apply(this, arguments);
            });
            once_1._callback = callback;
            on(source, name, once_1, context);
        }
    }
    function off(source, name, callback, context) {
        var _events = source._events;
        if (_events) {
            if (callback || context) {
                if (name) {
                    listOff(_events, name, callback, context);
                }
                else {
                    for (var name_3 in _events) {
                        listOff(_events, name_3, callback, context);
                    }
                }
            }
            else if (name) {
                _events[name] = void 0;
            }
            else {
                source._events = void 0;
            }
        }
    }
    var eventSplitter = /\s+/;
    function strings(api, source, events$$1, callback, context) {
        if (eventSplitter.test(events$$1)) {
            var names = events$$1.split(eventSplitter);
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_4 = names_1[_i];
                api(source, name_4, callback, context);
            }
        }
        else
            api(source, events$$1, callback, context);
    }
    function trigger2(self, name, a, b) {
        var _events = self._events;
        if (_events) {
            var queue = _events[name], all = _events.all;
            listSend2(queue, a, b);
            listSend3(all, name, a, b);
        }
    }
    function trigger3(self, name, a, b, c) {
        var _events = self._events;
        if (_events) {
            var queue = _events[name], all = _events.all;
            listSend3(queue, a, b, c);
            listSend4(all, name, a, b, c);
        }
    }
    function trigger5(self, name, a, b, c, d, e) {
        var _events = self._events;
        if (_events) {
            var queue = _events[name], all = _events.all;
            listSend5(queue, a, b, c, d, e);
            listSend6(all, name, a, b, c, d, e);
        }
    }

    var strings$1 = strings, on$1 = on, off$1 = off, once$2 = once$1, trigger5$1 = trigger5, trigger2$1 = trigger2, trigger3$1 = trigger3;
    var _idCount = 0;
    function uniqueId() {
        return 'l' + _idCount++;
    }
    var Messenger = (function () {
        function Messenger() {
            this._events = void 0;
            this._listeningTo = void 0;
            this.cid = uniqueId();
            this.initialize.apply(this, arguments);
        }
        Messenger.onDefine = function (_a, BaseClass) {
            var localEvents = _a.localEvents, _localEvents = _a._localEvents, properties = _a.properties;
            if (localEvents || _localEvents) {
                var eventsMap = new EventMap(this.prototype._localEvents);
                localEvents && eventsMap.addEventsMap(localEvents);
                _localEvents && eventsMap.merge(_localEvents);
                this.prototype._localEvents = eventsMap;
            }
            if (properties) {
                Object.defineProperties(this.prototype, transform({}, properties, toPropertyDescriptor));
            }
        };
        Messenger.prototype.initialize = function () { };
        Messenger.prototype.on = function (events$$1, callback, context) {
            if (typeof events$$1 === 'string')
                strings$1(on$1, this, events$$1, callback, context);
            else
                for (var name_1 in events$$1)
                    strings$1(on$1, this, name_1, events$$1[name_1], context || callback);
            return this;
        };
        Messenger.prototype.once = function (events$$1, callback, context) {
            if (typeof events$$1 === 'string')
                strings$1(once$2, this, events$$1, callback, context);
            else
                for (var name_2 in events$$1)
                    strings$1(once$2, this, name_2, events$$1[name_2], context || callback);
            return this;
        };
        Messenger.prototype.off = function (events$$1, callback, context) {
            if (!events$$1)
                off$1(this, void 0, callback, context);
            else if (typeof events$$1 === 'string')
                strings$1(off$1, this, events$$1, callback, context);
            else
                for (var name_3 in events$$1)
                    strings$1(off$1, this, name_3, events$$1[name_3], context || callback);
            return this;
        };
        Messenger.prototype.trigger = function (name, a, b, c, d, e) {
            if (d !== void 0 || e !== void 0)
                trigger5$1(this, name, a, b, c, d, e);
            else if (c !== void 0)
                trigger3$1(this, name, a, b, c);
            else
                trigger2$1(this, name, a, b);
            return this;
        };
        Messenger.prototype.listenTo = function (source, a, b) {
            if (source) {
                addReference(this, source);
                source.on(a, !b && typeof a === 'object' ? this : b, this);
            }
            return this;
        };
        Messenger.prototype.listenToOnce = function (source, a, b) {
            if (source) {
                addReference(this, source);
                source.once(a, !b && typeof a === 'object' ? this : b, this);
            }
            return this;
        };
        Messenger.prototype.stopListening = function (a_source, a, b) {
            var _listeningTo = this._listeningTo;
            if (_listeningTo) {
                var removeAll = !(a || b), second = !b && typeof a === 'object' ? this : b;
                if (a_source) {
                    var source = _listeningTo[a_source.cid];
                    if (source) {
                        if (removeAll)
                            delete _listeningTo[a_source.cid];
                        source.off(a, second, this);
                    }
                }
                else if (a_source == null) {
                    for (var cid in _listeningTo)
                        _listeningTo[cid].off(a, second, this);
                    if (removeAll)
                        (this._listeningTo = void 0);
                }
            }
            return this;
        };
        Messenger.prototype.dispose = function () {
            if (this._disposed)
                return;
            this.stopListening();
            this.off();
            this._disposed = true;
        };
        Messenger = __decorate([
            define,
            definitions({
                properties: mixinRules.merge,
                localEvents: mixinRules.merge
            })
        ], Messenger);
        return Messenger;
    }());
    var Events = omit(Messenger.prototype, 'constructor', 'initialize');
    function toPropertyDescriptor(x) {
        if (x) {
            return typeof x === 'function' ? { get: x } : x;
        }
    }
    function addReference(listener, source) {
        var listeningTo = listener._listeningTo || (listener._listeningTo = Object.create(null)), cid = source.cid || (source.cid = uniqueId());
        listeningTo[cid] = source;
    }

    Object.extend = function (protoProps, staticProps) { return Mixable.extend(protoProps, staticProps); };
    Object.assign || (Object.assign = assign);
    Object.log = log;

    var ValidationError = (function () {
        function ValidationError(obj) {
            this.length = obj._validateNested(this.nested = {});
            if (this.error = obj.validate(obj)) {
                this.length++;
            }
        }
        ValidationError.prototype.each = function (iteratee) {
            var _a = this, error = _a.error, nested = _a.nested;
            if (error)
                iteratee(error, null);
            for (var key in nested) {
                iteratee(nested[key], key);
            }
        };
        ValidationError.prototype.eachError = function (iteratee, object) {
            this.each(function (value, key) {
                if (value instanceof ValidationError) {
                    value.eachError(iteratee, object.get(key));
                }
                else {
                    iteratee(value, key, object);
                }
            });
        };
        return ValidationError;
    }());

    var referenceMask = /\^|(store\.[^.]+)|([^.]+)/g;
    var CompiledReference = (function () {
        function CompiledReference(reference, splitTail) {
            if (splitTail === void 0) { splitTail = false; }
            var path$$1 = reference
                .match(referenceMask)
                .map(function (key) {
                if (key === '^' || key === 'owner')
                    return 'getOwner()';
                if (key[0] === '~')
                    return "getStore().get(\"" + key.substr(1) + "\")";
                if (key.indexOf('store.') === 0)
                    return "getStore().get(\"" + key.substr(6) + "\")";
                return key;
            });
            this.tail = splitTail && path$$1.pop();
            this.local = !path$$1.length;
            this.resolve = new Function('self', "\n            var v = self." + path$$1.shift() + ";\n                           \n            " + path$$1.map(function (x) { return "\n                v = v && v." + x + ";\n            "; }).join('') + "\n\n            return v;\n        ");
        }
        return CompiledReference;
    }());
    function resolveReference(root, reference, action) {
        var path$$1 = reference.match(referenceMask), skip = path$$1.length - 1;
        var self = root;
        for (var i = 0; i < skip; i++) {
            var key = path$$1[i];
            switch (key) {
                case '~':
                    self = self.getStore();
                    break;
                case '^':
                    self = self.getOwner();
                    break;
                default: self = self.get(key);
            }
            if (!self)
                return;
        }
        return action(self, path$$1[skip]);
    }

    function createIOPromise(initialize) {
        var resolve, reject, onAbort;
        function abort(fn) {
            onAbort = fn;
        }
        var promise = new Promise(function (a_resolve, a_reject) {
            reject = a_reject;
            resolve = a_resolve;
            initialize(resolve, reject, abort);
        });
        promise.abort = function () {
            onAbort ? onAbort(resolve, reject) : reject(new Error("I/O Aborted"));
        };
        return promise;
    }
    function startIO(self, promise, options, thenDo) {
        abortIO(self);
        options.ioUpdate = true;
        self._ioPromise = promise
            .then(function (resp) {
            self._ioPromise = null;
            var result = thenDo ? thenDo(resp) : resp;
            triggerAndBubble(self, 'sync', self, resp, options);
            return result;
        })
            .catch(function (err) {
            self._ioPromise = null;
            console.error(err);
            triggerAndBubble(self, 'error', self, err, options);
            throw err;
        });
        self._ioPromise.abort = promise.abort;
        return self._ioPromise;
    }
    function abortIO(self) {
        if (self._ioPromise && self._ioPromise.abort) {
            self._ioPromise.abort();
            self._ioPromise = null;
        }
    }
    function triggerAndBubble(eventSource) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        eventSource.trigger.apply(eventSource, args);
        var collection = eventSource.collection;
        collection && collection.trigger.apply(collection, args);
    }

    var trigger3$2 = trigger3, on$2 = on, off$2 = off;
    var ItemsBehavior;
    (function (ItemsBehavior) {
        ItemsBehavior[ItemsBehavior["share"] = 1] = "share";
        ItemsBehavior[ItemsBehavior["listen"] = 2] = "listen";
        ItemsBehavior[ItemsBehavior["persistent"] = 4] = "persistent";
    })(ItemsBehavior || (ItemsBehavior = {}));
    var Transactional = (function () {
        function Transactional(cid) {
            this._events = void 0;
            this._changeToken = {};
            this._transaction = false;
            this._isDirty = null;
            this._owner = void 0;
            this._ownerKey = void 0;
            this._validationError = void 0;
            this.cid = this.cidPrefix + cid;
        }
        Transactional_1 = Transactional;
        Transactional.onDefine = function (definitions$$1, BaseClass) {
            if (definitions$$1.endpoint)
                this.prototype._endpoint = definitions$$1.endpoint;
            Messenger.onDefine.call(this, definitions$$1, BaseClass);
        };
        Transactional.onExtend = function (BaseClass) {
            if (BaseClass.create === this.create) {
                this.create = Transactional_1.create;
            }
        };
        Transactional.create = function (a, b) {
            return new this(a, b);
        };
        Transactional.prototype.dispose = function () {
            if (this._disposed)
                return;
            abortIO(this);
            this._owner = void 0;
            this._ownerKey = void 0;
            this.off();
            this.stopListening();
            this._disposed = true;
        };
        Transactional.prototype.initialize = function () { };
        Transactional.prototype.onChanges = function (handler, target) {
            on$2(this, this._changeEventName, handler, target);
        };
        Transactional.prototype.offChanges = function (handler, target) {
            off$2(this, this._changeEventName, handler, target);
        };
        Transactional.prototype.listenToChanges = function (target, handler) {
            this.listenTo(target, target._changeEventName, handler);
        };
        Transactional.prototype.transaction = function (fun, options) {
            if (options === void 0) { options = {}; }
            var isRoot = transactionApi.begin(this);
            var update = fun.call(this, this);
            update && this.set(update);
            isRoot && transactionApi.commit(this);
        };
        Transactional.prototype.updateEach = function (iteratee, options) {
            var isRoot = transactionApi.begin(this);
            this.each(iteratee);
            isRoot && transactionApi.commit(this);
        };
        Transactional.prototype.set = function (values, options) {
            if (values) {
                var transaction = this._createTransaction(values, options);
                transaction && transaction.commit();
            }
            return this;
        };
        Transactional.prototype.assignFrom = function (source) {
            var _this = this;
            this.transaction(function () {
                _this.set(source.__inner_state__ || source, { merge: true });
                var _changeToken = source._changeToken;
                if (_changeToken) {
                    _this._changeToken = _changeToken;
                }
            });
            return this;
        };
        Transactional.prototype.parse = function (data, options) { return data; };
        Transactional.prototype.deepGet = function (reference) {
            return resolveReference(this, reference, function (object, key) { return object.get ? object.get(key) : object[key]; });
        };
        Transactional.prototype.getOwner = function () {
            return this._owner;
        };
        Transactional.prototype.getStore = function () {
            var _owner = this._owner;
            return _owner ? _owner.getStore() : this._defaultStore;
        };
        Transactional.prototype.map = function (iteratee, context) {
            var arr = [], fun = context !== void 0 ? function (v, k) { return iteratee.call(context, v, k); } : iteratee;
            this.each(function (val, key) {
                var result = fun(val, key);
                if (result !== void 0)
                    arr.push(result);
            });
            return arr;
        };
        Transactional.prototype.hasPendingIO = function () { return this._ioPromise; };
        Transactional.prototype.fetch = function (options) { throw new Error("Not implemented"); };
        Transactional.prototype.getEndpoint = function () {
            return getOwnerEndpoint$1(this) || this._endpoint;
        };
        Transactional.prototype.mapObject = function (iteratee, context) {
            var obj = {};
            this.each(function (val, key) {
                var result = iteratee(val, key);
                if (result !== void 0)
                    obj[key] = result;
            });
            return obj;
        };
        Object.defineProperty(Transactional.prototype, "validationError", {
            get: function () {
                var error = this._validationError || (this._validationError = new ValidationError(this));
                return error.length ? error : null;
            },
            enumerable: true,
            configurable: true
        });
        Transactional.prototype.validate = function (obj) { };
        Transactional.prototype.getValidationError = function (key) {
            var error = this.validationError;
            return (key ? error && error.nested[key] : error) || null;
        };
        Transactional.prototype.deepValidationError = function (reference) {
            return resolveReference(this, reference, function (object, key) { return object.getValidationError(key); });
        };
        Transactional.prototype.eachValidationError = function (iteratee) {
            var validationError = this.validationError;
            validationError && validationError.eachError(iteratee, this);
        };
        Transactional.prototype.isValid = function (key) {
            return !this.getValidationError(key);
        };
        Transactional.prototype.valueOf = function () { return this.cid; };
        Transactional.prototype.toString = function () { return this.cid; };
        Transactional.prototype.getClassName = function () {
            var name = this.constructor.name;
            if (name !== 'Subclass')
                return name;
        };
        var Transactional_1;
        Transactional = Transactional_1 = __decorate([
            define,
            definitions({
                endpoint: mixinRules.value
            }),
            mixins(Messenger)
        ], Transactional);
        return Transactional;
    }());
    var transactionApi = {
        begin: function (object) {
            return object._transaction ? false : (object._transaction = true);
        },
        markAsDirty: function (object, options) {
            var dirty = !options.silent;
            if (dirty)
                object._isDirty = options;
            object._changeToken = {};
            object._validationError = void 0;
            return dirty;
        },
        commit: function (object, initiator) {
            var originalOptions = object._isDirty;
            if (originalOptions) {
                while (object._isDirty) {
                    var options = object._isDirty;
                    object._isDirty = null;
                    trigger3$2(object, object._changeEventName, object, options, initiator);
                }
                object._transaction = false;
                var _owner = object._owner;
                if (_owner && _owner !== initiator) {
                    _owner._onChildrenChange(object, originalOptions);
                }
            }
            else {
                object._isDirty = null;
                object._transaction = false;
            }
        },
        aquire: function (owner, child, key) {
            if (!child._owner) {
                child._owner = owner;
                child._ownerKey = key;
                return true;
            }
            return child._owner === owner;
        },
        free: function (owner, child) {
            if (owner === child._owner) {
                child._owner = void 0;
                child._ownerKey = void 0;
            }
        }
    };
    function getOwnerEndpoint$1(self) {
        var collection = self.collection;
        if (collection) {
            return getOwnerEndpoint$1(collection);
        }
        if (self._owner) {
            var _endpoints = self._owner._endpoints;
            return _endpoints && _endpoints[self._ownerKey];
        }
    }

    var _begin = transactionApi.begin, _markAsDirty = transactionApi.markAsDirty, commit = transactionApi.commit;
    var trigger3$3 = trigger3;
    function setAttribute(record, name, value) {
        var isRoot = begin(record), options = {};
        if (record._attributes[name].doUpdate(value, record, options)) {
            markAsDirty(record, options);
            trigger3$3(record, 'change:' + name, record, record.attributes[name], options);
        }
        isRoot && commit(record);
    }
    function begin(record) {
        if (_begin(record)) {
            record._previousAttributes = new record.AttributesCopy(record.attributes);
            record._changedAttributes = null;
            return true;
        }
        return false;
    }
    function markAsDirty(record, options) {
        if (record._changedAttributes) {
            record._changedAttributes = null;
        }
        return _markAsDirty(record, options);
    }
    var UpdateRecordMixin = {
        transaction: function (fun, options) {
            if (options === void 0) { options = {}; }
            var isRoot = begin(this);
            fun.call(this, this);
            isRoot && commit(this);
        },
        _onChildrenChange: function (child, options) {
            var _ownerKey = child._ownerKey, attribute = this._attributes[_ownerKey];
            if (!attribute || attribute.propagateChanges)
                this.forceAttributeChange(_ownerKey, options);
        },
        forceAttributeChange: function (key, options) {
            if (options === void 0) { options = {}; }
            var isRoot = begin(this);
            if (markAsDirty(this, options)) {
                trigger3$3(this, 'change:' + key, this, this.attributes[key], options);
            }
            isRoot && commit(this);
        },
        _createTransaction: function (a_values, options) {
            if (options === void 0) { options = {}; }
            var isRoot = begin(this), changes = [], nested = [], _attributes = this._attributes, values = options.parse ? this.parse(a_values, options) : a_values;
            var unknown;
            if (shouldBeAnObject(this, values)) {
                for (var name_1 in values) {
                    var spec = _attributes[name_1];
                    if (spec) {
                        if (spec.doUpdate(values[name_1], this, options, nested)) {
                            changes.push(name_1);
                        }
                    }
                    else {
                        unknown || (unknown = []);
                        unknown.push("'" + name_1 + "'");
                    }
                }
            }
            if (changes.length && markAsDirty(this, options)) {
                return new RecordTransaction(this, isRoot, nested, changes);
            }
            for (var _i = 0, nested_1 = nested; _i < nested_1.length; _i++) {
                var pendingTransaction = nested_1[_i];
                pendingTransaction.commit(this);
            }
            isRoot && commit(this);
        }
    };
    function constructorsMixin(attrDefs) {
        var attrs = Object.keys(attrDefs);
        var AttributesCopy = new Function('values', "\n        " + attrs.map(function (attr) { return "\n            this." + attr + " = values." + attr + ";\n        "; }).join('') + "\n    ");
        AttributesCopy.prototype = Object.prototype;
        var Attributes = new Function('record', 'values', 'options', "\n        var _attrs = record._attributes;\n\n        " + attrs.map(function (attr) { return "\n            this." + attr + " = _attrs." + attr + ".doInit( values." + attr + ", record, options );\n        "; }).join('') + "\n    ");
        Attributes.prototype = Object.prototype;
        return { Attributes: Attributes, AttributesCopy: AttributesCopy };
    }
    function shouldBeAnObject(record, values) {
        if (values && values.constructor === Object)
            return true;
        record._log('warn', 'update with non-object is ignored!', { values: values });
        return false;
    }
    var RecordTransaction = (function () {
        function RecordTransaction(object, isRoot, nested, changes) {
            this.object = object;
            this.isRoot = isRoot;
            this.nested = nested;
            this.changes = changes;
        }
        RecordTransaction.prototype.commit = function (initiator) {
            var _a = this, nested = _a.nested, object = _a.object, changes = _a.changes;
            for (var _i = 0, nested_2 = nested; _i < nested_2.length; _i++) {
                var transaction = nested_2[_i];
                transaction.commit(object);
            }
            var attributes = object.attributes, _isDirty = object._isDirty;
            for (var _b = 0, changes_1 = changes; _b < changes_1.length; _b++) {
                var key = changes_1[_b];
                trigger3$3(object, 'change:' + key, object, attributes[key], _isDirty);
            }
            this.isRoot && commit(object, initiator);
        };
        return RecordTransaction;
    }());

    var notEqual$1 = notEqual, assign$2 = assign;
    var emptyOptions = {};
    var AnyType = (function () {
        function AnyType(name, a_options) {
            this.name = name;
            this.getHook = null;
            this.options = a_options;
            var options = assign$2({ getHooks: [], transforms: [], changeHandlers: [] }, a_options);
            options.getHooks = options.getHooks.slice();
            options.transforms = options.transforms.slice();
            options.changeHandlers = options.changeHandlers.slice();
            var value = options.value, type = options.type, parse = options.parse, toJSON = options.toJSON, changeEvents = options.changeEvents, validate = options.validate, getHooks = options.getHooks, transforms = options.transforms, changeHandlers = options.changeHandlers;
            this.value = value;
            this.type = type;
            if (!options.hasCustomDefault && type) {
                this.defaultValue = this.create;
            }
            else if (isValidJSON(value)) {
                this.defaultValue = new Function("return " + JSON.stringify(value) + ";");
            }
            else {
                this.defaultValue = this.defaultValue;
            }
            this.propagateChanges = changeEvents !== false;
            this.toJSON = toJSON === void 0 ? this.toJSON : toJSON;
            this.validate = validate || this.validate;
            if (options.isRequired) {
                this.validate = wrapIsRequired(this.validate);
            }
            transforms.unshift(this.convert);
            if (this.get)
                getHooks.unshift(this.get);
            this.initialize.call(this, options);
            if (getHooks.length) {
                var getHook_1 = this.getHook = getHooks.reduce(chainGetHooks);
                var validate_1 = this.validate;
                this.validate = function (record, value, key) {
                    return validate_1.call(this, record, getHook_1.call(record, value, key), key);
                };
            }
            this.transform = transforms.length ? transforms.reduce(chainTransforms) : this.transform;
            this.handleChange = changeHandlers.length ? changeHandlers.reduce(chainChangeHandlers) : this.handleChange;
            var _a = this, doInit = _a.doInit, doUpdate = _a.doUpdate;
            this.doInit = parse ? function (value, record, options) {
                return doInit.call(this, options.parse && value !== void 0 ? parse.call(record, value, this.name) : value, record, options);
            } : doInit;
            this.doUpdate = parse ? function (value, record, options, nested) {
                return doUpdate.call(this, options.parse && value !== void 0 ? parse.call(record, value, this.name) : value, record, options, nested);
            } : doUpdate;
        }
        AnyType.create = function (options, name) {
            var type = options.type, AttributeCtor = options._attribute || (type ? type._attribute : AnyType);
            return new AttributeCtor(name, options);
        };
        AnyType.prototype.canBeUpdated = function (prev, next, options) { };
        AnyType.prototype.transform = function (next, prev, model, options) { return next; };
        AnyType.prototype.convert = function (next, prev, model, options) { return next; };
        AnyType.prototype.isChanged = function (a, b) {
            return notEqual$1(a, b);
        };
        AnyType.prototype.handleChange = function (next, prev, model, options) { };
        AnyType.prototype.create = function () { return void 0; };
        AnyType.prototype.clone = function (value, record) {
            return value;
        };
        AnyType.prototype.dispose = function (record, value) {
            this.handleChange(void 0, value, record, emptyOptions);
        };
        AnyType.prototype.validate = function (record, value, key) { };
        AnyType.prototype.toJSON = function (value, key, options) {
            return value && value.toJSON ? value.toJSON(options) : value;
        };
        AnyType.prototype.createPropertyDescriptor = function () {
            var _a = this, name = _a.name, getHook = _a.getHook;
            if (name !== 'id') {
                return {
                    set: function (value) {
                        setAttribute(this, name, value);
                    },
                    get: (getHook ?
                        function () {
                            return getHook.call(this, this.attributes[name], name);
                        } :
                        function () { return this.attributes[name]; })
                };
            }
        };
        AnyType.prototype.initialize = function (name, options) { };
        AnyType.prototype.doInit = function (value, record, options) {
            var v = value === void 0 ? this.defaultValue() : value, x = this.transform(v, void 0, record, options);
            this.handleChange(x, void 0, record, options);
            return x;
        };
        AnyType.prototype.doUpdate = function (value, record, options, nested) {
            var name = this.name, attributes = record.attributes, prev = attributes[name];
            var next = this.transform(value, prev, record, options);
            attributes[name] = next;
            if (this.isChanged(next, prev)) {
                this.handleChange(next, prev, record, options);
                return true;
            }
            return false;
        };
        AnyType.prototype._log = function (level, text, value, record) {
            log(level, "[Attribute Update Error] " + record.getClassName() + "." + this.name + ": " + text, {
                'Record': record,
                'Attribute definition': this,
                'Prev. value': record.attributes[this.name],
                'New value': value
            });
        };
        AnyType.prototype.defaultValue = function () {
            return this.value;
        };
        return AnyType;
    }());
    function chainGetHooks(prevHook, nextHook) {
        return function (value, name) {
            return nextHook.call(this, prevHook.call(this, value, name), name);
        };
    }
    function chainTransforms(prevTransform, nextTransform) {
        return function (next, prev, record, options) {
            return nextTransform.call(this, prevTransform.call(this, next, prev, record, options), prev, record, options);
        };
    }
    function chainChangeHandlers(prevHandler, nextHandler) {
        return function (next, prev, record, options) {
            prevHandler.call(this, next, prev, record, options);
            nextHandler.call(this, next, prev, record, options);
        };
    }
    function wrapIsRequired(validate) {
        return function (record, value, key) {
            return value ? validate.call(this, record, value, key) : 'Required';
        };
    }

    var free = transactionApi.free, aquire = transactionApi.aquire;
    var AggregatedType = (function (_super) {
        __extends(AggregatedType, _super);
        function AggregatedType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AggregatedType.prototype.clone = function (value) {
            return value ? value.clone() : value;
        };
        AggregatedType.prototype.toJSON = function (x, key, options) { return x && x.toJSON(options); };
        AggregatedType.prototype.doInit = function (value, record, options) {
            var v = options.clone ? this.clone(value) : (value === void 0 ? this.defaultValue() : value);
            var x = this.transform(v, void 0, record, options);
            this.handleChange(x, void 0, record, options);
            return x;
        };
        AggregatedType.prototype.doUpdate = function (value, record, options, nested) {
            var key = this.name, attributes = record.attributes;
            var prev = attributes[key];
            var update;
            if (update = this.canBeUpdated(prev, value, options)) {
                var nestedTransaction = prev._createTransaction(update, options);
                if (nestedTransaction) {
                    if (nested) {
                        nested.push(nestedTransaction);
                    }
                    else {
                        nestedTransaction.commit(record);
                    }
                    if (this.propagateChanges)
                        return true;
                }
                return false;
            }
            var next = this.transform(value, prev, record, options);
            attributes[key] = next;
            if (this.isChanged(next, prev)) {
                this.handleChange(next, prev, record, options);
                return true;
            }
            return false;
        };
        AggregatedType.prototype.canBeUpdated = function (prev, next, options) {
            if (prev && next != null) {
                if (next instanceof this.type) {
                    if (options.merge)
                        return next.__inner_state__;
                }
                else {
                    return next;
                }
            }
        };
        AggregatedType.prototype.convert = function (next, prev, record, options) {
            if (next == null)
                return next;
            if (next instanceof this.type) {
                if (next._shared && !(next._shared & ItemsBehavior.persistent)) {
                    this._log('error', 'aggregated collection attribute is assigned with shared collection', next, record);
                }
                return options.merge ? next.clone() : next;
            }
            return this.type.create(next, options);
        };
        AggregatedType.prototype.dispose = function (record, value) {
            if (value) {
                this.handleChange(void 0, value, record, {});
            }
        };
        AggregatedType.prototype.validate = function (record, value) {
            var error = value && value.validationError;
            if (error)
                return error;
        };
        AggregatedType.prototype.create = function () {
            return this.type.create();
        };
        AggregatedType.prototype.initialize = function (options) {
            options.changeHandlers.unshift(this._handleChange);
        };
        AggregatedType.prototype._handleChange = function (next, prev, record, options) {
            if (prev) {
                free(record, prev);
                options.unset || prev.dispose();
            }
            if (next && !aquire(record, next, this.name)) {
                this._log('error', 'aggregated attribute assigned with object already having an owner', next, record);
            }
        };
        return AggregatedType;
    }(AnyType));

    var assign$3 = assign;
    var ChainableAttributeSpec = (function () {
        function ChainableAttributeSpec(options) {
            this.options = { getHooks: [], transforms: [], changeHandlers: [] };
            if (options)
                assign$3(this.options, options);
        }
        ChainableAttributeSpec.prototype.check = function (check, error) {
            function validate(model, value, name) {
                if (!check.call(model, value, name)) {
                    var msg = error || check.error || name + ' is not valid';
                    return typeof msg === 'function' ? msg.call(model, name) : msg;
                }
            }
            var prev = this.options.validate;
            return this.metadata({
                validate: prev ? (function (model, value, name) {
                    return prev(model, value, name) || validate(model, value, name);
                }) : validate
            });
        };
        Object.defineProperty(ChainableAttributeSpec.prototype, "asProp", {
            get: function () {
                return definitionDecorator('attributes', this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ChainableAttributeSpec.prototype, "as", {
            get: function () { return this.asProp; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ChainableAttributeSpec.prototype, "isRequired", {
            get: function () {
                return this.metadata({ isRequired: true });
            },
            enumerable: true,
            configurable: true
        });
        ChainableAttributeSpec.prototype.endpoint = function (endpoint) {
            return this.metadata({ endpoint: endpoint });
        };
        ChainableAttributeSpec.prototype.watcher = function (ref) {
            return this.metadata({ _onChange: ref });
        };
        ChainableAttributeSpec.prototype.parse = function (fun) {
            return this.metadata({ parse: fun });
        };
        ChainableAttributeSpec.prototype.toJSON = function (fun) {
            return this.metadata({
                toJSON: typeof fun === 'function' ? fun : (fun ? function (x, k, o) { return x && x.toJSON(o); } : emptyFunction)
            });
        };
        ChainableAttributeSpec.prototype.get = function (fun) {
            return this.metadata({
                getHooks: this.options.getHooks.concat(fun)
            });
        };
        ChainableAttributeSpec.prototype.set = function (fun) {
            function handleSetHook(next, prev, record, options) {
                if (this.isChanged(next, prev)) {
                    var changed = fun.call(record, next, this.name);
                    return changed === void 0 ? prev : this.convert(changed, prev, record, options);
                }
                return prev;
            }
            return this.metadata({
                transforms: this.options.transforms.concat(handleSetHook)
            });
        };
        ChainableAttributeSpec.prototype.changeEvents = function (events$$1) {
            return this.metadata({ changeEvents: events$$1 });
        };
        ChainableAttributeSpec.prototype.events = function (map) {
            var eventMap = new EventMap(map);
            function handleEventsSubscribtion(next, prev, record) {
                prev && prev.trigger && eventMap.unsubscribe(record, prev);
                next && next.trigger && eventMap.subscribe(record, next);
            }
            return this.metadata({
                changeHandlers: this.options.changeHandlers.concat(handleEventsSubscribtion)
            });
        };
        Object.defineProperty(ChainableAttributeSpec.prototype, "has", {
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        ChainableAttributeSpec.prototype.metadata = function (options) {
            var cloned = new ChainableAttributeSpec(this.options);
            assign$3(cloned.options, options);
            return cloned;
        };
        ChainableAttributeSpec.prototype.value = function (x) {
            return this.metadata({ value: x, hasCustomDefault: true });
        };
        ChainableAttributeSpec.from = function (spec) {
            var attrSpec;
            if (typeof spec === 'function') {
                attrSpec = spec.has;
            }
            else if (spec && spec instanceof ChainableAttributeSpec) {
                attrSpec = spec;
            }
            else {
                var type_1 = inferType(spec);
                if (type_1 && type_1.prototype instanceof Transactional) {
                    attrSpec = type_1.shared.value(spec);
                }
                else {
                    attrSpec = new ChainableAttributeSpec({ type: type_1, value: spec, hasCustomDefault: true });
                }
            }
            return attrSpec;
        };
        return ChainableAttributeSpec;
    }());
    function emptyFunction() { }
    function type(spec) {
        return spec instanceof ChainableAttributeSpec ? spec : new ChainableAttributeSpec({
            type: spec,
            value: spec._attribute.defaultValue,
            hasCustomDefault: spec._attribute.defaultValue !== void 0
        });
    }
    Function.prototype.value = function (x) {
        return new ChainableAttributeSpec({ type: this, value: x, hasCustomDefault: true });
    };
    Object.defineProperty(Function.prototype, 'isRequired', {
        get: function () { return this._isRequired || this.has.isRequired; },
        set: function (x) { this._isRequired = x; }
    });
    Object.defineProperty(Function.prototype, 'asProp', {
        get: function () { return this.has.asProp; },
    });
    Object.defineProperty(Function.prototype, 'has', {
        get: function () {
            return this._has || type(this);
        },
        set: function (value) { this._has = value; }
    });
    function inferType(value) {
        switch (typeof value) {
            case 'number':
                return Number;
            case 'string':
                return String;
            case 'boolean':
                return Boolean;
            case 'undefined':
                return void 0;
            case 'object':
                return value ? value.constructor : void 0;
        }
    }

    var DateType = (function (_super) {
        __extends(DateType, _super);
        function DateType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DateType.prototype.create = function () {
            return new Date();
        };
        DateType.prototype.convert = function (next, a, record) {
            if (next == null || next instanceof Date)
                return next;
            var date = new Date(next), timestamp = date.getTime();
            if (timestamp !== timestamp) {
                this._log('warn', 'assigned with Invalid Date', next, record);
            }
            return date;
        };
        DateType.prototype.validate = function (model, value, name) {
            if (value != null) {
                var timestamp = value.getTime();
                if (timestamp !== timestamp)
                    return name + ' is Invalid Date';
            }
        };
        DateType.prototype.toJSON = function (value) { return value && value.toISOString(); };
        DateType.prototype.isChanged = function (a, b) { return (a && a.getTime()) !== (b && b.getTime()); };
        DateType.prototype.doInit = function (value, record, options) {
            return this.transform(value === void 0 ? this.defaultValue() : value, void 0, record, options);
        };
        DateType.prototype.doUpdate = function (value, record, options, nested) {
            var name = this.name, attributes = record.attributes, prev = attributes[name];
            return this.isChanged(prev, attributes[name] = this.transform(value, prev, record, options));
        };
        DateType.prototype.clone = function (value) { return value && new Date(value.getTime()); };
        DateType.prototype.dispose = function () { };
        return DateType;
    }(AnyType));
    Date._attribute = DateType;
    var msDatePattern = /\/Date\(([0-9]+)\)\//;
    var MSDateType = (function (_super) {
        __extends(MSDateType, _super);
        function MSDateType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MSDateType.prototype.convert = function (next) {
            if (typeof next === 'string') {
                var msDate = msDatePattern.exec(next);
                if (msDate) {
                    return new Date(Number(msDate[1]));
                }
            }
            return DateType.prototype.convert.apply(this, arguments);
        };
        MSDateType.prototype.toJSON = function (value) { return value && "/Date(" + value.getTime() + ")/"; };
        return MSDateType;
    }(DateType));
    var TimestampType = (function (_super) {
        __extends(TimestampType, _super);
        function TimestampType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimestampType.prototype.toJSON = function (value) { return value && value.getTime(); };
        return TimestampType;
    }(DateType));
    Object.defineProperties(Date, {
        microsoft: {
            get: function () {
                return new ChainableAttributeSpec({
                    type: Date,
                    _attribute: MSDateType
                });
            }
        },
        timestamp: {
            get: function () {
                return new ChainableAttributeSpec({
                    type: Date,
                    _attribute: TimestampType
                });
            }
        }
    });
    function supportsDate(date) {
        return !isNaN((new Date(date)).getTime());
    }
    if (!supportsDate('2011-11-29T15:52:30.5') ||
        !supportsDate('2011-11-29T15:52:30.52') ||
        !supportsDate('2011-11-29T15:52:18.867') ||
        !supportsDate('2011-11-29T15:52:18.867Z') ||
        !supportsDate('2011-11-29T15:52:18.867-03:30')) {
        DateType.prototype.convert = function (value) {
            return value == null || value instanceof Date ? value : new Date(safeParseDate(value));
        };
    }
    var numericKeys = [1, 4, 5, 6, 7, 10, 11], isoDatePattern = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
    function safeParseDate(date) {
        var timestamp, struct, minutesOffset = 0;
        if ((struct = isoDatePattern.exec(date))) {
            for (var i = 0, k; (k = numericKeys[i]); ++i) {
                struct[k] = +struct[k] || 0;
            }
            struct[2] = (+struct[2] || 1) - 1;
            struct[3] = +struct[3] || 1;
            if (struct[8] !== 'Z' && struct[9] !== undefined) {
                minutesOffset = struct[10] * 60 + struct[11];
                if (struct[9] === '+') {
                    minutesOffset = 0 - minutesOffset;
                }
            }
            timestamp =
                Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
        }
        else {
            timestamp = Date.parse(date);
        }
        return timestamp;
    }

    var ImmutableClassType = (function (_super) {
        __extends(ImmutableClassType, _super);
        function ImmutableClassType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ImmutableClassType.prototype.create = function () {
            return new this.type();
        };
        ImmutableClassType.prototype.convert = function (next) {
            return next == null || next instanceof this.type ? next : new this.type(next);
        };
        ImmutableClassType.prototype.toJSON = function (value, key, options) {
            return value && value.toJSON ? value.toJSON(options) : value;
        };
        ImmutableClassType.prototype.clone = function (value) {
            return new this.type(this.toJSON(value));
        };
        ImmutableClassType.prototype.isChanged = function (a, b) {
            return a !== b;
        };
        return ImmutableClassType;
    }(AnyType));
    Function.prototype._attribute = ImmutableClassType;
    var PrimitiveType = (function (_super) {
        __extends(PrimitiveType, _super);
        function PrimitiveType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PrimitiveType.prototype.dispose = function () { };
        PrimitiveType.prototype.create = function () { return this.type(); };
        PrimitiveType.prototype.toJSON = function (value) { return value; };
        PrimitiveType.prototype.convert = function (next) { return next == null ? next : this.type(next); };
        PrimitiveType.prototype.isChanged = function (a, b) { return a !== b; };
        PrimitiveType.prototype.clone = function (value) { return value; };
        PrimitiveType.prototype.doInit = function (value, record, options) {
            return this.transform(value === void 0 ? this.value : value, void 0, record, options);
        };
        PrimitiveType.prototype.doUpdate = function (value, record, options, nested) {
            var name = this.name, attributes = record.attributes, prev = attributes[name];
            return prev !== (attributes[name] = this.transform(value, prev, record, options));
        };
        PrimitiveType.prototype.initialize = function () {
            if (!this.options.hasCustomDefault) {
                this.value = this.type();
            }
        };
        return PrimitiveType;
    }(AnyType));
    Boolean._attribute = String._attribute = PrimitiveType;
    var NumericType = (function (_super) {
        __extends(NumericType, _super);
        function NumericType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumericType.prototype.create = function () {
            return 0;
        };
        NumericType.prototype.convert = function (next, prev, record) {
            var num = next == null ? next : this.type(next);
            if (num !== num) {
                this._log('warn', 'assigned with Invalid Number', next, record);
            }
            return num;
        };
        NumericType.prototype.validate = function (model, value, name) {
            if (value != null && !isFinite(value)) {
                return name + ' is not valid number';
            }
        };
        return NumericType;
    }(PrimitiveType));
    Number._attribute = NumericType;
    function Integer(x) {
        return x ? Math.round(x) : 0;
    }
    Integer._attribute = NumericType;
    Number.integer = Integer;
    if (typeof window !== 'undefined') {
        window.Integer = Number.integer;
    }
    var ArrayType = (function (_super) {
        __extends(ArrayType, _super);
        function ArrayType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ArrayType.prototype.toJSON = function (value) { return value; };
        ArrayType.prototype.dispose = function () { };
        ArrayType.prototype.create = function () { return []; };
        ArrayType.prototype.convert = function (next, prev, record) {
            if (next == null || Array.isArray(next))
                return next;
            this._log('warn', 'assignment of non-array to Array attribute is ignored', next, record);
            return [];
        };
        ArrayType.prototype.clone = function (value) {
            return value && value.slice();
        };
        return ArrayType;
    }(AnyType));
    Array._attribute = ArrayType;
    var ObjectType = (function (_super) {
        __extends(ObjectType, _super);
        function ObjectType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ObjectType.prototype.create = function () { return {}; };
        ObjectType.prototype.convert = function (next, prev, record) {
            if (next == null || typeof next === 'object')
                return next;
            this._log('warn', 'assignment of non-object to Object attribute is ignored', next, record);
            return {};
        };
        return ObjectType;
    }(AnyType));
    Object._attribute = ObjectType;
    function doNothing() { }
    var FunctionType = (function (_super) {
        __extends(FunctionType, _super);
        function FunctionType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FunctionType.prototype.toJSON = function (value) { return void 0; };
        FunctionType.prototype.create = function () { return doNothing; };
        FunctionType.prototype.dispose = function () { };
        FunctionType.prototype.convert = function (next, prev, record) {
            if (next == null || typeof next === 'function')
                return next;
            this._log('warn', 'assigned with non-function', next, record);
            return doNothing;
        };
        FunctionType.prototype.clone = function (value) { return value; };
        return FunctionType;
    }(AnyType));
    Function._attribute = FunctionType;

    var on$3 = on, off$3 = off, free$1 = transactionApi.free, aquire$1 = transactionApi.aquire;
    var shareAndListen = ItemsBehavior.listen | ItemsBehavior.share;
    var SharedType = (function (_super) {
        __extends(SharedType, _super);
        function SharedType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SharedType.prototype.doInit = function (value, record, options) {
            var v = options.clone ? this.clone(value, record) : (value === void 0 ? this.defaultValue() : value);
            var x = this.transform(v, void 0, record, options);
            this.handleChange(x, void 0, record, options);
            return x;
        };
        SharedType.prototype.doUpdate = function (value, record, options, nested) {
            var key = this.name, attributes = record.attributes;
            var prev = attributes[key];
            var update;
            if (update = this.canBeUpdated(prev, value, options)) {
                var nestedTransaction = prev._createTransaction(update, options);
                if (nestedTransaction) {
                    if (nested) {
                        nested.push(nestedTransaction);
                    }
                    else {
                        nestedTransaction.commit(record);
                    }
                    if (this.propagateChanges)
                        return true;
                }
                return false;
            }
            var next = this.transform(value, prev, record, options);
            attributes[key] = next;
            if (this.isChanged(next, prev)) {
                this.handleChange(next, prev, record, options);
                return true;
            }
            return false;
        };
        SharedType.prototype.clone = function (value, record) {
            if (!value || value._owner !== record)
                return value;
            var clone = value.clone();
            aquire$1(record, clone, this.name);
            return clone;
        };
        SharedType.prototype.toJSON = function () { };
        SharedType.prototype.canBeUpdated = function (prev, next, options) {
            if (prev && next != null && !(next instanceof this.type)) {
                return next;
            }
        };
        SharedType.prototype.convert = function (next, prev, record, options) {
            if (next == null || next instanceof this.type)
                return next;
            var implicitObject = new this.type(next, options, shareAndListen);
            aquire$1(record, implicitObject, this.name);
            return implicitObject;
        };
        SharedType.prototype.validate = function (model, value, name) { };
        SharedType.prototype.create = function () {
            return null;
        };
        SharedType.prototype._handleChange = function (next, prev, record, options) {
            if (prev) {
                if (prev._owner === record) {
                    free$1(record, prev);
                    options.unset || prev.dispose();
                }
                else {
                    off$3(prev, prev._changeEventName, this._onChange, record);
                }
            }
            if (next) {
                if (next._owner !== record) {
                    on$3(next, next._changeEventName, this._onChange, record);
                }
            }
        };
        SharedType.prototype.dispose = function (record, value) {
            if (value) {
                this.handleChange(void 0, value, record, {});
            }
        };
        SharedType.prototype.initialize = function (options) {
            var attribute = this;
            this._onChange = this.propagateChanges ? function (child, options, initiator) {
                this === initiator || this.forceAttributeChange(attribute.name, options);
            } : ignore;
            options.changeHandlers.unshift(this._handleChange);
        };
        return SharedType;
    }(AnyType));
    function ignore() { }

    function compile (attributesDefinition, baseClassAttributes) {
        var myAttributes = transform({}, attributesDefinition, createAttribute), allAttributes = defaults({}, myAttributes, baseClassAttributes);
        var ConstructorsMixin = constructorsMixin(allAttributes);
        return __assign({}, ConstructorsMixin, { _attributes: new ConstructorsMixin.AttributesCopy(allAttributes), _attributesArray: Object.keys(allAttributes).map(function (key) { return allAttributes[key]; }), properties: transform({}, myAttributes, function (x) { return x.createPropertyDescriptor(); }) }, localEventsMixin(myAttributes), { _endpoints: transform({}, allAttributes, function (attrDef) { return attrDef.options.endpoint; }) });
    }
    function createAttribute(spec, name) {
        return AnyType.create(ChainableAttributeSpec.from(spec).options, name);
    }
    function createSharedTypeSpec(Constructor, Attribute) {
        if (!Constructor.hasOwnProperty('shared')) {
            Object.defineProperty(Constructor, 'shared', {
                get: function () {
                    return new ChainableAttributeSpec({
                        value: null,
                        type: Constructor,
                        _attribute: Attribute
                    });
                }
            });
        }
    }
    function localEventsMixin(attrSpecs) {
        var _localEvents;
        for (var key in attrSpecs) {
            var attribute = attrSpecs[key], _onChange = attribute.options._onChange;
            if (_onChange) {
                _localEvents || (_localEvents = new EventMap());
                _localEvents.addEvent('change:' + key, typeof _onChange === 'string' ?
                    createWatcherFromRef(_onChange, key) :
                    wrapWatcher(_onChange, key));
            }
        }
        return _localEvents ? { _localEvents: _localEvents } : {};
    }
    function wrapWatcher(watcher, key) {
        return function (record, value) {
            watcher.call(record, value, key);
        };
    }
    function createWatcherFromRef(ref, key) {
        var _a = new CompiledReference(ref, true), local = _a.local, resolve = _a.resolve, tail = _a.tail;
        return local ?
            function (record, value) {
                record[tail](value, key);
            } :
            function (record, value) {
                resolve(record)[tail](value, key);
            };
    }

    var IORecordMixin = {
        save: function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var endpoint = this.getEndpoint(), json = this.toJSON(options);
            return startIO(this, this.isNew() ?
                endpoint.create(json, options, this) :
                endpoint.update(this.id, json, options, this), options, function (update) {
                _this.set(update, __assign({ parse: true }, options));
            });
        },
        fetch: function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            return startIO(this, this.getEndpoint().read(this.id, options, this), options, function (json) { return _this.set(json, __assign({ parse: true }, options)); });
        },
        destroy: function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            return startIO(this, this.getEndpoint().destroy(this.id, options, this), options, function () {
                var collection = _this.collection;
                if (collection) {
                    collection.remove(_this, options);
                }
                else {
                    _this.dispose();
                }
                return _this;
            });
        }
    };

    var assign$4 = assign, isEmpty$1 = isEmpty, log$1 = log;
    var _cidCounter = 0;
    var Record = (function (_super) {
        __extends(Record, _super);
        function Record(a_values, a_options) {
            var _this = _super.call(this, _cidCounter++) || this;
            _this.attributes = {};
            var options = a_options || {}, values = (options.parse ? _this.parse(a_values, options) : a_values) || {};
            if (log$1.level > 1)
                typeCheck(_this, values);
            _this._previousAttributes = _this.attributes = new _this.Attributes(_this, values, options);
            _this.initialize(a_values, a_options);
            if (_this._localEvents)
                _this._localEvents.subscribe(_this, _this);
            return _this;
        }
        Record_1 = Record;
        Record.onDefine = function (definition, BaseClass) { };
        Record.defaults = function (attrs) {
            return this.extend({ attributes: attrs });
        };
        Record.prototype.save = function (options) { throw new Error('Implemented by mixin'); };
        Record.prototype.destroy = function (options) { throw new Error('Implemented by mixin'); };
        Record.prototype.previousAttributes = function () { return new this.AttributesCopy(this._previousAttributes); };
        Object.defineProperty(Record.prototype, "__inner_state__", {
            get: function () { return this.attributes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Record.prototype, "changed", {
            get: function () {
                var changed = this._changedAttributes;
                if (!changed) {
                    var prev = this._previousAttributes;
                    changed = {};
                    var _a = this, _attributes = _a._attributes, attributes = _a.attributes;
                    for (var _i = 0, _b = this._attributesArray; _i < _b.length; _i++) {
                        var attr = _b[_i];
                        var key = attr.name, value = attributes[key];
                        if (attr.isChanged(value, prev[key])) {
                            changed[key] = value;
                        }
                    }
                    this._changedAttributes = changed;
                }
                return changed;
            },
            enumerable: true,
            configurable: true
        });
        Record.prototype.changedAttributes = function (diff) {
            if (!diff)
                return this.hasChanged() ? assign$4({}, this.changed) : false;
            var val, changed = false, old = this._transaction ? this._previousAttributes : this.attributes, attrSpecs = this._attributes;
            for (var attr in diff) {
                if (!attrSpecs[attr].isChanged(old[attr], (val = diff[attr])))
                    continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        };
        Record.prototype.hasChanged = function (key) {
            var _previousAttributes = this._previousAttributes;
            if (!_previousAttributes)
                return false;
            return key ?
                this._attributes[key].isChanged(this.attributes[key], _previousAttributes[key]) :
                !isEmpty$1(this.changed);
        };
        Record.prototype.previous = function (key) {
            if (key) {
                var _previousAttributes = this._previousAttributes;
                if (_previousAttributes)
                    return _previousAttributes[key];
            }
            return null;
        };
        Record.prototype.isNew = function () {
            return this.id == null;
        };
        Record.prototype.has = function (key) {
            return this[key] != void 0;
        };
        Record.prototype.unset = function (key, options) {
            var _a;
            var value = this[key];
            this.set((_a = {}, _a[key] = void 0, _a), __assign({ unset: true }, options));
            return value;
        };
        Record.prototype.clear = function (options) {
            var _this = this;
            var nullify = options && options.nullify;
            this.transaction(function () {
                _this.forEachAttr(_this.attributes, function (value, key) { return _this[key] = nullify ? null : void 0; });
            }, options);
            return this;
        };
        Record.prototype.getOwner = function () {
            var owner = this._owner;
            return this._ownerKey ? owner : owner && owner._owner;
        };
        Object.defineProperty(Record.prototype, "id", {
            get: function () { return this.attributes[this.idAttribute]; },
            set: function (x) { setAttribute(this, this.idAttribute, x); },
            enumerable: true,
            configurable: true
        });
        Record.prototype.forEachAttr = function (attrs, iteratee) {
            var _attributes = this._attributes;
            var unknown;
            for (var name_1 in attrs) {
                var spec = _attributes[name_1];
                if (spec) {
                    iteratee(attrs[name_1], name_1, spec);
                }
                else {
                    unknown || (unknown = []);
                    unknown.push("'" + name_1 + "'");
                }
            }
            if (unknown) {
                this._log('warn', "attributes " + unknown.join(', ') + " are not defined", {
                    attributes: attrs
                });
            }
        };
        Record.prototype.each = function (iteratee, context) {
            var fun = context !== void 0 ? function (v, k) { return iteratee.call(context, v, k); } : iteratee, attributes = this.attributes;
            for (var key in this.attributes) {
                var value = attributes[key];
                if (value !== void 0)
                    fun(value, key);
            }
        };
        Record.prototype.keys = function () {
            var keys$$1 = [];
            this.each(function (value, key) { return value === void 0 || keys$$1.push(key); });
            return keys$$1;
        };
        Record.prototype.values = function () {
            return this.map(function (value) { return value; });
        };
        Record.prototype.defaults = function (values) {
            if (values === void 0) { values = {}; }
            var defaults$$1 = {}, _attributesArray = this._attributesArray;
            for (var _i = 0, _attributesArray_1 = _attributesArray; _i < _attributesArray_1.length; _i++) {
                var attr = _attributesArray_1[_i];
                var key = attr.name, value = values[key];
                defaults$$1[key] = value === void 0 ? attr.defaultValue() : value;
            }
            return defaults$$1;
        };
        Record.prototype.initialize = function (values, options) { };
        Record.prototype.clone = function (options) {
            if (options === void 0) { options = {}; }
            var copy = new this.constructor(this.attributes, { clone: true });
            if (options.pinStore)
                copy._defaultStore = this.getStore();
            return copy;
        };
        Record.prototype.deepClone = function () { return this.clone(); };
        Record.prototype._validateNested = function (errors) {
            var _this = this;
            var length = 0;
            this.forEachAttr(this.attributes, function (value, name, attribute) {
                var error = attribute.validate(_this, value, name);
                if (error) {
                    errors[name] = error;
                    length++;
                }
            });
            return length;
        };
        Record.prototype.get = function (key) {
            return this[key];
        };
        Record.prototype.toJSON = function (options) {
            var _this = this;
            var json = {};
            this.forEachAttr(this.attributes, function (value, key, _a) {
                var toJSON = _a.toJSON;
                if (value !== void 0) {
                    var asJson = toJSON.call(_this, value, key, options);
                    if (asJson !== void 0)
                        json[key] = asJson;
                }
            });
            return json;
        };
        Record.prototype.parse = function (data, options) {
            return data;
        };
        Record.prototype._parse = function (data) { return data; };
        Record.prototype.deepSet = function (name, value, options) {
            var _this = this;
            this.transaction(function () {
                var _a;
                var path$$1 = name.split('.'), l = path$$1.length - 1, attr = path$$1[l];
                var model = _this;
                for (var i = 0; i < l; i++) {
                    var key = path$$1[i];
                    var next = model.get ? model.get(key) : model[key];
                    if (!next) {
                        var attrSpecs = model._attributes;
                        if (attrSpecs) {
                            var newModel = attrSpecs[key].create();
                            if (options && options.nullify && newModel._attributes) {
                                newModel.clear(options);
                            }
                            model[key] = next = newModel;
                        }
                        else
                            return;
                    }
                    model = next;
                }
                if (model.set) {
                    model.set((_a = {}, _a[attr] = value, _a), options);
                }
                else {
                    model[attr] = value;
                }
            });
            return this;
        };
        Object.defineProperty(Record.prototype, "collection", {
            get: function () {
                return this._ownerKey ? null : this._owner;
            },
            enumerable: true,
            configurable: true
        });
        Record.prototype.dispose = function () {
            var _this = this;
            if (this._disposed)
                return;
            this.forEachAttr(this.attributes, function (value, key, attribute) {
                attribute.dispose(_this, value);
            });
            _super.prototype.dispose.call(this);
        };
        Record.prototype._log = function (level, text, props) {
            log(level, '[Record] ' + text, __assign({ 'Record': this, 'Attributes definition:': this._attributes }, props));
        };
        Record.prototype.getClassName = function () {
            return _super.prototype.getClassName.call(this) || 'Record';
        };
        Record.prototype._createTransaction = function (values, options) { return void 0; };
        var Record_1;
        Record = Record_1 = __decorate([
            define({
                cidPrefix: 'm',
                _changeEventName: 'change',
                idAttribute: 'id'
            }),
            definitions({
                defaults: mixinRules.merge,
                attributes: mixinRules.merge,
                collection: mixinRules.merge,
                Collection: mixinRules.value,
                idAttribute: mixinRules.protoValue
            })
        ], Record);
        return Record;
    }(Transactional));
    assign$4(Record.prototype, UpdateRecordMixin, IORecordMixin);
    var BaseRecordAttributes = (function () {
        function BaseRecordAttributes(record, x, options) {
            this.id = x.id;
        }
        return BaseRecordAttributes;
    }());
    Record.prototype.Attributes = BaseRecordAttributes;
    var BaseRecordAttributesCopy = (function () {
        function BaseRecordAttributesCopy(x) {
            this.id = x.id;
        }
        return BaseRecordAttributesCopy;
    }());
    Record.prototype.AttributesCopy = BaseRecordAttributesCopy;
    var IdAttribute = AnyType.create({ value: void 0 }, 'id');
    Record.prototype._attributes = { id: IdAttribute };
    Record.prototype._attributesArray = [IdAttribute];
    Record._attribute = AggregatedType;
    function typeCheck(record, values) {
        if (shouldBeAnObject(record, values)) {
            var _attributes = record._attributes;
            var unknown = void 0;
            for (var name_2 in values) {
                if (!_attributes[name_2]) {
                    unknown || (unknown = []);
                    unknown.push("'" + name_2 + "'");
                }
            }
            if (unknown) {
                record._log('warn', "undefined attributes " + unknown.join(', ') + " are ignored.", { values: values });
            }
        }
    }

    var assign$5 = assign, defaults$1 = defaults;
    Record.onExtend = function (BaseClass) {
        Transactional.onExtend.call(this, BaseClass);
        var Class = this;
        var DefaultCollection = (function (_super) {
            __extends(DefaultCollection, _super);
            function DefaultCollection() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DefaultCollection.model = Class;
            DefaultCollection = __decorate([
                predefine
            ], DefaultCollection);
            return DefaultCollection;
        }(BaseClass.Collection));
        this.DefaultCollection = DefaultCollection;
        if (Class.Collection === BaseClass.Collection) {
            this.Collection = DefaultCollection;
        }
        createSharedTypeSpec(this, SharedType);
    };
    Record.onDefine = function (definition, BaseClass) {
        var baseProto = BaseClass.prototype;
        var _a = compile(this.attributes = getAttributes(definition), baseProto._attributes), properties = _a.properties, _localEvents = _a._localEvents, dynamicMixin = __rest(_a, ["properties", "_localEvents"]);
        assign$5(this.prototype, dynamicMixin);
        definition.properties = defaults$1(definition.properties || {}, properties);
        definition._localEvents = _localEvents;
        Transactional.onDefine.call(this, definition, BaseClass);
        this.DefaultCollection.define(definition.collection || {});
        this.Collection = definition.Collection;
        this.Collection.prototype.model = this;
        if (definition.endpoint)
            this.Collection.prototype._endpoint = definition.endpoint;
    };
    Record._attribute = AggregatedType;
    createSharedTypeSpec(Record, SharedType);
    function getAttributes(_a) {
        var defaults$$1 = _a.defaults, attributes = _a.attributes, idAttribute = _a.idAttribute;
        var definition = attributes || defaults$$1 || {};
        if (idAttribute && !(idAttribute in definition)) {
            definition[idAttribute] = void 0;
        }
        return definition;
    }
    function attr(proto, attrName) {
        if (attrName) {
            if (typeof Reflect !== 'undefined' && Reflect.getMetadata) {
                Reflect
                    .getMetadata("design:type", proto, attrName)
                    .asProp(proto, attrName);
            }
            else {
                proto._log('error', 'Add import "reflect-metadata"; as the first line of your app.');
            }
        }
        else {
            return ChainableAttributeSpec.from(proto).asProp;
        }
    }
    function prop(spec) {
        return spec.asProp;
    }

    var trigger2$3 = trigger2, trigger3$4 = trigger3, on$4 = on, off$4 = off, commit$1 = transactionApi.commit, _aquire = transactionApi.aquire, _free = transactionApi.free;
    function convertAndAquire(collection, attrs, options) {
        var model = collection.model;
        var record;
        if (collection._shared) {
            record = attrs instanceof model ? attrs : model.create(attrs, options);
            if (collection._shared & ItemsBehavior.listen) {
                on$4(record, record._changeEventName, collection._onChildrenChange, collection);
            }
        }
        else {
            record = attrs instanceof model ? (options.merge ? attrs.clone() : attrs) : model.create(attrs, options);
            if (!_aquire(collection, record)) {
                var errors = collection._aggregationError || (collection._aggregationError = []);
                errors.push(record);
            }
        }
        var _itemEvents = collection._itemEvents;
        _itemEvents && _itemEvents.subscribe(collection, record);
        return record;
    }
    function free$2(owner, child, unset) {
        if (owner._shared) {
            if (owner._shared & ItemsBehavior.listen) {
                off$4(child, child._changeEventName, owner._onChildrenChange, owner);
            }
        }
        else {
            _free(owner, child);
            unset || child.dispose();
        }
        var _itemEvents = owner._itemEvents;
        _itemEvents && _itemEvents.unsubscribe(owner, child);
    }
    function freeAll(collection, children) {
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var child = children_1[_i];
            free$2(collection, child);
        }
        return children;
    }
    function sortElements(collection, options) {
        var _comparator = collection._comparator;
        if (_comparator && options.sort !== false) {
            collection.models.sort(_comparator);
            return true;
        }
        return false;
    }
    function addIndex(index, model) {
        index[model.cid] = model;
        var id = model.id;
        if (id || id === 0) {
            index[id] = model;
        }
    }
    function removeIndex(index, model) {
        delete index[model.cid];
        var id = model.id;
        if (id || id === 0) {
            delete index[id];
        }
    }
    function updateIndex(index, model) {
        delete index[model.previous(model.idAttribute)];
        var id = model.id;
        id == null || (index[id] = model);
    }
    var CollectionTransaction = (function () {
        function CollectionTransaction(object, isRoot, added, removed, nested, sorted) {
            this.object = object;
            this.isRoot = isRoot;
            this.added = added;
            this.removed = removed;
            this.nested = nested;
            this.sorted = sorted;
        }
        CollectionTransaction.prototype.commit = function (initiator) {
            var _a = this, nested = _a.nested, object = _a.object, _isDirty = object._isDirty;
            for (var _i = 0, nested_1 = nested; _i < nested_1.length; _i++) {
                var transaction = nested_1[_i];
                transaction.commit(object);
            }
            if (object._aggregationError) {
                logAggregationError(object);
            }
            for (var _b = 0, nested_2 = nested; _b < nested_2.length; _b++) {
                var transaction = nested_2[_b];
                trigger2$3(object, 'change', transaction.object, _isDirty);
            }
            var _c = this, added = _c.added, removed = _c.removed;
            for (var _d = 0, added_1 = added; _d < added_1.length; _d++) {
                var record = added_1[_d];
                trigger3$4(record, 'add', record, object, _isDirty);
                trigger3$4(object, 'add', record, object, _isDirty);
            }
            for (var _e = 0, removed_1 = removed; _e < removed_1.length; _e++) {
                var record = removed_1[_e];
                trigger3$4(record, 'remove', record, object, _isDirty);
                trigger3$4(object, 'remove', record, object, _isDirty);
            }
            if (this.sorted) {
                trigger2$3(object, 'sort', object, _isDirty);
            }
            if (added.length || removed.length) {
                trigger2$3(object, 'update', object, _isDirty);
            }
            this.isRoot && commit$1(object, initiator);
        };
        return CollectionTransaction;
    }());
    function logAggregationError(collection) {
        collection._log('error', 'added records already have an owner', collection._aggregationError);
        collection._aggregationError = void 0;
    }

    var begin$1 = transactionApi.begin, commit$2 = transactionApi.commit, markAsDirty$2 = transactionApi.markAsDirty;
    function addTransaction(collection, items, options, merge) {
        var isRoot = begin$1(collection), nested = [];
        var added = appendElements(collection, items, nested, options, merge);
        if (added.length || nested.length) {
            var needSort = sortOrMoveElements(collection, added, options);
            if (markAsDirty$2(collection, options)) {
                return new CollectionTransaction(collection, isRoot, added, [], nested, needSort);
            }
            if (collection._aggregationError)
                logAggregationError(collection);
        }
        isRoot && commit$2(collection);
    }
    function sortOrMoveElements(collection, added, options) {
        var at = options.at;
        if (at != null) {
            var length_1 = collection.models.length - added.length;
            at = Number(at);
            if (at < 0)
                at += length_1 + 1;
            if (at < 0)
                at = 0;
            if (at > length_1)
                at = length_1;
            moveElements(collection.models, at, added);
            return false;
        }
        return sortElements(collection, options);
    }
    function moveElements(source, at, added) {
        for (var j = source.length - 1, i = j - added.length; i >= at; i--, j--) {
            source[j] = source[i];
        }
        for (i = 0, j = at; i < added.length; i++, j++) {
            source[j] = added[i];
        }
    }
    function appendElements(collection, a_items, nested, a_options, forceMerge) {
        var _byId = collection._byId, models = collection.models, merge = (forceMerge || a_options.merge) && !collection._shared, parse = a_options.parse, idAttribute = collection.model.prototype.idAttribute, prevLength = models.length;
        for (var _i = 0, a_items_1 = a_items; _i < a_items_1.length; _i++) {
            var item = a_items_1[_i];
            var model = item ? _byId[item[idAttribute]] || _byId[item.cid] : null;
            if (model) {
                if (merge && item !== model) {
                    var attrs = item.attributes || item;
                    var transaction = model._createTransaction(attrs, a_options);
                    transaction && nested.push(transaction);
                    if (model.hasChanged(idAttribute)) {
                        updateIndex(_byId, model);
                    }
                }
            }
            else {
                model = convertAndAquire(collection, item, a_options);
                models.push(model);
                addIndex(_byId, model);
            }
        }
        return models.slice(prevLength);
    }

    var begin$2 = transactionApi.begin, commit$3 = transactionApi.commit, markAsDirty$3 = transactionApi.markAsDirty;
    var silentOptions = { silent: true };
    function emptySetTransaction(collection, items, options, silent) {
        var isRoot = begin$2(collection);
        var added = _reallocateEmpty(collection, items, options);
        if (added.length) {
            var needSort = sortElements(collection, options);
            if (markAsDirty$3(collection, silent ? silentOptions : options)) {
                return new CollectionTransaction(collection, isRoot, added.slice(), [], [], needSort);
            }
            if (collection._aggregationError)
                logAggregationError(collection);
        }
        isRoot && commit$3(collection);
    }
    function setTransaction(collection, items, options) {
        var isRoot = begin$2(collection), nested = [];
        var previous = collection.models, added = _reallocate(collection, items, nested, options);
        var reusedCount = collection.models.length - added.length, removed = reusedCount < previous.length ? (reusedCount ? _garbageCollect(collection, previous) :
            freeAll(collection, previous)) : [];
        var addedOrChanged = nested.length || added.length, sorted = (sortElements(collection, options) && addedOrChanged) || added.length || options.sorted;
        if (addedOrChanged || removed.length || sorted) {
            if (markAsDirty$3(collection, options)) {
                return new CollectionTransaction(collection, isRoot, added, removed, nested, sorted);
            }
            if (collection._aggregationError)
                logAggregationError(collection);
        }
        isRoot && commit$3(collection);
    }
    function _garbageCollect(collection, previous) {
        var _byId = collection._byId, removed = [];
        for (var _i = 0, previous_1 = previous; _i < previous_1.length; _i++) {
            var record = previous_1[_i];
            if (!_byId[record.cid]) {
                removed.push(record);
                free$2(collection, record);
            }
        }
        return removed;
    }
    function _reallocate(collection, source, nested, options) {
        var models = Array(source.length), _byId = {}, merge = (options.merge == null ? true : options.merge) && !collection._shared, _prevById = collection._byId, prevModels = collection.models, idAttribute = collection.model.prototype.idAttribute, toAdd = [], orderKept = true;
        for (var i = 0, j = 0; i < source.length; i++) {
            var item = source[i], model = null;
            if (item) {
                var id = item[idAttribute], cid = item.cid;
                if (_byId[id] || _byId[cid])
                    continue;
                model = _prevById[id] || _prevById[cid];
            }
            if (model) {
                if (merge && item !== model) {
                    if (orderKept && prevModels[j] !== model)
                        orderKept = false;
                    var attrs = item.attributes || item;
                    var transaction = model._createTransaction(attrs, options);
                    transaction && nested.push(transaction);
                }
            }
            else {
                model = convertAndAquire(collection, item, options);
                toAdd.push(model);
            }
            models[j++] = model;
            addIndex(_byId, model);
        }
        models.length = j;
        collection.models = models;
        collection._byId = _byId;
        if (!orderKept)
            options.sorted = true;
        return toAdd;
    }
    function _reallocateEmpty(self, source, options) {
        var len = source ? source.length : 0, models = Array(len), _byId = {}, idAttribute = self.model.prototype.idAttribute;
        for (var i = 0, j = 0; i < len; i++) {
            var src = source[i];
            if (src && (_byId[src[idAttribute]] || _byId[src.cid])) {
                continue;
            }
            var model = convertAndAquire(self, src, options);
            models[j++] = model;
            addIndex(_byId, model);
        }
        models.length = j;
        self._byId = _byId;
        return self.models = models;
    }

    var trigger2$4 = trigger2, trigger3$5 = trigger3, markAsDirty$4 = transactionApi.markAsDirty, begin$3 = transactionApi.begin, commit$4 = transactionApi.commit;
    function removeOne(collection, el, options) {
        var model = collection.get(el);
        if (model) {
            var isRoot = begin$3(collection), models = collection.models;
            models.splice(models.indexOf(model), 1);
            removeIndex(collection._byId, model);
            var notify = markAsDirty$4(collection, options);
            if (notify) {
                trigger3$5(model, 'remove', model, collection, options);
                trigger3$5(collection, 'remove', model, collection, options);
            }
            free$2(collection, model, options.unset);
            notify && trigger2$4(collection, 'update', collection, options);
            isRoot && commit$4(collection);
            return model;
        }
    }
    function removeMany(collection, toRemove, options) {
        var removed = _removeFromIndex(collection, toRemove, options.unset);
        if (removed.length) {
            var isRoot = begin$3(collection);
            _reallocate$1(collection, removed.length);
            if (markAsDirty$4(collection, options)) {
                var transaction = new CollectionTransaction(collection, isRoot, [], removed, [], false);
                transaction.commit();
            }
            else {
                isRoot && commit$4(collection);
            }
        }
        return removed;
    }
    function _removeFromIndex(collection, toRemove, unset) {
        var removed = Array(toRemove.length), _byId = collection._byId;
        for (var i = 0, j = 0; i < toRemove.length; i++) {
            var model = collection.get(toRemove[i]);
            if (model) {
                removed[j++] = model;
                removeIndex(_byId, model);
                free$2(collection, model, unset);
            }
        }
        removed.length = j;
        return removed;
    }
    function _reallocate$1(collection, removed) {
        var prev = collection.models, models = collection.models = Array(prev.length - removed), _byId = collection._byId;
        for (var i = 0, j = 0; i < prev.length; i++) {
            var model = prev[i];
            if (_byId[model.cid]) {
                models[j++] = model;
            }
        }
        models.length = j;
    }

    var trigger2$5 = trigger2, begin$4 = transactionApi.begin, commit$5 = transactionApi.commit, markAsDirty$5 = transactionApi.markAsDirty, assign$6 = assign, defaults$2 = defaults;
    var _count = 0;
    var slice = Array.prototype.slice;
    var CollectionRefsType = (function (_super) {
        __extends(CollectionRefsType, _super);
        function CollectionRefsType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CollectionRefsType.defaultValue = [];
        return CollectionRefsType;
    }(SharedType));
    var Collection = (function (_super) {
        __extends(Collection, _super);
        function Collection(records, options, shared) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, _count++) || this;
            _this.models = [];
            _this._byId = {};
            _this.comparator = _this.comparator;
            if (options.comparator !== void 0) {
                _this.comparator = options.comparator;
                options.comparator = void 0;
            }
            _this.model = _this.model;
            if (options.model) {
                _this.model = options.model;
                options.model = void 0;
            }
            _this.idAttribute = _this.model.prototype.idAttribute;
            _this._shared = shared || 0;
            if (records) {
                var elements = toElements(_this, records, options);
                emptySetTransaction(_this, elements, options, true);
            }
            _this.initialize.apply(_this, arguments);
            if (_this._localEvents)
                _this._localEvents.subscribe(_this, _this);
            return _this;
        }
        Collection_1 = Collection;
        Collection.prototype.createSubset = function (models, options) {
            var SubsetOf = this.constructor.subsetOf(this).options.type, subset = new SubsetOf(models, options);
            subset.resolve(this);
            return subset;
        };
        Collection.onExtend = function (BaseClass) {
            var Ctor = this;
            this._SubsetOf = null;
            function RefsCollection(a, b, listen) {
                Ctor.call(this, a, b, ItemsBehavior.share | (listen ? ItemsBehavior.listen : 0));
            }
            Mixable.mixins.populate(RefsCollection);
            RefsCollection.prototype = this.prototype;
            RefsCollection._attribute = CollectionRefsType;
            this.Refs = this.Subset = RefsCollection;
            Transactional.onExtend.call(this, BaseClass);
            createSharedTypeSpec(this, SharedType);
        };
        Collection.onDefine = function (definition, BaseClass) {
            if (definition.itemEvents) {
                var eventsMap = new EventMap(BaseClass.prototype._itemEvents);
                eventsMap.addEventsMap(definition.itemEvents);
                this.prototype._itemEvents = eventsMap;
            }
            if (definition.comparator !== void 0)
                this.prototype.comparator = definition.comparator;
            Transactional.onDefine.call(this, definition);
        };
        Object.defineProperty(Collection.prototype, "__inner_state__", {
            get: function () { return this.models; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Collection.prototype, "comparator", {
            get: function () { return this._comparator; },
            set: function (x) {
                var _this = this;
                switch (typeof x) {
                    case 'string':
                        this._comparator = function (a, b) {
                            var aa = a[x], bb = b[x];
                            if (aa === bb)
                                return 0;
                            return aa < bb ? -1 : +1;
                        };
                        break;
                    case 'function':
                        if (x.length === 1) {
                            this._comparator = function (a, b) {
                                var aa = x.call(_this, a), bb = x.call(_this, b);
                                if (aa === bb)
                                    return 0;
                                return aa < bb ? -1 : +1;
                            };
                        }
                        else {
                            this._comparator = function (a, b) { return x.call(_this, a, b); };
                        }
                        break;
                    default:
                        this._comparator = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Collection.prototype.getStore = function () {
            return this._store || (this._store = this._owner ? this._owner.getStore() : this._defaultStore);
        };
        Collection.prototype._onChildrenChange = function (record, options, initiator) {
            if (options === void 0) { options = {}; }
            if (initiator === this)
                return;
            var idAttribute = this.idAttribute;
            if (record.hasChanged(idAttribute)) {
                updateIndex(this._byId, record);
            }
            var isRoot = begin$4(this);
            if (markAsDirty$5(this, options)) {
                trigger2$5(this, 'change', record, options);
            }
            isRoot && commit$5(this);
        };
        Collection.prototype.get = function (objOrId) {
            if (objOrId == null)
                return;
            if (typeof objOrId === 'object') {
                var id = objOrId[this.idAttribute];
                return (id !== void 0 && this._byId[id]) || this._byId[objOrId.cid];
            }
            else {
                return this._byId[objOrId];
            }
        };
        Collection.prototype.each = function (iteratee, context) {
            var fun = bindContext(iteratee, context), models = this.models;
            for (var i = 0; i < models.length; i++) {
                fun(models[i], i);
            }
        };
        Collection.prototype.forEach = function (iteratee, context) {
            return this.each(iteratee, context);
        };
        Collection.prototype.every = function (iteratee, context) {
            var fun = toPredicateFunction(iteratee, context), models = this.models;
            for (var i = 0; i < models.length; i++) {
                if (!fun(models[i], i))
                    return false;
            }
            return true;
        };
        Collection.prototype.filter = function (iteratee, context) {
            var fun = toPredicateFunction(iteratee, context), models = this.models;
            return this.map(function (x, i) { return fun(x, i) ? x : void 0; });
        };
        Collection.prototype.find = function (iteratee, context) {
            var fun = toPredicateFunction(iteratee, context), models = this.models;
            for (var i = 0; i < models.length; i++) {
                if (fun(models[i], i))
                    return models[i];
            }
            return null;
        };
        Collection.prototype.some = function (iteratee, context) {
            return Boolean(this.find(iteratee, context));
        };
        Collection.prototype.map = function (iteratee, context) {
            var fun = bindContext(iteratee, context), models = this.models, mapped = Array(models.length);
            var j = 0;
            for (var i = 0; i < models.length; i++) {
                var x = fun(models[i], i);
                x === void 0 || (mapped[j++] = x);
            }
            mapped.length = j;
            return mapped;
        };
        Collection.prototype._validateNested = function (errors) {
            if (this._shared)
                return 0;
            var count = 0;
            this.each(function (record) {
                var error = record.validationError;
                if (error) {
                    errors[record.cid] = error;
                    count++;
                }
            });
            return count;
        };
        Collection.prototype.initialize = function () { };
        Object.defineProperty(Collection.prototype, "length", {
            get: function () { return this.models.length; },
            enumerable: true,
            configurable: true
        });
        Collection.prototype.first = function () { return this.models[0]; };
        Collection.prototype.last = function () { return this.models[this.models.length - 1]; };
        Collection.prototype.at = function (a_index) {
            var index = a_index < 0 ? a_index + this.models.length : a_index;
            return this.models[index];
        };
        Collection.prototype.clone = function (options) {
            if (options === void 0) { options = {}; }
            var models = this._shared & ItemsBehavior.share ? this.models : this.map(function (model) { return model.clone(); }), copy = new this.constructor(models, { model: this.model, comparator: this.comparator }, this._shared);
            if (options.pinStore)
                copy._defaultStore = this.getStore();
            return copy;
        };
        Collection.prototype.toJSON = function (options) {
            return this.models.map(function (model) { return model.toJSON(options); });
        };
        Collection.prototype.set = function (elements, options) {
            if (elements === void 0) { elements = []; }
            if (options === void 0) { options = {}; }
            if (options.add !== void 0) {
                this._log('warn', "Collection.set doesn't support 'add' option, behaving as if options.add === true.", options);
            }
            if (options.reset) {
                this.reset(elements, options);
            }
            else {
                var transaction = this._createTransaction(elements, options);
                transaction && transaction.commit();
            }
            return this;
        };
        Collection.prototype.liveUpdates = function (enabled) {
            var _this = this;
            if (enabled) {
                this.liveUpdates(false);
                var filter_1 = typeof enabled === 'function' ? enabled : function () { return true; };
                this._liveUpdates = {
                    updated: function (json) {
                        filter_1(json) && _this.add(json, { parse: true, merge: true });
                    },
                    removed: function (id) { return _this.remove(id); }
                };
                return this.getEndpoint().subscribe(this._liveUpdates, this).then(function () { return _this; });
            }
            else {
                if (this._liveUpdates) {
                    this.getEndpoint().unsubscribe(this._liveUpdates, this);
                    this._liveUpdates = null;
                }
            }
        };
        Collection.prototype.fetch = function (a_options) {
            var _this = this;
            if (a_options === void 0) { a_options = {}; }
            var options = __assign({ parse: true }, a_options), endpoint = this.getEndpoint();
            return startIO(this, endpoint.list(options, this), options, function (json) {
                var result = _this.set(json, __assign({ parse: true }, options));
                if (options.liveUpdates) {
                    result = _this.liveUpdates(options.liveUpdates);
                }
                return result;
            });
        };
        Collection.prototype.dispose = function () {
            if (this._disposed)
                return;
            var aggregated = !this._shared;
            for (var _i = 0, _a = this.models; _i < _a.length; _i++) {
                var record = _a[_i];
                free$2(this, record);
                if (aggregated)
                    record.dispose();
            }
            this.liveUpdates(false);
            _super.prototype.dispose.call(this);
        };
        Collection.prototype.reset = function (a_elements, options) {
            if (options === void 0) { options = {}; }
            var isRoot = begin$4(this), previousModels = this.models;
            if (a_elements) {
                emptySetTransaction(this, toElements(this, a_elements, options), options, true);
            }
            else {
                this._byId = {};
                this.models = [];
            }
            markAsDirty$5(this, options);
            options.silent || trigger2$5(this, 'reset', this, defaults$2({ previousModels: previousModels }, options));
            var _byId = this._byId;
            for (var _i = 0, previousModels_1 = previousModels; _i < previousModels_1.length; _i++) {
                var toDispose = previousModels_1[_i];
                _byId[toDispose.cid] || free$2(this, toDispose);
            }
            isRoot && commit$5(this);
            return this.models;
        };
        Collection.prototype.add = function (a_elements, options) {
            if (options === void 0) { options = {}; }
            var elements = toElements(this, a_elements, options), transaction = this.models.length ?
                addTransaction(this, elements, options) :
                emptySetTransaction(this, elements, options);
            if (transaction) {
                transaction.commit();
                return transaction.added;
            }
        };
        Collection.prototype.remove = function (recordsOrIds, options) {
            if (options === void 0) { options = {}; }
            if (recordsOrIds) {
                return Array.isArray(recordsOrIds) ?
                    removeMany(this, recordsOrIds, options) :
                    removeOne(this, recordsOrIds, options);
            }
            return [];
        };
        Collection.prototype._createTransaction = function (a_elements, options) {
            if (options === void 0) { options = {}; }
            var elements = toElements(this, a_elements, options);
            if (this.models.length) {
                return options.remove === false ?
                    addTransaction(this, elements, options, true) :
                    setTransaction(this, elements, options);
            }
            else {
                return emptySetTransaction(this, elements, options);
            }
        };
        Collection.prototype.pluck = function (key) {
            return this.models.map(function (model) { return model[key]; });
        };
        Collection.prototype.sort = function (options) {
            if (options === void 0) { options = {}; }
            if (sortElements(this, options)) {
                var isRoot = begin$4(this);
                if (markAsDirty$5(this, options)) {
                    trigger2$5(this, 'sort', this, options);
                }
                isRoot && commit$5(this);
            }
            return this;
        };
        Collection.prototype.push = function (model, options) {
            return this.add(model, assign$6({ at: this.length }, options));
        };
        Collection.prototype.pop = function (options) {
            var model = this.at(this.length - 1);
            this.remove(model, __assign({ unset: true }, options));
            return model;
        };
        Collection.prototype.unset = function (modelOrId, options) {
            var value = this.get(modelOrId);
            this.remove(modelOrId, __assign({ unset: true }, options));
            return value;
        };
        Collection.prototype.unshift = function (model, options) {
            return this.add(model, assign$6({ at: 0 }, options));
        };
        Collection.prototype.shift = function (options) {
            var model = this.at(0);
            this.remove(model, __assign({ unset: true }, options));
            return model;
        };
        Collection.prototype.slice = function () {
            return slice.apply(this.models, arguments);
        };
        Collection.prototype.indexOf = function (modelOrId) {
            var record = this.get(modelOrId);
            return this.models.indexOf(record);
        };
        Collection.prototype.modelId = function (attrs) {
            return attrs[this.model.prototype.idAttribute];
        };
        Collection.prototype.toggle = function (model, a_next) {
            var prev = Boolean(this.get(model)), next = a_next === void 0 ? !prev : Boolean(a_next);
            if (prev !== next) {
                if (prev) {
                    this.remove(model);
                }
                else {
                    this.add(model);
                }
            }
            return next;
        };
        Collection.prototype._log = function (level, text, value) {
            log(level, "[Collection Update] " + this.model.prototype.getClassName() + "." + this.getClassName() + ": " + text, {
                Argument: value,
                'Attributes spec': this.model.prototype._attributes
            });
        };
        Collection.prototype.getClassName = function () {
            return _super.prototype.getClassName.call(this) || 'Collection';
        };
        var Collection_1;
        Collection._attribute = AggregatedType;
        Collection = Collection_1 = __decorate([
            define({
                cidPrefix: 'c',
                model: Record,
                _changeEventName: 'changes',
                _aggregationError: null
            }),
            definitions({
                comparator: mixinRules.value,
                model: mixinRules.protoValue,
                itemEvents: mixinRules.merge
            })
        ], Collection);
        return Collection;
    }(Transactional));
    function toElements(collection, elements, options) {
        var parsed = options.parse ? collection.parse(elements, options) : elements;
        return Array.isArray(parsed) ? parsed : [parsed];
    }
    createSharedTypeSpec(Collection, SharedType);
    Record.Collection = Collection;
    function bindContext(fun, context) {
        return context !== void 0 ? function (v, k) { return fun.call(context, v, k); } : fun;
    }
    function toPredicateFunction(iteratee, context) {
        if (typeof iteratee === 'object') {
            return function (x) {
                for (var key in iteratee) {
                    if (iteratee[key] !== x[key])
                        return false;
                }
                return true;
            };
        }
        return bindContext(iteratee, context);
    }

    function parseReference(collectionRef) {
        switch (typeof collectionRef) {
            case 'function':
                return function (root) { return collectionRef.call(root); };
            case 'object':
                return function () { return collectionRef; };
            case 'string':
                var resolve = new CompiledReference(collectionRef).resolve;
                return resolve;
        }
    }

    var RecordRefType = (function (_super) {
        __extends(RecordRefType, _super);
        function RecordRefType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RecordRefType.prototype.toJSON = function (value) {
            return value && typeof value === 'object' ? value.id : value;
        };
        RecordRefType.prototype.clone = function (value) {
            return value && typeof value === 'object' ? value.id : value;
        };
        RecordRefType.prototype.isChanged = function (a, b) {
            var aId = a && (a.id == null ? a : a.id), bId = b && (b.id == null ? b : b.id);
            return aId !== bId;
        };
        RecordRefType.prototype.validate = function (model, value, name) { };
        return RecordRefType;
    }(AnyType));
    Record.from = function from(masterCollection) {
        var getMasterCollection = parseReference(masterCollection);
        var typeSpec = new ChainableAttributeSpec({
            value: null,
            _attribute: RecordRefType
        });
        return typeSpec
            .get(function (objOrId, name) {
            if (typeof objOrId === 'object')
                return objOrId;
            var collection = getMasterCollection(this);
            var record = null;
            if (collection && collection.length) {
                record = collection.get(objOrId) || null;
                this.attributes[name] = record;
                record && this._attributes[name].handleChange(record, null, this, {});
            }
            return record;
        });
    };

    Collection.subsetOf = function subsetOf(masterCollection) {
        var SubsetOf = this._SubsetOf || (this._SubsetOf = defineSubsetCollection(this)), getMasterCollection = parseReference(masterCollection), typeSpec = new ChainableAttributeSpec({
            type: SubsetOf
        });
        return typeSpec.get(function (refs) {
            !refs || refs.resolvedWith || refs.resolve(getMasterCollection(this));
            return refs;
        });
    };
    var subsetOfBehavior = ItemsBehavior.share | ItemsBehavior.persistent;
    function defineSubsetCollection(CollectionConstructor) {
        var SubsetOfCollection = (function (_super) {
            __extends(SubsetOfCollection, _super);
            function SubsetOfCollection(recordsOrIds, options) {
                var _this = _super.call(this, [], options, subsetOfBehavior) || this;
                _this.resolvedWith = null;
                _this.refs = toArray(recordsOrIds);
                return _this;
            }
            Object.defineProperty(SubsetOfCollection.prototype, "__inner_state__", {
                get: function () { return this.refs || this.models; },
                enumerable: true,
                configurable: true
            });
            SubsetOfCollection.prototype.add = function (a_elements, options) {
                if (options === void 0) { options = {}; }
                var resolvedWith = this.resolvedWith, toAdd = toArray(a_elements);
                if (resolvedWith) {
                    return _super.prototype.add.call(this, resolveRefs(resolvedWith, toAdd), options);
                }
                else {
                    if (toAdd.length) {
                        var isRoot = transactionApi.begin(this);
                        this.refs = this.refs ? this.refs.concat(toAdd) : toAdd.slice();
                        transactionApi.markAsDirty(this, options);
                        isRoot && transactionApi.commit(this);
                    }
                }
            };
            SubsetOfCollection.prototype.reset = function (a_elements, options) {
                if (options === void 0) { options = {}; }
                var resolvedWith = this.resolvedWith, elements = toArray(a_elements);
                return resolvedWith ?
                    _super.prototype.reset.call(this, resolveRefs(resolvedWith, elements), options) :
                    delaySet(this, elements, options) || [];
            };
            SubsetOfCollection.prototype._createTransaction = function (a_elements, options) {
                var resolvedWith = this.resolvedWith, elements = toArray(a_elements);
                return resolvedWith ?
                    _super.prototype._createTransaction.call(this, resolveRefs(resolvedWith, elements), options) :
                    delaySet(this, elements, options);
            };
            SubsetOfCollection.prototype.toJSON = function () {
                return this.refs ?
                    this.refs.map(function (objOrId) { return objOrId.id || objOrId; }) :
                    this.models.map(function (model) { return model.id; });
            };
            SubsetOfCollection.prototype._validateNested = function () { return 0; };
            Object.defineProperty(SubsetOfCollection.prototype, "length", {
                get: function () {
                    return this.models.length || (this.refs ? this.refs.length : 0);
                },
                enumerable: true,
                configurable: true
            });
            SubsetOfCollection.prototype.clone = function (owner) {
                var Ctor = this.constructor, copy = new Ctor([], {
                    model: this.model,
                    comparator: this.comparator
                });
                if (this.resolvedWith) {
                    copy.resolvedWith = this.resolvedWith;
                    copy.refs = null;
                    copy.reset(this.models, { silent: true });
                }
                else {
                    copy.refs = this.refs.slice();
                }
                return copy;
            };
            SubsetOfCollection.prototype.parse = function (raw) {
                return raw;
            };
            SubsetOfCollection.prototype.resolve = function (collection) {
                if (collection && collection.length) {
                    this.resolvedWith = collection;
                    if (this.refs) {
                        this.reset(this.refs, { silent: true });
                        this.refs = null;
                    }
                }
                return this;
            };
            SubsetOfCollection.prototype.getModelIds = function () { return this.toJSON(); };
            SubsetOfCollection.prototype.toggle = function (modelOrId, val) {
                return _super.prototype.toggle.call(this, this.resolvedWith.get(modelOrId), val);
            };
            SubsetOfCollection.prototype.addAll = function () {
                if (this.resolvedWith) {
                    this.set(this.resolvedWith.models);
                    return this.models;
                }
                throw new Error("Cannot add elemens because the subset collection is not resolved yet.");
            };
            SubsetOfCollection.prototype.toggleAll = function () {
                return this.length ? this.reset() : this.addAll();
            };
            SubsetOfCollection = __decorate([
                define
            ], SubsetOfCollection);
            return SubsetOfCollection;
        }(CollectionConstructor));
        SubsetOfCollection.prototype._itemEvents = void 0;
        return SubsetOfCollection;
    }
    function resolveRefs(master, elements) {
        var records = [];
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var el = elements_1[_i];
            var record = master.get(el);
            if (record)
                records.push(record);
        }
        return records;
    }
    function delaySet(collection, elements, options) {
        if (notEqual(collection.refs, elements)) {
            var isRoot = transactionApi.begin(collection);
            collection.refs = elements.slice();
            transactionApi.markAsDirty(collection, options);
            isRoot && transactionApi.commit(collection);
        }
    }
    function toArray(elements) {
        return elements ? (Array.isArray(elements) ? elements : [elements]) : [];
    }

    var _store = null;
    var Store = (function (_super) {
        __extends(Store, _super);
        function Store() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Store.prototype.getStore = function () { return this; };
        Store.prototype.get = function (name) {
            var local = this[name];
            if (local || this === this._defaultStore)
                return local;
            return this._owner ? this._owner.get(name) : this._defaultStore.get(name);
        };
        Object.defineProperty(Store, "global", {
            get: function () { return _store; },
            set: function (store) {
                if (_store) {
                    _store.dispose();
                }
                Transactional.prototype._defaultStore = _store = store;
            },
            enumerable: true,
            configurable: true
        });
        return Store;
    }(Record));
    Store.global = new Store();

    var _a;
    Object.setPrototypeOf || (Object.setPrototypeOf = defaults);
    var on$6 = (_a = Events, _a.on), off$6 = _a.off, trigger = _a.trigger, once$3 = _a.once, listenTo = _a.listenTo, stopListening = _a.stopListening, listenToOnce = _a.listenToOnce;

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    /*!
     * assertion-error
     * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
     * MIT Licensed
     */

    /*!
     * Return a function that will copy properties from
     * one object to another excluding any originally
     * listed. Returned function will create a new `{}`.
     *
     * @param {String} excluded properties ...
     * @return {Function}
     */

    function exclude () {
      var excludes = [].slice.call(arguments);

      function excludeProps (res, obj) {
        Object.keys(obj).forEach(function (key) {
          if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
      }

      return function extendExclude () {
        var args = [].slice.call(arguments)
          , i = 0
          , res = {};

        for (; i < args.length; i++) {
          excludeProps(res, args[i]);
        }

        return res;
      };
    }
    /*!
     * Primary Exports
     */

    var assertionError = AssertionError;

    /**
     * ### AssertionError
     *
     * An extension of the JavaScript `Error` constructor for
     * assertion and validation scenarios.
     *
     * @param {String} message
     * @param {Object} properties to include (optional)
     * @param {callee} start stack function (optional)
     */

    function AssertionError (message, _props, ssf) {
      var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
        , props = extend(_props || {});

      // default values
      this.message = message || 'Unspecified AssertionError';
      this.showDiff = false;

      // copy from properties
      for (var key in props) {
        this[key] = props[key];
      }

      // capture stack trace
      ssf = ssf || arguments.callee;
      if (ssf && Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
      } else {
        try {
          throw new Error();
        } catch(e) {
          this.stack = e.stack;
        }
      }
    }

    /*!
     * Inherit from Error.prototype
     */

    AssertionError.prototype = Object.create(Error.prototype);

    /*!
     * Statically set name
     */

    AssertionError.prototype.name = 'AssertionError';

    /*!
     * Ensure correct constructor
     */

    AssertionError.prototype.constructor = AssertionError;

    /**
     * Allow errors to be converted to JSON for static transfer.
     *
     * @param {Boolean} include stack (default: `true`)
     * @return {Object} object that can be `JSON.stringify`
     */

    AssertionError.prototype.toJSON = function (stack) {
      var extend = exclude('constructor', 'toJSON', 'stack')
        , props = extend({ name: this.name }, this);

      // include stack if exists and not turned off
      if (false !== stack && this.stack) {
        props.stack = this.stack;
      }

      return props;
    };

    /* !
     * Chai - pathval utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * @see https://github.com/logicalparadox/filtr
     * MIT Licensed
     */

    /**
     * ### .hasProperty(object, name)
     *
     * This allows checking whether an object has own
     * or inherited from prototype chain named property.
     *
     * Basically does the same thing as the `in`
     * operator but works properly with null/undefined values
     * and other primitives.
     *
     *     var obj = {
     *         arr: ['a', 'b', 'c']
     *       , str: 'Hello'
     *     }
     *
     * The following would be the results.
     *
     *     hasProperty(obj, 'str');  // true
     *     hasProperty(obj, 'constructor');  // true
     *     hasProperty(obj, 'bar');  // false
     *
     *     hasProperty(obj.str, 'length'); // true
     *     hasProperty(obj.str, 1);  // true
     *     hasProperty(obj.str, 5);  // false
     *
     *     hasProperty(obj.arr, 'length');  // true
     *     hasProperty(obj.arr, 2);  // true
     *     hasProperty(obj.arr, 3);  // false
     *
     * @param {Object} object
     * @param {String|Symbol} name
     * @returns {Boolean} whether it exists
     * @namespace Utils
     * @name hasProperty
     * @api public
     */

    function hasProperty(obj, name) {
      if (typeof obj === 'undefined' || obj === null) {
        return false;
      }

      // The `in` operator does not work with primitives.
      return name in Object(obj);
    }

    /* !
     * ## parsePath(path)
     *
     * Helper function used to parse string object
     * paths. Use in conjunction with `internalGetPathValue`.
     *
     *      var parsed = parsePath('myobject.property.subprop');
     *
     * ### Paths:
     *
     * * Can be infinitely deep and nested.
     * * Arrays are also valid using the formal `myobject.document[3].property`.
     * * Literal dots and brackets (not delimiter) must be backslash-escaped.
     *
     * @param {String} path
     * @returns {Object} parsed
     * @api private
     */

    function parsePath(path$$1) {
      var str = path$$1.replace(/([^\\])\[/g, '$1.[');
      var parts = str.match(/(\\\.|[^.]+?)+/g);
      return parts.map(function mapMatches(value) {
        var regexp = /^\[(\d+)\]$/;
        var mArr = regexp.exec(value);
        var parsed = null;
        if (mArr) {
          parsed = { i: parseFloat(mArr[1]) };
        } else {
          parsed = { p: value.replace(/\\([.\[\]])/g, '$1') };
        }

        return parsed;
      });
    }

    /* !
     * ## internalGetPathValue(obj, parsed[, pathDepth])
     *
     * Helper companion function for `.parsePath` that returns
     * the value located at the parsed address.
     *
     *      var value = getPathValue(obj, parsed);
     *
     * @param {Object} object to search against
     * @param {Object} parsed definition from `parsePath`.
     * @param {Number} depth (nesting level) of the property we want to retrieve
     * @returns {Object|Undefined} value
     * @api private
     */

    function internalGetPathValue(obj, parsed, pathDepth) {
      var temporaryValue = obj;
      var res = null;
      pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);

      for (var i = 0; i < pathDepth; i++) {
        var part = parsed[i];
        if (temporaryValue) {
          if (typeof part.p === 'undefined') {
            temporaryValue = temporaryValue[part.i];
          } else {
            temporaryValue = temporaryValue[part.p];
          }

          if (i === (pathDepth - 1)) {
            res = temporaryValue;
          }
        }
      }

      return res;
    }

    /* !
     * ## internalSetPathValue(obj, value, parsed)
     *
     * Companion function for `parsePath` that sets
     * the value located at a parsed address.
     *
     *  internalSetPathValue(obj, 'value', parsed);
     *
     * @param {Object} object to search and define on
     * @param {*} value to use upon set
     * @param {Object} parsed definition from `parsePath`
     * @api private
     */

    function internalSetPathValue(obj, val, parsed) {
      var tempObj = obj;
      var pathDepth = parsed.length;
      var part = null;
      // Here we iterate through every part of the path
      for (var i = 0; i < pathDepth; i++) {
        var propName = null;
        var propVal = null;
        part = parsed[i];

        // If it's the last part of the path, we set the 'propName' value with the property name
        if (i === (pathDepth - 1)) {
          propName = typeof part.p === 'undefined' ? part.i : part.p;
          // Now we set the property with the name held by 'propName' on object with the desired val
          tempObj[propName] = val;
        } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
          tempObj = tempObj[part.p];
        } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
          tempObj = tempObj[part.i];
        } else {
          // If the obj doesn't have the property we create one with that name to define it
          var next = parsed[i + 1];
          // Here we set the name of the property which will be defined
          propName = typeof part.p === 'undefined' ? part.i : part.p;
          // Here we decide if this property will be an array or a new object
          propVal = typeof next.p === 'undefined' ? [] : {};
          tempObj[propName] = propVal;
          tempObj = tempObj[propName];
        }
      }
    }

    /**
     * ### .getPathInfo(object, path)
     *
     * This allows the retrieval of property info in an
     * object given a string path.
     *
     * The path info consists of an object with the
     * following properties:
     *
     * * parent - The parent object of the property referenced by `path`
     * * name - The name of the final property, a number if it was an array indexer
     * * value - The value of the property, if it exists, otherwise `undefined`
     * * exists - Whether the property exists or not
     *
     * @param {Object} object
     * @param {String} path
     * @returns {Object} info
     * @namespace Utils
     * @name getPathInfo
     * @api public
     */

    function getPathInfo(obj, path$$1) {
      var parsed = parsePath(path$$1);
      var last = parsed[parsed.length - 1];
      var info = {
        parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
        name: last.p || last.i,
        value: internalGetPathValue(obj, parsed),
      };
      info.exists = hasProperty(info.parent, info.name);

      return info;
    }

    /**
     * ### .getPathValue(object, path)
     *
     * This allows the retrieval of values in an
     * object given a string path.
     *
     *     var obj = {
     *         prop1: {
     *             arr: ['a', 'b', 'c']
     *           , str: 'Hello'
     *         }
     *       , prop2: {
     *             arr: [ { nested: 'Universe' } ]
     *           , str: 'Hello again!'
     *         }
     *     }
     *
     * The following would be the results.
     *
     *     getPathValue(obj, 'prop1.str'); // Hello
     *     getPathValue(obj, 'prop1.att[2]'); // b
     *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
     *
     * @param {Object} object
     * @param {String} path
     * @returns {Object} value or `undefined`
     * @namespace Utils
     * @name getPathValue
     * @api public
     */

    function getPathValue(obj, path$$1) {
      var info = getPathInfo(obj, path$$1);
      return info.value;
    }

    /**
     * ### .setPathValue(object, path, value)
     *
     * Define the value in an object at a given string path.
     *
     * ```js
     * var obj = {
     *     prop1: {
     *         arr: ['a', 'b', 'c']
     *       , str: 'Hello'
     *     }
     *   , prop2: {
     *         arr: [ { nested: 'Universe' } ]
     *       , str: 'Hello again!'
     *     }
     * };
     * ```
     *
     * The following would be acceptable.
     *
     * ```js
     * var properties = require('tea-properties');
     * properties.set(obj, 'prop1.str', 'Hello Universe!');
     * properties.set(obj, 'prop1.arr[2]', 'B');
     * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
     * ```
     *
     * @param {Object} object
     * @param {String} path
     * @param {Mixed} value
     * @api private
     */

    function setPathValue(obj, path$$1, val) {
      var parsed = parsePath(path$$1);
      internalSetPathValue(obj, val, parsed);
      return obj;
    }

    var pathval = {
      hasProperty: hasProperty,
      getPathInfo: getPathInfo,
      getPathValue: getPathValue,
      setPathValue: setPathValue,
    };

    /*!
     * Chai - flag utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .flag(object, key, [value])
     *
     * Get or set a flag value on an object. If a
     * value is provided it will be set, else it will
     * return the currently set value or `undefined` if
     * the value is not set.
     *
     *     utils.flag(this, 'foo', 'bar'); // setter
     *     utils.flag(this, 'foo'); // getter, returns `bar`
     *
     * @param {Object} object constructed Assertion
     * @param {String} key
     * @param {Mixed} value (optional)
     * @namespace Utils
     * @name flag
     * @api private
     */

    var flag = function flag(obj, key, value) {
      var flags = obj.__flags || (obj.__flags = Object.create(null));
      if (arguments.length === 3) {
        flags[key] = value;
      } else {
        return flags[key];
      }
    };

    /*!
     * Chai - test utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */



    /**
     * ### .test(object, expression)
     *
     * Test and object for expression.
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     * @namespace Utils
     * @name test
     */

    var test = function test(obj, args) {
      var negate = flag(obj, 'negate')
        , expr = args[0];
      return negate ? !expr : expr;
    };

    var typeDetect = createCommonjsModule(function (module) {

    /* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */
    var promiseExists = typeof Promise === 'function';
    var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line
    var isDom = 'location' in globalObject && 'document' in globalObject;
    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
    var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    /**
     * ### typeOf (obj)
     *
     * Uses `Object.prototype.toString` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */
    module.exports = function typeDetect(obj) {
      /* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
       */
      var typeofObj = typeof obj;
      if (typeofObj !== 'object') {
        return typeofObj;
      }

      /* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
       */
      if (obj === null) {
        return 'null';
      }

      /* ! Spec Conformance
       * Test: `Object.prototype.toString.call(window)``
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: `Object.prototype.toString.call(this)``
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */
      if (obj === globalObject) {
        return 'global';
      }

      /* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
       */
      if (
        Array.isArray(obj) &&
        (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
      ) {
        return 'Array';
      }

      if (isDom) {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The `Location` interface
         * Test: `Object.prototype.toString.call(window.location)``
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */
        if (obj === globalObject.location) {
          return 'Location';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The `Document` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: `Object.prototype.toString.call(document)``
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */
        if (obj === globalObject.document) {
          return 'Document';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
         *  - IE <=10 === "[object MSMimeTypesCollection]"
         */
        if (obj === (globalObject.navigator || {}).mimeTypes) {
          return 'MimeTypeArray';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
         * Test: `Object.prototype.toString.call(navigator.plugins)``
         *  - IE <=10 === "[object MSPluginsCollection]"
         */
        if (obj === (globalObject.navigator || {}).plugins) {
          return 'PluginArray';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
         * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
         *  - IE <=10 === "[object HTMLBlockElement]"
         */
        if (obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
          return 'HTMLQuoteElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltabledatacellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('td'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj instanceof HTMLElement && obj.tagName === 'TD') {
          return 'HTMLTableDataCellElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltableheadercellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('th'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj instanceof HTMLElement && obj.tagName === 'TH') {
          return 'HTMLTableHeaderCellElement';
        }
      }

      /* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
      */
      var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
      if (typeof stringTag === 'string') {
        return stringTag;
      }

      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
      */
      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }

      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
      */
      if (objPrototype === Date.prototype) {
        return 'Date';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */
      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }

      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
      */
      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }

      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
      */
      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }

      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
      */
      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }

      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
      */
      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */
      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */
      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */
      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */
      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }

      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */
      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }

      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
      */
      if (objPrototype === null) {
        return 'Object';
      }

      return Object
        .prototype
        .toString
        .call(obj)
        .slice(toStringLeftSliceLength, toStringRightSliceLength);
    };

    module.exports.typeDetect = module.exports;
    });
    var typeDetect_1 = typeDetect.typeDetect;

    /*!
     * Chai - expectTypes utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .expectTypes(obj, types)
     *
     * Ensures that the object being tested against is of a valid type.
     *
     *     utils.expectTypes(this, ['array', 'object', 'string']);
     *
     * @param {Mixed} obj constructed Assertion
     * @param {Array} type A list of allowed types for this assertion
     * @namespace Utils
     * @name expectTypes
     * @api public
     */





    var expectTypes = function expectTypes(obj, types) {
      var flagMsg = flag(obj, 'message');
      var ssfi = flag(obj, 'ssfi');

      flagMsg = flagMsg ? flagMsg + ': ' : '';

      obj = flag(obj, 'object');
      types = types.map(function (t) { return t.toLowerCase(); });
      types.sort();

      // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
      var str = types.map(function (t, index) {
        var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
        var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
        return or + art + ' ' + t;
      }).join(', ');

      var objType = typeDetect(obj).toLowerCase();

      if (!types.some(function (expected) { return objType === expected; })) {
        throw new assertionError(
          flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',
          undefined,
          ssfi
        );
      }
    };

    /*!
     * Chai - getActual utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getActual(object, [actual])
     *
     * Returns the `actual` value for an Assertion.
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     * @namespace Utils
     * @name getActual
     */

    var getActual = function getActual(obj, args) {
      return args.length > 4 ? args[4] : obj._obj;
    };

    /* !
     * Chai - getFuncName utility
     * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getFuncName(constructorFn)
     *
     * Returns the name of a function.
     * When a non-function instance is passed, returns `null`.
     * This also includes a polyfill function if `aFunc.name` is not defined.
     *
     * @name getFuncName
     * @param {Function} funct
     * @namespace Utils
     * @api public
     */

    var toString$1 = Function.prototype.toString;
    var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
    function getFuncName(aFunc) {
      if (typeof aFunc !== 'function') {
        return null;
      }

      var name = '';
      if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
        // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
        var match = toString$1.call(aFunc).match(functionNameMatch);
        if (match) {
          name = match[1];
        }
      } else {
        // If we've got a `name` property we just use it
        name = aFunc.name;
      }

      return name;
    }

    var getFuncName_1 = getFuncName;

    /*!
     * Chai - getProperties utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getProperties(object)
     *
     * This allows the retrieval of property names of an object, enumerable or not,
     * inherited or not.
     *
     * @param {Object} object
     * @returns {Array}
     * @namespace Utils
     * @name getProperties
     * @api public
     */

    var getProperties = function getProperties(object) {
      var result = Object.getOwnPropertyNames(object);

      function addProperty(property) {
        if (result.indexOf(property) === -1) {
          result.push(property);
        }
      }

      var proto = Object.getPrototypeOf(object);
      while (proto !== null) {
        Object.getOwnPropertyNames(proto).forEach(addProperty);
        proto = Object.getPrototypeOf(proto);
      }

      return result;
    };

    /*!
     * Chai - getEnumerableProperties utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getEnumerableProperties(object)
     *
     * This allows the retrieval of enumerable property names of an object,
     * inherited or not.
     *
     * @param {Object} object
     * @returns {Array}
     * @namespace Utils
     * @name getEnumerableProperties
     * @api public
     */

    var getEnumerableProperties = function getEnumerableProperties(object) {
      var result = [];
      for (var name in object) {
        result.push(name);
      }
      return result;
    };

    var config = {

      /**
       * ### config.includeStack
       *
       * User configurable property, influences whether stack trace
       * is included in Assertion error message. Default of false
       * suppresses stack trace in the error message.
       *
       *     chai.config.includeStack = true;  // enable stack on error
       *
       * @param {Boolean}
       * @api public
       */

      includeStack: false,

      /**
       * ### config.showDiff
       *
       * User configurable property, influences whether or not
       * the `showDiff` flag should be included in the thrown
       * AssertionErrors. `false` will always be `false`; `true`
       * will be true when the assertion has requested a diff
       * be shown.
       *
       * @param {Boolean}
       * @api public
       */

      showDiff: true,

      /**
       * ### config.truncateThreshold
       *
       * User configurable property, sets length threshold for actual and
       * expected values in assertion errors. If this threshold is exceeded, for
       * example for large data structures, the value is replaced with something
       * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
       *
       * Set it to zero if you want to disable truncating altogether.
       *
       * This is especially userful when doing assertions on arrays: having this
       * set to a reasonable large value makes the failure messages readily
       * inspectable.
       *
       *     chai.config.truncateThreshold = 0;  // disable truncating
       *
       * @param {Number}
       * @api public
       */

      truncateThreshold: 40,

      /**
       * ### config.useProxy
       *
       * User configurable property, defines if chai will use a Proxy to throw
       * an error when a non-existent property is read, which protects users
       * from typos when using property-based assertions.
       *
       * Set it to false if you want to disable this feature.
       *
       *     chai.config.useProxy = false;  // disable use of Proxy
       *
       * This feature is automatically disabled regardless of this config value
       * in environments that don't support proxies.
       *
       * @param {Boolean}
       * @api public
       */

      useProxy: true,

      /**
       * ### config.proxyExcludedKeys
       *
       * User configurable property, defines which properties should be ignored
       * instead of throwing an error if they do not exist on the assertion.
       * This is only applied if the environment Chai is running in supports proxies and
       * if the `useProxy` configuration setting is enabled.
       * By default, `then` and `inspect` will not throw an error if they do not exist on the
       * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
       * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
       *
       *     // By default these keys will not throw an error if they do not exist on the assertion object
       *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
       *
       * @param {Array}
       * @api public
       */

      proxyExcludedKeys: ['then', 'inspect', 'toJSON']
    };

    var inspect_1 = createCommonjsModule(function (module, exports) {
    // This is (almost) directly from Node.js utils
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js






    module.exports = inspect;

    /**
     * ### .inspect(obj, [showHidden], [depth], [colors])
     *
     * Echoes the value of a value. Tries to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
     *    properties of objects. Default is false.
     * @param {Number} depth Depth in which to descend in object. Default is 2.
     * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
     *    output. Default is false (no coloring).
     * @namespace Utils
     * @name inspect
     */
    function inspect(obj, showHidden, depth, colors) {
      var ctx = {
        showHidden: showHidden,
        seen: [],
        stylize: function (str) { return str; }
      };
      return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
    }

    // Returns true if object is a DOM element.
    var isDOMElement = function (object) {
      if (typeof HTMLElement === 'object') {
        return object instanceof HTMLElement;
      } else {
        return object &&
          typeof object === 'object' &&
          'nodeType' in object &&
          object.nodeType === 1 &&
          typeof object.nodeName === 'string';
      }
    };

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === 'function' &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (typeof ret !== 'string') {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // If this is a DOM element, try to get the outer HTML.
      if (isDOMElement(value)) {
        if ('outerHTML' in value) {
          return value.outerHTML;
          // This value does not have an outerHTML attribute,
          //   it could still be an XML element
        } else {
          // Attempt to serialize it
          try {
            if (document.xmlVersion) {
              var xmlSerializer = new XMLSerializer();
              return xmlSerializer.serializeToString(value);
            } else {
              // Firefox 11- do not support outerHTML
              //   It does, however, support innerHTML
              //   Use the following to render the element
              var ns = "http://www.w3.org/1999/xhtml";
              var container = document.createElementNS(ns, '_');

              container.appendChild(value.cloneNode(false));
              var html = container.innerHTML
                .replace('><', '>' + value.innerHTML + '<');
              container.innerHTML = '';
              return html;
            }
          } catch (err) {
            // This could be a non-native DOM implementation,
            //   continue with the normal flow:
            //   printing the element as if it is an object.
          }
        }
      }

      // Look up the keys of the object.
      var visibleKeys = getEnumerableProperties(value);
      var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

      var name, nameSuffix;

      // Some type of object without properties can be shortcutted.
      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
      // a `stack` plus `description` property; ignore those for consistency.
      if (keys.length === 0 || (isError(value) && (
          (keys.length === 1 && keys[0] === 'stack') ||
          (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
         ))) {
        if (typeof value === 'function') {
          name = getFuncName_1(value);
          nameSuffix = name ? ': ' + name : '';
          return ctx.stylize('[Function' + nameSuffix + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = ''
        , array = false
        , typedArray = false
        , braces = ['{', '}'];

      if (isTypedArray(value)) {
        typedArray = true;
        braces = ['[', ']'];
      }

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        base = ' [Function' + nameSuffix + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        return formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else if (typedArray) {
        return formatTypedArray(value);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      switch (typeof value) {
        case 'undefined':
          return ctx.stylize('undefined', 'undefined');

        case 'string':
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                   .replace(/'/g, "\\'")
                                                   .replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');

        case 'number':
          if (value === 0 && (1/value) === -Infinity) {
            return ctx.stylize('-0', 'number');
          }
          return ctx.stylize('' + value, 'number');

        case 'boolean':
          return ctx.stylize('' + value, 'boolean');

        case 'symbol':
          return ctx.stylize(value.toString(), 'symbol');
      }
      // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return ctx.stylize('null', 'null');
      }
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (Object.prototype.hasOwnProperty.call(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }

    function formatTypedArray(value) {
      var str = '[ ';

      for (var i = 0; i < value.length; ++i) {
        if (str.length >= config.truncateThreshold - 7) {
          str += '...';
          break;
        }
        str += value[i] + ', ';
      }
      str += ' ]';

      // Removing trailing `, ` if the array was not truncated
      if (str.indexOf(',  ]') !== -1) {
        str = str.replace(',  ]', ' ]');
      }

      return str;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name;
      var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
      var str;

      if (propDescriptor) {
        if (propDescriptor.get) {
          if (propDescriptor.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (propDescriptor.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
      }
      if (visibleKeys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, value[key], null);
          } else {
            str = formatValue(ctx, value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isTypedArray(ar) {
      // Unfortunately there's no way to check if an object is a TypedArray
      // We have to check if it's one of these types
      return (typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar)));
    }

    function isArray(ar) {
      return Array.isArray(ar) ||
             (typeof ar === 'object' && objectToString(ar) === '[object Array]');
    }

    function isRegExp(re) {
      return typeof re === 'object' && objectToString(re) === '[object RegExp]';
    }

    function isDate(d) {
      return typeof d === 'object' && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return typeof e === 'object' && objectToString(e) === '[object Error]';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    });

    /*!
     * Chai - flag utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */




    /**
     * ### .objDisplay(object)
     *
     * Determines if an object or an array matches
     * criteria to be inspected in-line for error
     * messages or should be truncated.
     *
     * @param {Mixed} javascript object to inspect
     * @name objDisplay
     * @namespace Utils
     * @api public
     */

    var objDisplay = function objDisplay(obj) {
      var str = inspect_1(obj)
        , type = Object.prototype.toString.call(obj);

      if (config.truncateThreshold && str.length >= config.truncateThreshold) {
        if (type === '[object Function]') {
          return !obj.name || obj.name === ''
            ? '[Function]'
            : '[Function: ' + obj.name + ']';
        } else if (type === '[object Array]') {
          return '[ Array(' + obj.length + ') ]';
        } else if (type === '[object Object]') {
          var keys = Object.keys(obj)
            , kstr = keys.length > 2
              ? keys.splice(0, 2).join(', ') + ', ...'
              : keys.join(', ');
          return '{ Object (' + kstr + ') }';
        } else {
          return str;
        }
      } else {
        return str;
      }
    };

    /*!
     * Chai - message composition utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */



    /**
     * ### .getMessage(object, message, negateMessage)
     *
     * Construct the error message based on flags
     * and template tags. Template tags will return
     * a stringified inspection of the object referenced.
     *
     * Message template tags:
     * - `#{this}` current asserted object
     * - `#{act}` actual value
     * - `#{exp}` expected value
     *
     * @param {Object} object (constructed Assertion)
     * @param {Arguments} chai.Assertion.prototype.assert arguments
     * @namespace Utils
     * @name getMessage
     * @api public
     */

    var getMessage = function getMessage(obj, args) {
      var negate = flag(obj, 'negate')
        , val = flag(obj, 'object')
        , expected = args[3]
        , actual = getActual(obj, args)
        , msg = negate ? args[2] : args[1]
        , flagMsg = flag(obj, 'message');

      if(typeof msg === "function") msg = msg();
      msg = msg || '';
      msg = msg
        .replace(/#\{this\}/g, function () { return objDisplay(val); })
        .replace(/#\{act\}/g, function () { return objDisplay(actual); })
        .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

      return flagMsg ? flagMsg + ': ' + msg : msg;
    };

    /*!
     * Chai - transferFlags utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .transferFlags(assertion, object, includeAll = true)
     *
     * Transfer all the flags for `assertion` to `object`. If
     * `includeAll` is set to `false`, then the base Chai
     * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
     * and `message`) will not be transferred.
     *
     *
     *     var newAssertion = new Assertion();
     *     utils.transferFlags(assertion, newAssertion);
     *
     *     var anotherAsseriton = new Assertion(myObj);
     *     utils.transferFlags(assertion, anotherAssertion, false);
     *
     * @param {Assertion} assertion the assertion to transfer the flags from
     * @param {Object} object the object to transfer the flags to; usually a new assertion
     * @param {Boolean} includeAll
     * @namespace Utils
     * @name transferFlags
     * @api private
     */

    var transferFlags = function transferFlags(assertion, object, includeAll) {
      var flags = assertion.__flags || (assertion.__flags = Object.create(null));

      if (!object.__flags) {
        object.__flags = Object.create(null);
      }

      includeAll = arguments.length === 3 ? includeAll : true;

      for (var flag in flags) {
        if (includeAll ||
            (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {
          object.__flags[flag] = flags[flag];
        }
      }
    };

    /* globals Symbol: false, Uint8Array: false, WeakMap: false */
    /*!
     * deep-eql
     * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */


    function FakeMap() {
      this._key = 'chai/deep-eql__' + Math.random() + Date.now();
    }

    FakeMap.prototype = {
      get: function getMap(key) {
        return key[this._key];
      },
      set: function setMap(key, value) {
        if (Object.isExtensible(key)) {
          Object.defineProperty(key, this._key, {
            value: value,
            configurable: true,
          });
        }
      },
    };

    var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
    /*!
     * Check to see if the MemoizeMap has recorded a result of the two operands
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @returns {Boolean|null} result
    */
    function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
      // Technically, WeakMap keys can *only* be objects, not primitives.
      if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        return null;
      }
      var leftHandMap = memoizeMap.get(leftHandOperand);
      if (leftHandMap) {
        var result = leftHandMap.get(rightHandOperand);
        if (typeof result === 'boolean') {
          return result;
        }
      }
      return null;
    }

    /*!
     * Set the result of the equality into the MemoizeMap
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @param {Boolean} result
    */
    function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
      // Technically, WeakMap keys can *only* be objects, not primitives.
      if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        return;
      }
      var leftHandMap = memoizeMap.get(leftHandOperand);
      if (leftHandMap) {
        leftHandMap.set(rightHandOperand, result);
      } else {
        leftHandMap = new MemoizeMap();
        leftHandMap.set(rightHandOperand, result);
        memoizeMap.set(leftHandOperand, leftHandMap);
      }
    }

    /*!
     * Primary Export
     */

    var deepEql = deepEqual;
    var MemoizeMap_1 = MemoizeMap;

    /**
     * Assert deeply nested sameValue equality between two objects of any type.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (optional) Additional options
     * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
     * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
        complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
        references to blow the stack.
     * @return {Boolean} equal match
     */
    function deepEqual(leftHandOperand, rightHandOperand, options) {
      // If we have a comparator, we can't assume anything; so bail to its check first.
      if (options && options.comparator) {
        return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
      }

      var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
      if (simpleResult !== null) {
        return simpleResult;
      }

      // Deeper comparisons are pushed through to a larger function
      return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
    }

    /**
     * Many comparisons can be canceled out early via simple equality or primitive checks.
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @return {Boolean|null} equal match
     */
    function simpleEqual(leftHandOperand, rightHandOperand) {
      // Equal references (except for Numbers) can be returned early
      if (leftHandOperand === rightHandOperand) {
        // Handle +-0 cases
        return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
      }

      // handle NaN cases
      if (
        leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
        rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
      ) {
        return true;
      }

      // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
      // strings, and undefined, can be compared by reference.
      if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        // Easy out b/c it would have passed the first equality check
        return false;
      }
      return null;
    }

    /*!
     * The main logic of the `deepEqual` function.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (optional) Additional options
     * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
     * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
        complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
        references to blow the stack.
     * @return {Boolean} equal match
    */
    function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
      options = options || {};
      options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
      var comparator = options && options.comparator;

      // Check if a memoized result exists.
      var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
      if (memoizeResultLeft !== null) {
        return memoizeResultLeft;
      }
      var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
      if (memoizeResultRight !== null) {
        return memoizeResultRight;
      }

      // If a comparator is present, use it.
      if (comparator) {
        var comparatorResult = comparator(leftHandOperand, rightHandOperand);
        // Comparators may return null, in which case we want to go back to default behavior.
        if (comparatorResult === false || comparatorResult === true) {
          memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
          return comparatorResult;
        }
        // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
        // what to do, we need to make sure to return the basic tests first before we move on.
        var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
        if (simpleResult !== null) {
          // Don't memoize this, it takes longer to set/retrieve than to just compare.
          return simpleResult;
        }
      }

      var leftHandType = typeDetect(leftHandOperand);
      if (leftHandType !== typeDetect(rightHandOperand)) {
        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
        return false;
      }

      // Temporarily set the operands in the memoize object to prevent blowing the stack
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);

      var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
      return result;
    }

    function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
      switch (leftHandType) {
        case 'String':
        case 'Number':
        case 'Boolean':
        case 'Date':
          // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
          return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
        case 'Promise':
        case 'Symbol':
        case 'function':
        case 'WeakMap':
        case 'WeakSet':
        case 'Error':
          return leftHandOperand === rightHandOperand;
        case 'Arguments':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'Array':
          return iterableEqual(leftHandOperand, rightHandOperand, options);
        case 'RegExp':
          return regexpEqual(leftHandOperand, rightHandOperand);
        case 'Generator':
          return generatorEqual(leftHandOperand, rightHandOperand, options);
        case 'DataView':
          return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
        case 'ArrayBuffer':
          return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
        case 'Set':
          return entriesEqual(leftHandOperand, rightHandOperand, options);
        case 'Map':
          return entriesEqual(leftHandOperand, rightHandOperand, options);
        default:
          return objectEqual(leftHandOperand, rightHandOperand, options);
      }
    }

    /*!
     * Compare two Regular Expressions for equality.
     *
     * @param {RegExp} leftHandOperand
     * @param {RegExp} rightHandOperand
     * @return {Boolean} result
     */

    function regexpEqual(leftHandOperand, rightHandOperand) {
      return leftHandOperand.toString() === rightHandOperand.toString();
    }

    /*!
     * Compare two Sets/Maps for equality. Faster than other equality functions.
     *
     * @param {Set} leftHandOperand
     * @param {Set} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     */

    function entriesEqual(leftHandOperand, rightHandOperand, options) {
      // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
      if (leftHandOperand.size !== rightHandOperand.size) {
        return false;
      }
      if (leftHandOperand.size === 0) {
        return true;
      }
      var leftHandItems = [];
      var rightHandItems = [];
      leftHandOperand.forEach(function gatherEntries(key, value) {
        leftHandItems.push([ key, value ]);
      });
      rightHandOperand.forEach(function gatherEntries(key, value) {
        rightHandItems.push([ key, value ]);
      });
      return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
    }

    /*!
     * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     */

    function iterableEqual(leftHandOperand, rightHandOperand, options) {
      var length = leftHandOperand.length;
      if (length !== rightHandOperand.length) {
        return false;
      }
      if (length === 0) {
        return true;
      }
      var index = -1;
      while (++index < length) {
        if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
          return false;
        }
      }
      return true;
    }

    /*!
     * Simple equality for generator objects such as those returned by generator functions.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     */

    function generatorEqual(leftHandOperand, rightHandOperand, options) {
      return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
    }

    /*!
     * Determine if the given object has an @@iterator function.
     *
     * @param {Object} target
     * @return {Boolean} `true` if the object has an @@iterator function.
     */
    function hasIteratorFunction(target) {
      return typeof Symbol !== 'undefined' &&
        typeof target === 'object' &&
        typeof Symbol.iterator !== 'undefined' &&
        typeof target[Symbol.iterator] === 'function';
    }

    /*!
     * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
     * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
     *
     * @param {Object} target
     * @returns {Array} an array of entries from the @@iterator function
     */
    function getIteratorEntries(target) {
      if (hasIteratorFunction(target)) {
        try {
          return getGeneratorEntries(target[Symbol.iterator]());
        } catch (iteratorError) {
          return [];
        }
      }
      return [];
    }

    /*!
     * Gets all entries from a Generator. This will consume the generator - which could have side effects.
     *
     * @param {Generator} target
     * @returns {Array} an array of entries from the Generator.
     */
    function getGeneratorEntries(generator) {
      var generatorResult = generator.next();
      var accumulator = [ generatorResult.value ];
      while (generatorResult.done === false) {
        generatorResult = generator.next();
        accumulator.push(generatorResult.value);
      }
      return accumulator;
    }

    /*!
     * Gets all own and inherited enumerable keys from a target.
     *
     * @param {Object} target
     * @returns {Array} an array of own and inherited enumerable keys from the target.
     */
    function getEnumerableKeys(target) {
      var keys = [];
      for (var key in target) {
        keys.push(key);
      }
      return keys;
    }

    /*!
     * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
     * each key. If any value of the given key is not equal, the function will return false (early).
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     */
    function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
      var length = keys.length;
      if (length === 0) {
        return true;
      }
      for (var i = 0; i < length; i += 1) {
        if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
          return false;
        }
      }
      return true;
    }

    /*!
     * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
     * for each enumerable key in the object.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     */

    function objectEqual(leftHandOperand, rightHandOperand, options) {
      var leftHandKeys = getEnumerableKeys(leftHandOperand);
      var rightHandKeys = getEnumerableKeys(rightHandOperand);
      if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
        leftHandKeys.sort();
        rightHandKeys.sort();
        if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
          return false;
        }
        return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
      }

      var leftHandEntries = getIteratorEntries(leftHandOperand);
      var rightHandEntries = getIteratorEntries(rightHandOperand);
      if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
        leftHandEntries.sort();
        rightHandEntries.sort();
        return iterableEqual(leftHandEntries, rightHandEntries, options);
      }

      if (leftHandKeys.length === 0 &&
          leftHandEntries.length === 0 &&
          rightHandKeys.length === 0 &&
          rightHandEntries.length === 0) {
        return true;
      }

      return false;
    }

    /*!
     * Returns true if the argument is a primitive.
     *
     * This intentionally returns true for all objects that can be compared by reference,
     * including functions and symbols.
     *
     * @param {Mixed} value
     * @return {Boolean} result
     */
    function isPrimitive(value) {
      return value === null || typeof value !== 'object';
    }
    deepEql.MemoizeMap = MemoizeMap_1;

    /*!
     * Chai - isProxyEnabled helper
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .isProxyEnabled()
     *
     * Helper function to check if Chai's proxy protection feature is enabled. If
     * proxies are unsupported or disabled via the user's Chai config, then return
     * false. Otherwise, return true.
     *
     * @namespace Utils
     * @name isProxyEnabled
     */

    var isProxyEnabled = function isProxyEnabled() {
      return config.useProxy && 
        typeof Proxy !== 'undefined' &&
        typeof Reflect !== 'undefined';
    };

    /*!
     * Chai - addProperty utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */






    /**
     * ### .addProperty(ctx, name, getter)
     *
     * Adds a property to the prototype of an object.
     *
     *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.instanceof(Foo);
     *     });
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addProperty('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.foo;
     *
     * @param {Object} ctx object to which the property is added
     * @param {String} name of property to add
     * @param {Function} getter function to be used for name
     * @namespace Utils
     * @name addProperty
     * @api public
     */

    var addProperty = function addProperty(ctx, name, getter) {
      getter = getter === undefined ? function () {} : getter;

      Object.defineProperty(ctx, name,
        { get: function propertyGetter() {
            // Setting the `ssfi` flag to `propertyGetter` causes this function to
            // be the starting point for removing implementation frames from the
            // stack trace of a failed assertion.
            //
            // However, we only want to use this function as the starting point if
            // the `lockSsfi` flag isn't set and proxy protection is disabled.
            //
            // If the `lockSsfi` flag is set, then either this assertion has been
            // overwritten by another assertion, or this assertion is being invoked
            // from inside of another assertion. In the first case, the `ssfi` flag
            // has already been set by the overwriting assertion. In the second
            // case, the `ssfi` flag has already been set by the outer assertion.
            //
            // If proxy protection is enabled, then the `ssfi` flag has already been
            // set by the proxy getter.
            if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
              flag(this, 'ssfi', propertyGetter);
            }

            var result = getter.call(this);
            if (result !== undefined)
              return result;

            var newAssertion = new chai.Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
          }
        , configurable: true
      });
    };

    var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');

    /*!
     * Chai - addLengthGuard utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .addLengthGuard(fn, assertionName, isChainable)
     *
     * Define `length` as a getter on the given uninvoked method assertion. The
     * getter acts as a guard against chaining `length` directly off of an uninvoked
     * method assertion, which is a problem because it references `function`'s
     * built-in `length` property instead of Chai's `length` assertion. When the
     * getter catches the user making this mistake, it throws an error with a
     * helpful message.
     *
     * There are two ways in which this mistake can be made. The first way is by
     * chaining the `length` assertion directly off of an uninvoked chainable
     * method. In this case, Chai suggests that the user use `lengthOf` instead. The
     * second way is by chaining the `length` assertion directly off of an uninvoked
     * non-chainable method. Non-chainable methods must be invoked prior to
     * chaining. In this case, Chai suggests that the user consult the docs for the
     * given assertion.
     *
     * If the `length` property of functions is unconfigurable, then return `fn`
     * without modification.
     *
     * Note that in ES6, the function's `length` property is configurable, so once
     * support for legacy environments is dropped, Chai's `length` property can
     * replace the built-in function's `length` property, and this length guard will
     * no longer be necessary. In the mean time, maintaining consistency across all
     * environments is the priority.
     *
     * @param {Function} fn
     * @param {String} assertionName
     * @param {Boolean} isChainable
     * @namespace Utils
     * @name addLengthGuard
     */

    var addLengthGuard = function addLengthGuard (fn, assertionName, isChainable) {
      if (!fnLengthDesc.configurable) return fn;

      Object.defineProperty(fn, 'length', {
        get: function () {
          if (isChainable) {
            throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +
              ' to a compatibility issue, "length" cannot directly follow "' +
              assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
          }

          throw Error('Invalid Chai property: ' + assertionName + '.length. See' +
            ' docs for proper usage of "' + assertionName + '".');
        }
      });

      return fn;
    };

    /*!
     * Chai - proxify utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .proxify(object)
     *
     * Return a proxy of given object that throws an error when a non-existent
     * property is read. By default, the root cause is assumed to be a misspelled
     * property, and thus an attempt is made to offer a reasonable suggestion from
     * the list of existing properties. However, if a nonChainableMethodName is
     * provided, then the root cause is instead a failure to invoke a non-chainable
     * method prior to reading the non-existent property.
     * 
     * If proxies are unsupported or disabled via the user's Chai config, then
     * return object without modification.
     *
     * @param {Object} obj
     * @param {String} nonChainableMethodName
     * @namespace Utils
     * @name proxify
     */

    var builtins = ['__flags', '__methods', '_obj', 'assert'];

    var proxify = function proxify(obj, nonChainableMethodName) {
      if (!isProxyEnabled()) return obj;

      return new Proxy(obj, {
        get: function proxyGetter(target, property) {
          // This check is here because we should not throw errors on Symbol properties
          // such as `Symbol.toStringTag`.
          // The values for which an error should be thrown can be configured using
          // the `config.proxyExcludedKeys` setting.
          if (typeof property === 'string' &&
              config.proxyExcludedKeys.indexOf(property) === -1 &&
              !Reflect.has(target, property)) {
            // Special message for invalid property access of non-chainable methods.
            if (nonChainableMethodName) {
              throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +
                property + '. See docs for proper usage of "' +
                nonChainableMethodName + '".');
            }

            var orderedProperties = getProperties(target).filter(function(property) {
              return !Object.prototype.hasOwnProperty(property) &&
                builtins.indexOf(property) === -1;
            }).sort(function(a, b) {
              return stringDistance(property, a) - stringDistance(property, b);
            });

            if (orderedProperties.length &&
                stringDistance(orderedProperties[0], property) < 4) {
              // If the property is reasonably close to an existing Chai property,
              // suggest that property to the user.
              throw Error('Invalid Chai property: ' + property +
                '. Did you mean "' + orderedProperties[0] + '"?');
            } else {
              throw Error('Invalid Chai property: ' + property);
            }
          }

          // Use this proxy getter as the starting point for removing implementation
          // frames from the stack trace of a failed assertion. For property
          // assertions, this prevents the proxy getter from showing up in the stack
          // trace since it's invoked before the property getter. For method and
          // chainable method assertions, this flag will end up getting changed to
          // the method wrapper, which is good since this frame will no longer be in
          // the stack once the method is invoked. Note that Chai builtin assertion
          // properties such as `__flags` are skipped since this is only meant to
          // capture the starting point of an assertion. This step is also skipped
          // if the `lockSsfi` flag is set, thus indicating that this assertion is
          // being called from within another assertion. In that case, the `ssfi`
          // flag is already set to the outer assertion's starting point.
          if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
            flag(target, 'ssfi', proxyGetter);
          }

          return Reflect.get(target, property);
        }
      });
    };

    /**
     * # stringDistance(strA, strB)
     * Return the Levenshtein distance between two strings.
     * @param {string} strA
     * @param {string} strB
     * @return {number} the string distance between strA and strB
     * @api private
     */

    function stringDistance(strA, strB, memo) {
      if (!memo) {
        // `memo` is a two-dimensional array containing a cache of distances
        // memo[i][j] is the distance between strA.slice(0, i) and
        // strB.slice(0, j).
        memo = [];
        for (var i = 0; i <= strA.length; i++) {
          memo[i] = [];
        }
      }

      if (!memo[strA.length] || !memo[strA.length][strB.length]) {
        if (strA.length === 0 || strB.length === 0) {
          memo[strA.length][strB.length] = Math.max(strA.length, strB.length);
        } else {
          memo[strA.length][strB.length] = Math.min(
            stringDistance(strA.slice(0, -1), strB, memo) + 1,
            stringDistance(strA, strB.slice(0, -1), memo) + 1,
            stringDistance(strA.slice(0, -1), strB.slice(0, -1), memo) +
              (strA.slice(-1) === strB.slice(-1) ? 0 : 1)
          );
        }
      }

      return memo[strA.length][strB.length];
    }

    /*!
     * Chai - addMethod utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */







    /**
     * ### .addMethod(ctx, name, method)
     *
     * Adds a method to the prototype of an object.
     *
     *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.equal(str);
     *     });
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addMethod('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(fooStr).to.be.foo('bar');
     *
     * @param {Object} ctx object to which the method is added
     * @param {String} name of method to add
     * @param {Function} method function to be used for name
     * @namespace Utils
     * @name addMethod
     * @api public
     */

    var addMethod = function addMethod(ctx, name, method) {
      var methodWrapper = function () {
        // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
        // starting point for removing implementation frames from the stack trace of
        // a failed assertion.
        //
        // However, we only want to use this function as the starting point if the
        // `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked from
        // inside of another assertion. In the first case, the `ssfi` flag has
        // already been set by the overwriting assertion. In the second case, the
        // `ssfi` flag has already been set by the outer assertion.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', methodWrapper);
        }

        var result = method.apply(this, arguments);
        if (result !== undefined)
          return result;

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(methodWrapper, name, false);
      ctx[name] = proxify(methodWrapper, name);
    };

    /*!
     * Chai - overwriteProperty utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */






    /**
     * ### .overwriteProperty(ctx, name, fn)
     *
     * Overwites an already existing property getter and provides
     * access to previous value. Must return function to use as getter.
     *
     *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
     *       return function () {
     *         var obj = utils.flag(this, 'object');
     *         if (obj instanceof Foo) {
     *           new chai.Assertion(obj.name).to.equal('bar');
     *         } else {
     *           _super.call(this);
     *         }
     *       }
     *     });
     *
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.overwriteProperty('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.be.ok;
     *
     * @param {Object} ctx object whose property is to be overwritten
     * @param {String} name of property to overwrite
     * @param {Function} getter function that returns a getter function to be used for name
     * @namespace Utils
     * @name overwriteProperty
     * @api public
     */

    var overwriteProperty = function overwriteProperty(ctx, name, getter) {
      var _get = Object.getOwnPropertyDescriptor(ctx, name)
        , _super = function () {};

      if (_get && 'function' === typeof _get.get)
        _super = _get.get;

      Object.defineProperty(ctx, name,
        { get: function overwritingPropertyGetter() {
            // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
            // function to be the starting point for removing implementation frames
            // from the stack trace of a failed assertion.
            //
            // However, we only want to use this function as the starting point if
            // the `lockSsfi` flag isn't set and proxy protection is disabled.
            //
            // If the `lockSsfi` flag is set, then either this assertion has been
            // overwritten by another assertion, or this assertion is being invoked
            // from inside of another assertion. In the first case, the `ssfi` flag
            // has already been set by the overwriting assertion. In the second
            // case, the `ssfi` flag has already been set by the outer assertion.
            //
            // If proxy protection is enabled, then the `ssfi` flag has already been
            // set by the proxy getter.
            if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
              flag(this, 'ssfi', overwritingPropertyGetter);
            }

            // Setting the `lockSsfi` flag to `true` prevents the overwritten
            // assertion from changing the `ssfi` flag. By this point, the `ssfi`
            // flag is already set to the correct starting point for this assertion.
            var origLockSsfi = flag(this, 'lockSsfi');
            flag(this, 'lockSsfi', true);
            var result = getter(_super).call(this);
            flag(this, 'lockSsfi', origLockSsfi);

            if (result !== undefined) {
              return result;
            }

            var newAssertion = new chai.Assertion();
            transferFlags(this, newAssertion);
            return newAssertion;
          }
        , configurable: true
      });
    };

    /*!
     * Chai - overwriteMethod utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */







    /**
     * ### .overwriteMethod(ctx, name, fn)
     *
     * Overwites an already existing method and provides
     * access to previous function. Must return function
     * to be used for name.
     *
     *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
     *       return function (str) {
     *         var obj = utils.flag(this, 'object');
     *         if (obj instanceof Foo) {
     *           new chai.Assertion(obj.value).to.equal(str);
     *         } else {
     *           _super.apply(this, arguments);
     *         }
     *       }
     *     });
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.overwriteMethod('foo', fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.equal('bar');
     *
     * @param {Object} ctx object whose method is to be overwritten
     * @param {String} name of method to overwrite
     * @param {Function} method function that returns a function to be used for name
     * @namespace Utils
     * @name overwriteMethod
     * @api public
     */

    var overwriteMethod = function overwriteMethod(ctx, name, method) {
      var _method = ctx[name]
        , _super = function () {
          throw new Error(name + ' is not a function');
        };

      if (_method && 'function' === typeof _method)
        _super = _method;

      var overwritingMethodWrapper = function () {
        // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
        // function to be the starting point for removing implementation frames from
        // the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if the
        // `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked from
        // inside of another assertion. In the first case, the `ssfi` flag has
        // already been set by the overwriting assertion. In the second case, the
        // `ssfi` flag has already been set by the outer assertion.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', overwritingMethodWrapper);
        }

        // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
        // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
        // set to the correct starting point for this assertion.
        var origLockSsfi = flag(this, 'lockSsfi');
        flag(this, 'lockSsfi', true);
        var result = method(_super).apply(this, arguments);
        flag(this, 'lockSsfi', origLockSsfi);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(overwritingMethodWrapper, name, false);
      ctx[name] = proxify(overwritingMethodWrapper, name);
    };

    /*!
     * Chai - addChainingMethod utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependencies
     */







    /*!
     * Module variables
     */

    // Check whether `Object.setPrototypeOf` is supported
    var canSetPrototype = typeof Object.setPrototypeOf === 'function';

    // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
    // However, some of functions' own props are not configurable and should be skipped.
    var testFn = function() {};
    var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
      var propDesc = Object.getOwnPropertyDescriptor(testFn, name);

      // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
      // but then returns `undefined` as the property descriptor for `callee`. As a
      // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
      // and then filter it out if it's not an object as it should be.
      if (typeof propDesc !== 'object')
        return true;

      return !propDesc.configurable;
    });

    // Cache `Function` properties
    var call  = Function.prototype.call,
        apply = Function.prototype.apply;

    /**
     * ### .addChainableMethod(ctx, name, method, chainingBehavior)
     *
     * Adds a method to an object, such that the method can also be chained.
     *
     *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
     *       var obj = utils.flag(this, 'object');
     *       new chai.Assertion(obj).to.be.equal(str);
     *     });
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
     *
     * The result can then be used as both a method assertion, executing both `method` and
     * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
     *
     *     expect(fooStr).to.be.foo('bar');
     *     expect(fooStr).to.be.foo.equal('foo');
     *
     * @param {Object} ctx object to which the method is added
     * @param {String} name of method to add
     * @param {Function} method function to be used for `name`, when called
     * @param {Function} chainingBehavior function to be called every time the property is accessed
     * @namespace Utils
     * @name addChainableMethod
     * @api public
     */

    var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
      if (typeof chainingBehavior !== 'function') {
        chainingBehavior = function () { };
      }

      var chainableBehavior = {
          method: method
        , chainingBehavior: chainingBehavior
      };

      // save the methods so we can overwrite them later, if we need to.
      if (!ctx.__methods) {
        ctx.__methods = {};
      }
      ctx.__methods[name] = chainableBehavior;

      Object.defineProperty(ctx, name,
        { get: function chainableMethodGetter() {
            chainableBehavior.chainingBehavior.call(this);

            var chainableMethodWrapper = function () {
              // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
              // function to be the starting point for removing implementation
              // frames from the stack trace of a failed assertion.
              //
              // However, we only want to use this function as the starting point if
              // the `lockSsfi` flag isn't set.
              //
              // If the `lockSsfi` flag is set, then this assertion is being
              // invoked from inside of another assertion. In this case, the `ssfi`
              // flag has already been set by the outer assertion.
              //
              // Note that overwriting a chainable method merely replaces the saved
              // methods in `ctx.__methods` instead of completely replacing the
              // overwritten assertion. Therefore, an overwriting assertion won't
              // set the `ssfi` or `lockSsfi` flags.
              if (!flag(this, 'lockSsfi')) {
                flag(this, 'ssfi', chainableMethodWrapper);
              }

              var result = chainableBehavior.method.apply(this, arguments);
              if (result !== undefined) {
                return result;
              }

              var newAssertion = new chai.Assertion();
              transferFlags(this, newAssertion);
              return newAssertion;
            };

            addLengthGuard(chainableMethodWrapper, name, true);

            // Use `Object.setPrototypeOf` if available
            if (canSetPrototype) {
              // Inherit all properties from the object by replacing the `Function` prototype
              var prototype = Object.create(this);
              // Restore the `call` and `apply` methods from `Function`
              prototype.call = call;
              prototype.apply = apply;
              Object.setPrototypeOf(chainableMethodWrapper, prototype);
            }
            // Otherwise, redefine all properties (slow!)
            else {
              var asserterNames = Object.getOwnPropertyNames(ctx);
              asserterNames.forEach(function (asserterName) {
                if (excludeNames.indexOf(asserterName) !== -1) {
                  return;
                }

                var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                Object.defineProperty(chainableMethodWrapper, asserterName, pd);
              });
            }

            transferFlags(this, chainableMethodWrapper);
            return proxify(chainableMethodWrapper);
          }
        , configurable: true
      });
    };

    /*!
     * Chai - overwriteChainableMethod utility
     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */




    /**
     * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
     *
     * Overwites an already existing chainable method
     * and provides access to the previous function or
     * property.  Must return functions to be used for
     * name.
     *
     *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
     *       function (_super) {
     *       }
     *     , function (_super) {
     *       }
     *     );
     *
     * Can also be accessed directly from `chai.Assertion`.
     *
     *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
     *
     * Then can be used as any other assertion.
     *
     *     expect(myFoo).to.have.lengthOf(3);
     *     expect(myFoo).to.have.lengthOf.above(3);
     *
     * @param {Object} ctx object whose method / property is to be overwritten
     * @param {String} name of method / property to overwrite
     * @param {Function} method function that returns a function to be used for name
     * @param {Function} chainingBehavior function that returns a function to be used for property
     * @namespace Utils
     * @name overwriteChainableMethod
     * @api public
     */

    var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
      var chainableBehavior = ctx.__methods[name];

      var _chainingBehavior = chainableBehavior.chainingBehavior;
      chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
        var result = chainingBehavior(_chainingBehavior).call(this);
        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      var _method = chainableBehavior.method;
      chainableBehavior.method = function overwritingChainableMethodWrapper() {
        var result = method(_method).apply(this, arguments);
        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };
    };

    /*!
     * Chai - compareByInspect utility
     * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */



    /**
     * ### .compareByInspect(mixed, mixed)
     *
     * To be used as a compareFunction with Array.prototype.sort. Compares elements
     * using inspect instead of default behavior of using toString so that Symbols
     * and objects with irregular/missing toString can still be sorted without a
     * TypeError.
     *
     * @param {Mixed} first element to compare
     * @param {Mixed} second element to compare
     * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1 
     * @name compareByInspect
     * @namespace Utils
     * @api public
     */

    var compareByInspect = function compareByInspect(a, b) {
      return inspect_1(a) < inspect_1(b) ? -1 : 1;
    };

    /*!
     * Chai - getOwnEnumerablePropertySymbols utility
     * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .getOwnEnumerablePropertySymbols(object)
     *
     * This allows the retrieval of directly-owned enumerable property symbols of an
     * object. This function is necessary because Object.getOwnPropertySymbols
     * returns both enumerable and non-enumerable property symbols.
     *
     * @param {Object} object
     * @returns {Array}
     * @namespace Utils
     * @name getOwnEnumerablePropertySymbols
     * @api public
     */

    var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
      if (typeof Object.getOwnPropertySymbols !== 'function') return [];

      return Object.getOwnPropertySymbols(obj).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
      });
    };

    /*!
     * Chai - getOwnEnumerableProperties utility
     * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Module dependancies
     */



    /**
     * ### .getOwnEnumerableProperties(object)
     *
     * This allows the retrieval of directly-owned enumerable property names and
     * symbols of an object. This function is necessary because Object.keys only
     * returns enumerable property names, not enumerable property symbols.
     *
     * @param {Object} object
     * @returns {Array}
     * @namespace Utils
     * @name getOwnEnumerableProperties
     * @api public
     */

    var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
      return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
    };

    /* !
     * Chai - checkError utility
     * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /**
     * ### .checkError
     *
     * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
     *
     * @api public
     */

    /**
     * ### .compatibleInstance(thrown, errorLike)
     *
     * Checks if two instances are compatible (strict equal).
     * Returns false if errorLike is not an instance of Error, because instances
     * can only be compatible if they're both error instances.
     *
     * @name compatibleInstance
     * @param {Error} thrown error
     * @param {Error|ErrorConstructor} errorLike object to compare against
     * @namespace Utils
     * @api public
     */

    function compatibleInstance(thrown, errorLike) {
      return errorLike instanceof Error && thrown === errorLike;
    }

    /**
     * ### .compatibleConstructor(thrown, errorLike)
     *
     * Checks if two constructors are compatible.
     * This function can receive either an error constructor or
     * an error instance as the `errorLike` argument.
     * Constructors are compatible if they're the same or if one is
     * an instance of another.
     *
     * @name compatibleConstructor
     * @param {Error} thrown error
     * @param {Error|ErrorConstructor} errorLike object to compare against
     * @namespace Utils
     * @api public
     */

    function compatibleConstructor(thrown, errorLike) {
      if (errorLike instanceof Error) {
        // If `errorLike` is an instance of any error we compare their constructors
        return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
      } else if (errorLike.prototype instanceof Error || errorLike === Error) {
        // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
        return thrown.constructor === errorLike || thrown instanceof errorLike;
      }

      return false;
    }

    /**
     * ### .compatibleMessage(thrown, errMatcher)
     *
     * Checks if an error's message is compatible with a matcher (String or RegExp).
     * If the message contains the String or passes the RegExp test,
     * it is considered compatible.
     *
     * @name compatibleMessage
     * @param {Error} thrown error
     * @param {String|RegExp} errMatcher to look for into the message
     * @namespace Utils
     * @api public
     */

    function compatibleMessage(thrown, errMatcher) {
      var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
      if (errMatcher instanceof RegExp) {
        return errMatcher.test(comparisonString);
      } else if (typeof errMatcher === 'string') {
        return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
      }

      return false;
    }

    /**
     * ### .getFunctionName(constructorFn)
     *
     * Returns the name of a function.
     * This also includes a polyfill function if `constructorFn.name` is not defined.
     *
     * @name getFunctionName
     * @param {Function} constructorFn
     * @namespace Utils
     * @api private
     */

    var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
    function getFunctionName(constructorFn) {
      var name = '';
      if (typeof constructorFn.name === 'undefined') {
        // Here we run a polyfill if constructorFn.name is not defined
        var match = String(constructorFn).match(functionNameMatch$1);
        if (match) {
          name = match[1];
        }
      } else {
        name = constructorFn.name;
      }

      return name;
    }

    /**
     * ### .getConstructorName(errorLike)
     *
     * Gets the constructor name for an Error instance or constructor itself.
     *
     * @name getConstructorName
     * @param {Error|ErrorConstructor} errorLike
     * @namespace Utils
     * @api public
     */

    function getConstructorName(errorLike) {
      var constructorName = errorLike;
      if (errorLike instanceof Error) {
        constructorName = getFunctionName(errorLike.constructor);
      } else if (typeof errorLike === 'function') {
        // If `err` is not an instance of Error it is an error constructor itself or another function.
        // If we've got a common function we get its name, otherwise we may need to create a new instance
        // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
        constructorName = getFunctionName(errorLike).trim() ||
            getFunctionName(new errorLike()); // eslint-disable-line new-cap
      }

      return constructorName;
    }

    /**
     * ### .getMessage(errorLike)
     *
     * Gets the error message from an error.
     * If `err` is a String itself, we return it.
     * If the error has no message, we return an empty string.
     *
     * @name getMessage
     * @param {Error|String} errorLike
     * @namespace Utils
     * @api public
     */

    function getMessage$1(errorLike) {
      var msg = '';
      if (errorLike && errorLike.message) {
        msg = errorLike.message;
      } else if (typeof errorLike === 'string') {
        msg = errorLike;
      }

      return msg;
    }

    var checkError = {
      compatibleInstance: compatibleInstance,
      compatibleConstructor: compatibleConstructor,
      compatibleMessage: compatibleMessage,
      getMessage: getMessage$1,
      getConstructorName: getConstructorName,
    };

    /*!
     * Chai - isNaN utility
     * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
     * MIT Licensed
     */

    /**
     * ### .isNaN(value)
     *
     * Checks if the given value is NaN or not.
     *
     *     utils.isNaN(NaN); // true
     *
     * @param {Value} The value which has to be checked if it is NaN
     * @name isNaN
     * @api private
     */

    function isNaN$1(value) {
      // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
      // section's NOTE.
      return value !== value;
    }

    // If ECMAScript 6's Number.isNaN is present, prefer that.
    var _isNaN = Number.isNaN || isNaN$1;

    /*!
     * chai
     * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    /*!
     * Dependencies that are used for multiple exports are required here only once
     */



    /*!
     * test utility
     */

    var test$1 = test;

    /*!
     * type utility
     */

    var type$1 = typeDetect;

    /*!
     * expectTypes utility
     */
    var expectTypes$1 = expectTypes;

    /*!
     * message utility
     */

    var getMessage$2 = getMessage;

    /*!
     * actual utility
     */

    var getActual$1 = getActual;

    /*!
     * Inspect util
     */

    var inspect = inspect_1;

    /*!
     * Object Display util
     */

    var objDisplay$1 = objDisplay;

    /*!
     * Flag utility
     */

    var flag$1 = flag;

    /*!
     * Flag transferring utility
     */

    var transferFlags$1 = transferFlags;

    /*!
     * Deep equal utility
     */

    var eql = deepEql;

    /*!
     * Deep path info
     */

    var getPathInfo$1 = pathval.getPathInfo;

    /*!
     * Check if a property exists
     */

    var hasProperty$1 = pathval.hasProperty;

    /*!
     * Function name
     */

    var getName = getFuncName_1;

    /*!
     * add Property
     */

    var addProperty$1 = addProperty;

    /*!
     * add Method
     */

    var addMethod$1 = addMethod;

    /*!
     * overwrite Property
     */

    var overwriteProperty$1 = overwriteProperty;

    /*!
     * overwrite Method
     */

    var overwriteMethod$1 = overwriteMethod;

    /*!
     * Add a chainable method
     */

    var addChainableMethod$1 = addChainableMethod;

    /*!
     * Overwrite chainable method
     */

    var overwriteChainableMethod$1 = overwriteChainableMethod;

    /*!
     * Compare by inspect method
     */

    var compareByInspect$1 = compareByInspect;

    /*!
     * Get own enumerable property symbols method
     */

    var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;

    /*!
     * Get own enumerable properties method
     */

    var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;

    /*!
     * Checks error against a given set of criteria
     */

    var checkError$1 = checkError;

    /*!
     * Proxify util
     */

    var proxify$1 = proxify;

    /*!
     * addLengthGuard util
     */

    var addLengthGuard$1 = addLengthGuard;

    /*!
     * isProxyEnabled helper
     */

    var isProxyEnabled$1 = isProxyEnabled;

    /*!
     * isNaN method
     */

    var isNaN$2 = _isNaN;

    var utils = {
    	test: test$1,
    	type: type$1,
    	expectTypes: expectTypes$1,
    	getMessage: getMessage$2,
    	getActual: getActual$1,
    	inspect: inspect,
    	objDisplay: objDisplay$1,
    	flag: flag$1,
    	transferFlags: transferFlags$1,
    	eql: eql,
    	getPathInfo: getPathInfo$1,
    	hasProperty: hasProperty$1,
    	getName: getName,
    	addProperty: addProperty$1,
    	addMethod: addMethod$1,
    	overwriteProperty: overwriteProperty$1,
    	overwriteMethod: overwriteMethod$1,
    	addChainableMethod: addChainableMethod$1,
    	overwriteChainableMethod: overwriteChainableMethod$1,
    	compareByInspect: compareByInspect$1,
    	getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
    	getOwnEnumerableProperties: getOwnEnumerableProperties$1,
    	checkError: checkError$1,
    	proxify: proxify$1,
    	addLengthGuard: addLengthGuard$1,
    	isProxyEnabled: isProxyEnabled$1,
    	isNaN: isNaN$2
    };

    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */



    var assertion = function (_chai, util$$1) {
      /*!
       * Module dependencies.
       */

      var AssertionError = _chai.AssertionError
        , flag = util$$1.flag;

      /*!
       * Module export.
       */

      _chai.Assertion = Assertion;

      /*!
       * Assertion Constructor
       *
       * Creates object for chaining.
       *
       * `Assertion` objects contain metadata in the form of flags. Three flags can
       * be assigned during instantiation by passing arguments to this constructor:
       *
       * - `object`: This flag contains the target of the assertion. For example, in
       *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
       *   contain `numKittens` so that the `equal` assertion can reference it when
       *   needed.
       *
       * - `message`: This flag contains an optional custom error message to be
       *   prepended to the error message that's generated by the assertion when it
       *   fails.
       *
       * - `ssfi`: This flag stands for "start stack function indicator". It
       *   contains a function reference that serves as the starting point for
       *   removing frames from the stack trace of the error that's created by the
       *   assertion when it fails. The goal is to provide a cleaner stack trace to
       *   end users by removing Chai's internal functions. Note that it only works
       *   in environments that support `Error.captureStackTrace`, and only when
       *   `Chai.config.includeStack` hasn't been set to `false`.
       *
       * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
       *   should retain its current value, even as assertions are chained off of
       *   this object. This is usually set to `true` when creating a new assertion
       *   from within another assertion. It's also temporarily set to `true` before
       *   an overwritten assertion gets called by the overwriting assertion.
       *
       * @param {Mixed} obj target of the assertion
       * @param {String} msg (optional) custom error message
       * @param {Function} ssfi (optional) starting point for removing stack frames
       * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
       * @api private
       */

      function Assertion (obj, msg, ssfi, lockSsfi) {
        flag(this, 'ssfi', ssfi || Assertion);
        flag(this, 'lockSsfi', lockSsfi);
        flag(this, 'object', obj);
        flag(this, 'message', msg);

        return util$$1.proxify(this);
      }

      Object.defineProperty(Assertion, 'includeStack', {
        get: function() {
          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
          return config.includeStack;
        },
        set: function(value) {
          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
          config.includeStack = value;
        }
      });

      Object.defineProperty(Assertion, 'showDiff', {
        get: function() {
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
          return config.showDiff;
        },
        set: function(value) {
          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
          config.showDiff = value;
        }
      });

      Assertion.addProperty = function (name, fn) {
        util$$1.addProperty(this.prototype, name, fn);
      };

      Assertion.addMethod = function (name, fn) {
        util$$1.addMethod(this.prototype, name, fn);
      };

      Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
        util$$1.addChainableMethod(this.prototype, name, fn, chainingBehavior);
      };

      Assertion.overwriteProperty = function (name, fn) {
        util$$1.overwriteProperty(this.prototype, name, fn);
      };

      Assertion.overwriteMethod = function (name, fn) {
        util$$1.overwriteMethod(this.prototype, name, fn);
      };

      Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
        util$$1.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
      };

      /**
       * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
       *
       * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
       *
       * @name assert
       * @param {Philosophical} expression to be tested
       * @param {String|Function} message or function that returns message to display if expression fails
       * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
       * @param {Mixed} expected value (remember to check for negation)
       * @param {Mixed} actual (optional) will default to `this.obj`
       * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
       * @api private
       */

      Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
        var ok = util$$1.test(this, arguments);
        if (false !== showDiff) showDiff = true;
        if (undefined === expected && undefined === _actual) showDiff = false;
        if (true !== config.showDiff) showDiff = false;

        if (!ok) {
          msg = util$$1.getMessage(this, arguments);
          var actual = util$$1.getActual(this, arguments);
          throw new AssertionError(msg, {
              actual: actual
            , expected: expected
            , showDiff: showDiff
          }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
        }
      };

      /*!
       * ### ._obj
       *
       * Quick reference to stored `actual` value for plugin developers.
       *
       * @api private
       */

      Object.defineProperty(Assertion.prototype, '_obj',
        { get: function () {
            return flag(this, 'object');
          }
        , set: function (val) {
            flag(this, 'object', val);
          }
      });
    };

    /*!
     * chai
     * http://chaijs.com
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var assertions = function (chai, _) {
      var Assertion = chai.Assertion
        , AssertionError = chai.AssertionError
        , flag = _.flag;

      /**
       * ### Language Chains
       *
       * The following are provided as chainable getters to improve the readability
       * of your assertions.
       *
       * **Chains**
       *
       * - to
       * - be
       * - been
       * - is
       * - that
       * - which
       * - and
       * - has
       * - have
       * - with
       * - at
       * - of
       * - same
       * - but
       * - does
       *
       * @name language chains
       * @namespace BDD
       * @api public
       */

      [ 'to', 'be', 'been'
      , 'is', 'and', 'has', 'have'
      , 'with', 'that', 'which', 'at'
      , 'of', 'same', 'but', 'does' ].forEach(function (chain) {
        Assertion.addProperty(chain);
      });

      /**
       * ### .not
       *
       * Negates all assertions that follow in the chain.
       *
       *     expect(function () {}).to.not.throw();
       *     expect({a: 1}).to.not.have.property('b');
       *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
       *
       * Just because you can negate any assertion with `.not` doesn't mean you
       * should. With great power comes great responsibility. It's often best to
       * assert that the one expected output was produced, rather than asserting
       * that one of countless unexpected outputs wasn't produced. See individual
       * assertions for specific guidance.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.not.equal(1); // Not recommended
       *
       * @name not
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('not', function () {
        flag(this, 'negate', true);
      });

      /**
       * ### .deep
       *
       * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
       * assertions that follow in the chain to use deep equality instead of strict
       * (`===`) equality. See the `deep-eql` project page for info on the deep
       * equality algorithm: https://github.com/chaijs/deep-eql.
       *
       *     // Target object deeply (but not strictly) equals `{a: 1}`
       *     expect({a: 1}).to.deep.equal({a: 1});
       *     expect({a: 1}).to.not.equal({a: 1});
       *
       *     // Target array deeply (but not strictly) includes `{a: 1}`
       *     expect([{a: 1}]).to.deep.include({a: 1});
       *     expect([{a: 1}]).to.not.include({a: 1});
       *
       *     // Target object deeply (but not strictly) includes `x: {a: 1}`
       *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
       *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
       *
       *     // Target array deeply (but not strictly) has member `{a: 1}`
       *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
       *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
       *
       *     // Target set deeply (but not strictly) has key `{a: 1}`
       *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
       *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
       *
       *     // Target object deeply (but not strictly) has property `x: {a: 1}`
       *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
       *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
       *
       * @name deep
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('deep', function () {
        flag(this, 'deep', true);
      });

      /**
       * ### .nested
       *
       * Enables dot- and bracket-notation in all `.property` and `.include`
       * assertions that follow in the chain.
       *
       *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
       *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
       *
       * If `.` or `[]` are part of an actual property name, they can be escaped by
       * adding two backslashes before them.
       *
       *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
       *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
       *
       * `.nested` cannot be combined with `.own`.
       *
       * @name nested
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('nested', function () {
        flag(this, 'nested', true);
      });

      /**
       * ### .own
       *
       * Causes all `.property` and `.include` assertions that follow in the chain
       * to ignore inherited properties.
       *
       *     Object.prototype.b = 2;
       *
       *     expect({a: 1}).to.have.own.property('a');
       *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
       *
       *     expect({a: 1}).to.own.include({a: 1});
       *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
       *
       * `.own` cannot be combined with `.nested`.
       *
       * @name own
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('own', function () {
        flag(this, 'own', true);
      });

      /**
       * ### .ordered
       *
       * Causes all `.members` assertions that follow in the chain to require that
       * members be in the same order.
       *
       *     expect([1, 2]).to.have.ordered.members([1, 2])
       *       .but.not.have.ordered.members([2, 1]);
       *
       * When `.include` and `.ordered` are combined, the ordering begins at the
       * start of both arrays.
       *
       *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
       *       .but.not.include.ordered.members([2, 3]);
       *
       * @name ordered
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('ordered', function () {
        flag(this, 'ordered', true);
      });

      /**
       * ### .any
       *
       * Causes all `.keys` assertions that follow in the chain to only require that
       * the target have at least one of the given keys. This is the opposite of
       * `.all`, which requires that the target have all of the given keys.
       *
       *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
       *
       * See the `.keys` doc for guidance on when to use `.any` or `.all`.
       *
       * @name any
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('any', function () {
        flag(this, 'any', true);
        flag(this, 'all', false);
      });


      /**
       * ### .all
       *
       * Causes all `.keys` assertions that follow in the chain to require that the
       * target have all of the given keys. This is the opposite of `.any`, which
       * only requires that the target have at least one of the given keys.
       *
       *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
       *
       * Note that `.all` is used by default when neither `.all` nor `.any` are
       * added earlier in the chain. However, it's often best to add `.all` anyway
       * because it improves readability.
       *
       * See the `.keys` doc for guidance on when to use `.any` or `.all`.
       *
       * @name all
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('all', function () {
        flag(this, 'all', true);
        flag(this, 'any', false);
      });

      /**
       * ### .a(type[, msg])
       *
       * Asserts that the target's type is equal to the given string `type`. Types
       * are case insensitive. See the `type-detect` project page for info on the
       * type detection algorithm: https://github.com/chaijs/type-detect.
       *
       *     expect('foo').to.be.a('string');
       *     expect({a: 1}).to.be.an('object');
       *     expect(null).to.be.a('null');
       *     expect(undefined).to.be.an('undefined');
       *     expect(new Error).to.be.an('error');
       *     expect(Promise.resolve()).to.be.a('promise');
       *     expect(new Float32Array).to.be.a('float32array');
       *     expect(Symbol()).to.be.a('symbol');
       *
       * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
       *
       *     var myObj = {
       *       [Symbol.toStringTag]: 'myCustomType'
       *     };
       *
       *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
       *
       * It's often best to use `.a` to check a target's type before making more
       * assertions on the same target. That way, you avoid unexpected behavior from
       * any assertion that does different things based on the target's type.
       *
       *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
       *     expect([]).to.be.an('array').that.is.empty;
       *
       * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
       * assert that the target is the expected type, rather than asserting that it
       * isn't one of many unexpected types.
       *
       *     expect('foo').to.be.a('string'); // Recommended
       *     expect('foo').to.not.be.an('array'); // Not recommended
       *
       * `.a` accepts an optional `msg` argument which is a custom error message to
       * show when the assertion fails. The message can also be given as the second
       * argument to `expect`.
       *
       *     expect(1).to.be.a('string', 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.be.a('string');
       *
       * `.a` can also be used as a language chain to improve the readability of
       * your assertions. 
       *
       *     expect({b: 2}).to.have.a.property('b');
       *
       * The alias `.an` can be used interchangeably with `.a`.
       *
       * @name a
       * @alias an
       * @param {String} type
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function an (type, msg) {
        if (msg) flag(this, 'message', msg);
        type = type.toLowerCase();
        var obj = flag(this, 'object')
          , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

        this.assert(
            type === _.type(obj).toLowerCase()
          , 'expected #{this} to be ' + article + type
          , 'expected #{this} not to be ' + article + type
        );
      }

      Assertion.addChainableMethod('an', an);
      Assertion.addChainableMethod('a', an);

      /**
       * ### .include(val[, msg])
       *
       * When the target is a string, `.include` asserts that the given string `val`
       * is a substring of the target.
       *
       *     expect('foobar').to.include('foo');
       *
       * When the target is an array, `.include` asserts that the given `val` is a
       * member of the target.
       *
       *     expect([1, 2, 3]).to.include(2);
       *
       * When the target is an object, `.include` asserts that the given object
       * `val`'s properties are a subset of the target's properties.
       *
       *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
       *
       * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
       * member of the target. SameValueZero equality algorithm is used.
       *
       *     expect(new Set([1, 2])).to.include(2);
       *
       * When the target is a Map, `.include` asserts that the given `val` is one of
       * the values of the target. SameValueZero equality algorithm is used.
       *
       *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
       *
       * Because `.include` does different things based on the target's type, it's
       * important to check the target's type before using `.include`. See the `.a`
       * doc for info on testing a target's type.
       *
       *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
       *
       * By default, strict (`===`) equality is used to compare array members and
       * object properties. Add `.deep` earlier in the chain to use deep equality
       * instead (WeakSet targets are not supported). See the `deep-eql` project
       * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
       *
       *     // Target array deeply (but not strictly) includes `{a: 1}`
       *     expect([{a: 1}]).to.deep.include({a: 1});
       *     expect([{a: 1}]).to.not.include({a: 1});
       *
       *     // Target object deeply (but not strictly) includes `x: {a: 1}`
       *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
       *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
       *
       * By default, all of the target's properties are searched when working with
       * objects. This includes properties that are inherited and/or non-enumerable.
       * Add `.own` earlier in the chain to exclude the target's inherited
       * properties from the search.
       *
       *     Object.prototype.b = 2;
       *
       *     expect({a: 1}).to.own.include({a: 1});
       *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
       *
       * Note that a target object is always only searched for `val`'s own
       * enumerable properties.
       *
       * `.deep` and `.own` can be combined.
       *
       *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
       *
       * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
       * referencing nested properties.
       *
       *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
       *
       * If `.` or `[]` are part of an actual property name, they can be escaped by
       * adding two backslashes before them.
       *
       *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
       *
       * `.deep` and `.nested` can be combined.
       *
       *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
       *
       * `.own` and `.nested` cannot be combined.
       *
       * Add `.not` earlier in the chain to negate `.include`.
       *
       *     expect('foobar').to.not.include('taco');
       *     expect([1, 2, 3]).to.not.include(4);
       * 
       * However, it's dangerous to negate `.include` when the target is an object.
       * The problem is that it creates uncertain expectations by asserting that the
       * target object doesn't have all of `val`'s key/value pairs but may or may
       * not have some of them. It's often best to identify the exact output that's
       * expected, and then write an assertion that only accepts that exact output.
       *
       * When the target object isn't even expected to have `val`'s keys, it's
       * often best to assert exactly that.
       *
       *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
       *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
       *
       * When the target object is expected to have `val`'s keys, it's often best to
       * assert that each of the properties has its expected value, rather than
       * asserting that each property doesn't have one of many unexpected values.
       *
       *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
       *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
       *
       * `.include` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
       *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
       *
       * `.include` can also be used as a language chain, causing all `.members` and
       * `.keys` assertions that follow in the chain to require the target to be a
       * superset of the expected set, rather than an identical set. Note that
       * `.members` ignores duplicates in the subset when `.include` is added.
       *
       *     // Target object's keys are a superset of ['a', 'b'] but not identical
       *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
       *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
       *
       *     // Target array is a superset of [1, 2] but not identical
       *     expect([1, 2, 3]).to.include.members([1, 2]);
       *     expect([1, 2, 3]).to.not.have.members([1, 2]);
       *
       *     // Duplicates in the subset are ignored
       *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
       *
       * Note that adding `.any` earlier in the chain causes the `.keys` assertion
       * to ignore `.include`.
       *
       *     // Both assertions are identical
       *     expect({a: 1}).to.include.any.keys('a', 'b');
       *     expect({a: 1}).to.have.any.keys('a', 'b');
       *
       * The aliases `.includes`, `.contain`, and `.contains` can be used
       * interchangeably with `.include`.
       *
       * @name include
       * @alias contain
       * @alias includes
       * @alias contains
       * @param {Mixed} val
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function SameValueZero(a, b) {
        return (_.isNaN(a) && _.isNaN(b)) || a === b;
      }

      function includeChainingBehavior () {
        flag(this, 'contains', true);
      }

      function include (val, msg) {
        if (msg) flag(this, 'message', msg);
        
        var obj = flag(this, 'object')
          , objType = _.type(obj).toLowerCase()
          , flagMsg = flag(this, 'message')
          , negate = flag(this, 'negate')
          , ssfi = flag(this, 'ssfi')
          , isDeep = flag(this, 'deep')
          , descriptor = isDeep ? 'deep ' : '';

        flagMsg = flagMsg ? flagMsg + ': ' : '';

        var included = false;

        switch (objType) {
          case 'string':
            included = obj.indexOf(val) !== -1;
            break;

          case 'weakset':
            if (isDeep) {
              throw new AssertionError(
                flagMsg + 'unable to use .deep.include with WeakSet',
                undefined,
                ssfi
              );
            }

            included = obj.has(val);
            break;

          case 'map':
            var isEql = isDeep ? _.eql : SameValueZero;
            obj.forEach(function (item) {
              included = included || isEql(item, val);
            });
            break;

          case 'set':
            if (isDeep) {
              obj.forEach(function (item) {
                included = included || _.eql(item, val);
              });
            } else {
              included = obj.has(val);
            }
            break;

          case 'array':
            if (isDeep) {
              included = obj.some(function (item) {
                return _.eql(item, val);
              });
            } else {
              included = obj.indexOf(val) !== -1;
            }
            break;

          default:
            // This block is for asserting a subset of properties in an object.
            // `_.expectTypes` isn't used here because `.include` should work with
            // objects with a custom `@@toStringTag`.
            if (val !== Object(val)) {
              throw new AssertionError(
                flagMsg + 'object tested must be an array, a map, an object,'
                  + ' a set, a string, or a weakset, but ' + objType + ' given',
                undefined,
                ssfi
              );
            }

            var props = Object.keys(val)
              , firstErr = null
              , numErrs = 0;
      
            props.forEach(function (prop) {
              var propAssertion = new Assertion(obj);
              _.transferFlags(this, propAssertion, true);
              flag(propAssertion, 'lockSsfi', true);
      
              if (!negate || props.length === 1) {
                propAssertion.property(prop, val[prop]);
                return;
              }
      
              try {
                propAssertion.property(prop, val[prop]);
              } catch (err) {
                if (!_.checkError.compatibleConstructor(err, AssertionError)) {
                  throw err;
                }
                if (firstErr === null) firstErr = err;
                numErrs++;
              }
            }, this);
      
            // When validating .not.include with multiple properties, we only want
            // to throw an assertion error if all of the properties are included,
            // in which case we throw the first property assertion error that we
            // encountered.
            if (negate && props.length > 1 && numErrs === props.length) {
              throw firstErr;
            }
            return;
        }

        // Assert inclusion in collection or substring in a string.
        this.assert(
          included
          , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)
          , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
      }

      Assertion.addChainableMethod('include', include, includeChainingBehavior);
      Assertion.addChainableMethod('contain', include, includeChainingBehavior);
      Assertion.addChainableMethod('contains', include, includeChainingBehavior);
      Assertion.addChainableMethod('includes', include, includeChainingBehavior);

      /**
       * ### .ok
       *
       * Asserts that the target is loosely (`==`) equal to `true`. However, it's
       * often best to assert that the target is strictly (`===`) or deeply equal to
       * its expected value.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.be.ok; // Not recommended
       *
       *     expect(true).to.be.true; // Recommended
       *     expect(true).to.be.ok; // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.ok`.
       *
       *     expect(0).to.equal(0); // Recommended
       *     expect(0).to.not.be.ok; // Not recommended
       *
       *     expect(false).to.be.false; // Recommended
       *     expect(false).to.not.be.ok; // Not recommended
       *
       *     expect(null).to.be.null; // Recommended
       *     expect(null).to.not.be.ok; // Not recommended
       *
       *     expect(undefined).to.be.undefined; // Recommended
       *     expect(undefined).to.not.be.ok; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(false, 'nooo why fail??').to.be.ok;
       *
       * @name ok
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('ok', function () {
        this.assert(
            flag(this, 'object')
          , 'expected #{this} to be truthy'
          , 'expected #{this} to be falsy');
      });

      /**
       * ### .true
       *
       * Asserts that the target is strictly (`===`) equal to `true`.
       *
       *     expect(true).to.be.true;
       *
       * Add `.not` earlier in the chain to negate `.true`. However, it's often best
       * to assert that the target is equal to its expected value, rather than not
       * equal to `true`.
       *
       *     expect(false).to.be.false; // Recommended
       *     expect(false).to.not.be.true; // Not recommended
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.true; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(false, 'nooo why fail??').to.be.true;
       *
       * @name true
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('true', function () {
        this.assert(
            true === flag(this, 'object')
          , 'expected #{this} to be true'
          , 'expected #{this} to be false'
          , flag(this, 'negate') ? false : true
        );
      });

      /**
       * ### .false
       *
       * Asserts that the target is strictly (`===`) equal to `false`.
       *
       *     expect(false).to.be.false;
       *
       * Add `.not` earlier in the chain to negate `.false`. However, it's often
       * best to assert that the target is equal to its expected value, rather than
       * not equal to `false`.
       *
       *     expect(true).to.be.true; // Recommended
       *     expect(true).to.not.be.false; // Not recommended
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.false; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(true, 'nooo why fail??').to.be.false;
       *
       * @name false
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('false', function () {
        this.assert(
            false === flag(this, 'object')
          , 'expected #{this} to be false'
          , 'expected #{this} to be true'
          , flag(this, 'negate') ? true : false
        );
      });

      /**
       * ### .null
       *
       * Asserts that the target is strictly (`===`) equal to `null`.
       *
       *     expect(null).to.be.null;
       *
       * Add `.not` earlier in the chain to negate `.null`. However, it's often best
       * to assert that the target is equal to its expected value, rather than not
       * equal to `null`.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.null; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(42, 'nooo why fail??').to.be.null;
       *
       * @name null
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('null', function () {
        this.assert(
            null === flag(this, 'object')
          , 'expected #{this} to be null'
          , 'expected #{this} not to be null'
        );
      });

      /**
       * ### .undefined
       *
       * Asserts that the target is strictly (`===`) equal to `undefined`.
       *
       *     expect(undefined).to.be.undefined;
       *
       * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
       * best to assert that the target is equal to its expected value, rather than
       * not equal to `undefined`.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.undefined; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(42, 'nooo why fail??').to.be.undefined;
       *
       * @name undefined
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('undefined', function () {
        this.assert(
            undefined === flag(this, 'object')
          , 'expected #{this} to be undefined'
          , 'expected #{this} not to be undefined'
        );
      });

      /**
       * ### .NaN
       *
       * Asserts that the target is exactly `NaN`.
       *
       *     expect(NaN).to.be.NaN;
       *
       * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
       * to assert that the target is equal to its expected value, rather than not
       * equal to `NaN`.
       *
       *     expect('foo').to.equal('foo'); // Recommended
       *     expect('foo').to.not.be.NaN; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(42, 'nooo why fail??').to.be.NaN;
       *
       * @name NaN
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('NaN', function () {
        this.assert(
            _.isNaN(flag(this, 'object'))
            , 'expected #{this} to be NaN'
            , 'expected #{this} not to be NaN'
        );
      });

      /**
       * ### .exist
       *
       * Asserts that the target is not strictly (`===`) equal to either `null` or
       * `undefined`. However, it's often best to assert that the target is equal to
       * its expected value.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.exist; // Not recommended
       *
       *     expect(0).to.equal(0); // Recommended
       *     expect(0).to.exist; // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.exist`.
       *
       *     expect(null).to.be.null; // Recommended
       *     expect(null).to.not.exist; // Not recommended
       *
       *     expect(undefined).to.be.undefined; // Recommended
       *     expect(undefined).to.not.exist; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(null, 'nooo why fail??').to.exist;
       *
       * @name exist
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('exist', function () {
        var val = flag(this, 'object');
        this.assert(
            val !== null && val !== undefined
          , 'expected #{this} to exist'
          , 'expected #{this} to not exist'
        );
      });

      /**
       * ### .empty
       *
       * When the target is a string or array, `.empty` asserts that the target's
       * `length` property is strictly (`===`) equal to `0`.
       *
       *     expect([]).to.be.empty;
       *     expect('').to.be.empty;
       *
       * When the target is a map or set, `.empty` asserts that the target's `size`
       * property is strictly equal to `0`.
       *
       *     expect(new Set()).to.be.empty;
       *     expect(new Map()).to.be.empty;
       *
       * When the target is a non-function object, `.empty` asserts that the target
       * doesn't have any own enumerable properties. Properties with Symbol-based
       * keys are excluded from the count.
       *
       *     expect({}).to.be.empty;
       *
       * Because `.empty` does different things based on the target's type, it's
       * important to check the target's type before using `.empty`. See the `.a`
       * doc for info on testing a target's type.
       *
       *     expect([]).to.be.an('array').that.is.empty;
       *
       * Add `.not` earlier in the chain to negate `.empty`. However, it's often
       * best to assert that the target contains its expected number of values,
       * rather than asserting that it's not empty.
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
       *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
       *
       *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
       *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
       *
       *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
       *     expect({a: 1}).to.not.be.empty; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
       *
       * @name empty
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('empty', function () {
        var val = flag(this, 'object')
          , ssfi = flag(this, 'ssfi')
          , flagMsg = flag(this, 'message')
          , itemsCount;

        flagMsg = flagMsg ? flagMsg + ': ' : '';

        switch (_.type(val).toLowerCase()) {
          case 'array':
          case 'string':
            itemsCount = val.length;
            break;
          case 'map':
          case 'set':
            itemsCount = val.size;
            break;
          case 'weakmap':
          case 'weakset':
            throw new AssertionError(
              flagMsg + '.empty was passed a weak collection',
              undefined,
              ssfi
            );
          case 'function':
            var msg = flagMsg + '.empty was passed a function ' + _.getName(val);
            throw new AssertionError(msg.trim(), undefined, ssfi);
          default:
            if (val !== Object(val)) {
              throw new AssertionError(
                flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),
                undefined,
                ssfi
              );
            }
            itemsCount = Object.keys(val).length;
        }

        this.assert(
            0 === itemsCount
          , 'expected #{this} to be empty'
          , 'expected #{this} not to be empty'
        );
      });

      /**
       * ### .arguments
       *
       * Asserts that the target is an `arguments` object.
       *
       *     function test () {
       *       expect(arguments).to.be.arguments;
       *     }
       *
       *     test();
       *
       * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
       * best to assert which type the target is expected to be, rather than
       * asserting that its not an `arguments` object.
       *
       *     expect('foo').to.be.a('string'); // Recommended
       *     expect('foo').to.not.be.arguments; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect({}, 'nooo why fail??').to.be.arguments;
       *
       * The alias `.Arguments` can be used interchangeably with `.arguments`.
       *
       * @name arguments
       * @alias Arguments
       * @namespace BDD
       * @api public
       */

      function checkArguments () {
        var obj = flag(this, 'object')
          , type = _.type(obj);
        this.assert(
            'Arguments' === type
          , 'expected #{this} to be arguments but got ' + type
          , 'expected #{this} to not be arguments'
        );
      }

      Assertion.addProperty('arguments', checkArguments);
      Assertion.addProperty('Arguments', checkArguments);

      /**
       * ### .equal(val[, msg])
       *
       * Asserts that the target is strictly (`===`) equal to the given `val`.
       *
       *     expect(1).to.equal(1);
       *     expect('foo').to.equal('foo');
       * 
       * Add `.deep` earlier in the chain to use deep equality instead. See the
       * `deep-eql` project page for info on the deep equality algorithm:
       * https://github.com/chaijs/deep-eql.
       *
       *     // Target object deeply (but not strictly) equals `{a: 1}`
       *     expect({a: 1}).to.deep.equal({a: 1});
       *     expect({a: 1}).to.not.equal({a: 1});
       *
       *     // Target array deeply (but not strictly) equals `[1, 2]`
       *     expect([1, 2]).to.deep.equal([1, 2]);
       *     expect([1, 2]).to.not.equal([1, 2]);
       *
       * Add `.not` earlier in the chain to negate `.equal`. However, it's often
       * best to assert that the target is equal to its expected value, rather than
       * not equal to one of countless unexpected values.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.equal(2); // Not recommended
       *
       * `.equal` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(1).to.equal(2, 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.equal(2);
       *
       * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
       *
       * @name equal
       * @alias equals
       * @alias eq
       * @param {Mixed} val
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertEqual (val, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        if (flag(this, 'deep')) {
          return this.eql(val);
        } else {
          this.assert(
              val === obj
            , 'expected #{this} to equal #{exp}'
            , 'expected #{this} to not equal #{exp}'
            , val
            , this._obj
            , true
          );
        }
      }

      Assertion.addMethod('equal', assertEqual);
      Assertion.addMethod('equals', assertEqual);
      Assertion.addMethod('eq', assertEqual);

      /**
       * ### .eql(obj[, msg])
       *
       * Asserts that the target is deeply equal to the given `obj`. See the
       * `deep-eql` project page for info on the deep equality algorithm:
       * https://github.com/chaijs/deep-eql.
       *
       *     // Target object is deeply (but not strictly) equal to {a: 1}
       *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
       *
       *     // Target array is deeply (but not strictly) equal to [1, 2]
       *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
       *
       * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
       * to assert that the target is deeply equal to its expected value, rather
       * than not deeply equal to one of countless unexpected values.
       *
       *     expect({a: 1}).to.eql({a: 1}); // Recommended
       *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
       *
       * `.eql` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
       *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
       *
       * The alias `.eqls` can be used interchangeably with `.eql`.
       *
       * The `.deep.equal` assertion is almost identical to `.eql` but with one
       * difference: `.deep.equal` causes deep equality comparisons to also be used
       * for any other assertions that follow in the chain.
       *
       * @name eql
       * @alias eqls
       * @param {Mixed} obj
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertEql(obj, msg) {
        if (msg) flag(this, 'message', msg);
        this.assert(
            _.eql(obj, flag(this, 'object'))
          , 'expected #{this} to deeply equal #{exp}'
          , 'expected #{this} to not deeply equal #{exp}'
          , obj
          , this._obj
          , true
        );
      }

      Assertion.addMethod('eql', assertEql);
      Assertion.addMethod('eqls', assertEql);

      /**
       * ### .above(n[, msg])
       *
       * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
       * However, it's often best to assert that the target is equal to its expected
       * value.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.be.above(1); // Not recommended
       *
       * Add `.lengthOf` earlier in the chain to assert that the value of the
       * target's `length` property is greater than the given number `n`.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.have.lengthOf.above(2); // Not recommended
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.above`.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(1).to.not.be.above(2); // Not recommended
       *
       * `.above` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(1).to.be.above(2, 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.be.above(2);
       *
       * The aliases `.gt` and `.greaterThan` can be used interchangeably with
       * `.above`.
       *
       * @name above
       * @alias gt
       * @alias greaterThan
       * @param {Number} n
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertAbove (n, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , doLength = flag(this, 'doLength')
          , flagMsg = flag(this, 'message')
          , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
          , ssfi = flag(this, 'ssfi')
          , objType = _.type(obj).toLowerCase()
          , nType = _.type(n).toLowerCase()
          , shouldThrow = true;

        if (doLength) {
          new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        }
        
        if (!doLength && (objType === 'date' && nType !== 'date')) {
          errorMessage = msgPrefix + 'the argument to above must be a date';
        } else if (nType !== 'number' && (doLength || objType === 'number')) {
          errorMessage = msgPrefix + 'the argument to above must be a number';
        } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
          var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
        } else {
          shouldThrow = false;
        }

        if (shouldThrow) {
          throw new AssertionError(errorMessage, undefined, ssfi);
        }

        if (doLength) {
          var len = obj.length;
          this.assert(
              len > n
            , 'expected #{this} to have a length above #{exp} but got #{act}'
            , 'expected #{this} to not have a length above #{exp}'
            , n
            , len
          );
        } else {
          this.assert(
              obj > n
            , 'expected #{this} to be above #{exp}'
            , 'expected #{this} to be at most #{exp}'
            , n
          );
        }
      }

      Assertion.addMethod('above', assertAbove);
      Assertion.addMethod('gt', assertAbove);
      Assertion.addMethod('greaterThan', assertAbove);

      /**
       * ### .least(n[, msg])
       *
       * Asserts that the target is a number or a date greater than or equal to the given
       * number or date `n` respectively. However, it's often best to assert that the target is equal to
       * its expected value.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.be.at.least(1); // Not recommended
       *     expect(2).to.be.at.least(2); // Not recommended
       *
       * Add `.lengthOf` earlier in the chain to assert that the value of the
       * target's `length` property is greater than or equal to the given number
       * `n`.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.least`.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.at.least(2); // Not recommended
       *
       * `.least` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(1).to.be.at.least(2, 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.be.at.least(2);
       *
       * The alias `.gte` can be used interchangeably with `.least`.
       *
       * @name least
       * @alias gte
       * @param {Number} n
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertLeast (n, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , doLength = flag(this, 'doLength')
          , flagMsg = flag(this, 'message')
          , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
          , ssfi = flag(this, 'ssfi')
          , objType = _.type(obj).toLowerCase()
          , nType = _.type(n).toLowerCase()
          , shouldThrow = true;

        if (doLength) {
          new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        }

        if (!doLength && (objType === 'date' && nType !== 'date')) {
          errorMessage = msgPrefix + 'the argument to least must be a date';
        } else if (nType !== 'number' && (doLength || objType === 'number')) {
          errorMessage = msgPrefix + 'the argument to least must be a number';
        } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
          var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
        } else {
          shouldThrow = false;
        }

        if (shouldThrow) {
          throw new AssertionError(errorMessage, undefined, ssfi);
        }

        if (doLength) {
          var len = obj.length;
          this.assert(
              len >= n
            , 'expected #{this} to have a length at least #{exp} but got #{act}'
            , 'expected #{this} to have a length below #{exp}'
            , n
            , len
          );
        } else {
          this.assert(
              obj >= n
            , 'expected #{this} to be at least #{exp}'
            , 'expected #{this} to be below #{exp}'
            , n
          );
        }
      }

      Assertion.addMethod('least', assertLeast);
      Assertion.addMethod('gte', assertLeast);

      /**
       * ### .below(n[, msg])
       *
       * Asserts that the target is a number or a date less than the given number or date `n` respectively.
       * However, it's often best to assert that the target is equal to its expected
       * value.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.be.below(2); // Not recommended
       *
       * Add `.lengthOf` earlier in the chain to assert that the value of the
       * target's `length` property is less than the given number `n`.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.have.lengthOf.below(4); // Not recommended
       *
       *     expect([1, 2, 3]).to.have.length(3); // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.below`.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.not.be.below(1); // Not recommended
       *
       * `.below` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(2).to.be.below(1, 'nooo why fail??');
       *     expect(2, 'nooo why fail??').to.be.below(1);
       *
       * The aliases `.lt` and `.lessThan` can be used interchangeably with
       * `.below`.
       *
       * @name below
       * @alias lt
       * @alias lessThan
       * @param {Number} n
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertBelow (n, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , doLength = flag(this, 'doLength')
          , flagMsg = flag(this, 'message')
          , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
          , ssfi = flag(this, 'ssfi')
          , objType = _.type(obj).toLowerCase()
          , nType = _.type(n).toLowerCase()
          , shouldThrow = true;

        if (doLength) {
          new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        }

        if (!doLength && (objType === 'date' && nType !== 'date')) {
          errorMessage = msgPrefix + 'the argument to below must be a date';
        } else if (nType !== 'number' && (doLength || objType === 'number')) {
          errorMessage = msgPrefix + 'the argument to below must be a number';
        } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
          var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
        } else {
          shouldThrow = false;
        }

        if (shouldThrow) {
          throw new AssertionError(errorMessage, undefined, ssfi);
        }

        if (doLength) {
          var len = obj.length;
          this.assert(
              len < n
            , 'expected #{this} to have a length below #{exp} but got #{act}'
            , 'expected #{this} to not have a length below #{exp}'
            , n
            , len
          );
        } else {
          this.assert(
              obj < n
            , 'expected #{this} to be below #{exp}'
            , 'expected #{this} to be at least #{exp}'
            , n
          );
        }
      }

      Assertion.addMethod('below', assertBelow);
      Assertion.addMethod('lt', assertBelow);
      Assertion.addMethod('lessThan', assertBelow);

      /**
       * ### .most(n[, msg])
       *
       * Asserts that the target is a number or a date less than or equal to the given number
       * or date `n` respectively. However, it's often best to assert that the target is equal to its
       * expected value.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.be.at.most(2); // Not recommended
       *     expect(1).to.be.at.most(1); // Not recommended
       *
       * Add `.lengthOf` earlier in the chain to assert that the value of the
       * target's `length` property is less than or equal to the given number `n`.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.most`.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.not.be.at.most(1); // Not recommended
       *
       * `.most` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(2).to.be.at.most(1, 'nooo why fail??');
       *     expect(2, 'nooo why fail??').to.be.at.most(1);
       *
       * The alias `.lte` can be used interchangeably with `.most`.
       *
       * @name most
       * @alias lte
       * @param {Number} n
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertMost (n, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , doLength = flag(this, 'doLength')
          , flagMsg = flag(this, 'message')
          , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
          , ssfi = flag(this, 'ssfi')
          , objType = _.type(obj).toLowerCase()
          , nType = _.type(n).toLowerCase()
          , shouldThrow = true;

        if (doLength) {
          new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        }
        
        if (!doLength && (objType === 'date' && nType !== 'date')) {
          errorMessage = msgPrefix + 'the argument to most must be a date';
        } else if (nType !== 'number' && (doLength || objType === 'number')) {
          errorMessage = msgPrefix + 'the argument to most must be a number';
        } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
          var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
        } else {
          shouldThrow = false;
        }

        if (shouldThrow) {
          throw new AssertionError(errorMessage, undefined, ssfi);
        }

        if (doLength) {
          var len = obj.length;
          this.assert(
              len <= n
            , 'expected #{this} to have a length at most #{exp} but got #{act}'
            , 'expected #{this} to have a length above #{exp}'
            , n
            , len
          );
        } else {
          this.assert(
              obj <= n
            , 'expected #{this} to be at most #{exp}'
            , 'expected #{this} to be above #{exp}'
            , n
          );
        }
      }

      Assertion.addMethod('most', assertMost);
      Assertion.addMethod('lte', assertMost);

      /**
       * ### .within(start, finish[, msg])
       *
       * Asserts that the target is a number or a date greater than or equal to the given
       * number or date `start`, and less than or equal to the given number or date `finish` respectively.
       * However, it's often best to assert that the target is equal to its expected
       * value.
       *
       *     expect(2).to.equal(2); // Recommended
       *     expect(2).to.be.within(1, 3); // Not recommended
       *     expect(2).to.be.within(2, 3); // Not recommended
       *     expect(2).to.be.within(1, 2); // Not recommended
       *
       * Add `.lengthOf` earlier in the chain to assert that the value of the
       * target's `length` property is greater than or equal to the given number
       * `start`, and less than or equal to the given number `finish`.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.within`.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.within(2, 4); // Not recommended
       *
       * `.within` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect(4).to.be.within(1, 3, 'nooo why fail??');
       *     expect(4, 'nooo why fail??').to.be.within(1, 3);
       *
       * @name within
       * @param {Number} start lower bound inclusive
       * @param {Number} finish upper bound inclusive
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      Assertion.addMethod('within', function (start, finish, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , doLength = flag(this, 'doLength')
          , flagMsg = flag(this, 'message')
          , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
          , ssfi = flag(this, 'ssfi')
          , objType = _.type(obj).toLowerCase()
          , startType = _.type(start).toLowerCase()
          , finishType = _.type(finish).toLowerCase()
          , shouldThrow = true
          , range = (startType === 'date' && finishType === 'date')
              ? start.toUTCString() + '..' + finish.toUTCString()
              : start + '..' + finish;

        if (doLength) {
          new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        }

        if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {
          errorMessage = msgPrefix + 'the arguments to within must be dates';
        } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
          errorMessage = msgPrefix + 'the arguments to within must be numbers';
        } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
          var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
          errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
        } else {
          shouldThrow = false;
        }

        if (shouldThrow) {
          throw new AssertionError(errorMessage, undefined, ssfi);
        }

        if (doLength) {
          var len = obj.length;
          this.assert(
              len >= start && len <= finish
            , 'expected #{this} to have a length within ' + range
            , 'expected #{this} to not have a length within ' + range
          );
        } else {
          this.assert(
              obj >= start && obj <= finish
            , 'expected #{this} to be within ' + range
            , 'expected #{this} to not be within ' + range
          );
        }
      });

      /**
       * ### .instanceof(constructor[, msg])
       *
       * Asserts that the target is an instance of the given `constructor`.
       *
       *     function Cat () { }
       *
       *     expect(new Cat()).to.be.an.instanceof(Cat);
       *     expect([1, 2]).to.be.an.instanceof(Array);
       *
       * Add `.not` earlier in the chain to negate `.instanceof`.
       *
       *     expect({a: 1}).to.not.be.an.instanceof(Array);
       *
       * `.instanceof` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
       *
       * Due to limitations in ES5, `.instanceof` may not always work as expected
       * when using a transpiler such as Babel or TypeScript. In particular, it may
       * produce unexpected results when subclassing built-in object such as
       * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
       *
       * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
       * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
       *
       * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
       *
       * @name instanceof
       * @param {Constructor} constructor
       * @param {String} msg _optional_
       * @alias instanceOf
       * @namespace BDD
       * @api public
       */

      function assertInstanceOf (constructor, msg) {
        if (msg) flag(this, 'message', msg);

        var target = flag(this, 'object');
        var ssfi = flag(this, 'ssfi');
        var flagMsg = flag(this, 'message');

        try {
          var isInstanceOf = target instanceof constructor;
        } catch (err) {
          if (err instanceof TypeError) {
            flagMsg = flagMsg ? flagMsg + ': ' : '';
            throw new AssertionError(
              flagMsg + 'The instanceof assertion needs a constructor but '
                + _.type(constructor) + ' was given.',
              undefined,
              ssfi
            );
          }
          throw err;
        }

        var name = _.getName(constructor);
        if (name === null) {
          name = 'an unnamed constructor';
        }

        this.assert(
            isInstanceOf
          , 'expected #{this} to be an instance of ' + name
          , 'expected #{this} to not be an instance of ' + name
        );
      }
      Assertion.addMethod('instanceof', assertInstanceOf);
      Assertion.addMethod('instanceOf', assertInstanceOf);

      /**
       * ### .property(name[, val[, msg]])
       *
       * Asserts that the target has a property with the given key `name`.
       *
       *     expect({a: 1}).to.have.property('a');
       *
       * When `val` is provided, `.property` also asserts that the property's value
       * is equal to the given `val`.
       *
       *     expect({a: 1}).to.have.property('a', 1);
       *
       * By default, strict (`===`) equality is used. Add `.deep` earlier in the
       * chain to use deep equality instead. See the `deep-eql` project page for
       * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
       *
       *     // Target object deeply (but not strictly) has property `x: {a: 1}`
       *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
       *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
       *
       * The target's enumerable and non-enumerable properties are always included
       * in the search. By default, both own and inherited properties are included.
       * Add `.own` earlier in the chain to exclude inherited properties from the
       * search.
       *
       *     Object.prototype.b = 2;
       *
       *     expect({a: 1}).to.have.own.property('a');
       *     expect({a: 1}).to.have.own.property('a', 1);
       *     expect({a: 1}).to.have.property('b').but.not.own.property('b'); 
       *
       * `.deep` and `.own` can be combined.
       *
       *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
       *
       * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
       * referencing nested properties.
       *
       *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
       *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
       *
       * If `.` or `[]` are part of an actual property name, they can be escaped by
       * adding two backslashes before them.
       *
       *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
       *
       * `.deep` and `.nested` can be combined.
       *
       *     expect({a: {b: [{c: 3}]}})
       *       .to.have.deep.nested.property('a.b[0]', {c: 3});
       *
       * `.own` and `.nested` cannot be combined.
       *
       * Add `.not` earlier in the chain to negate `.property`.
       *
       *     expect({a: 1}).to.not.have.property('b');
       * 
       * However, it's dangerous to negate `.property` when providing `val`. The
       * problem is that it creates uncertain expectations by asserting that the
       * target either doesn't have a property with the given key `name`, or that it
       * does have a property with the given key `name` but its value isn't equal to
       * the given `val`. It's often best to identify the exact output that's
       * expected, and then write an assertion that only accepts that exact output.
       *
       * When the target isn't expected to have a property with the given key
       * `name`, it's often best to assert exactly that.
       *
       *     expect({b: 2}).to.not.have.property('a'); // Recommended
       *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
       *
       * When the target is expected to have a property with the given key `name`,
       * it's often best to assert that the property has its expected value, rather
       * than asserting that it doesn't have one of many unexpected values.
       *
       *     expect({a: 3}).to.have.property('a', 3); // Recommended
       *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
       *
       * `.property` changes the target of any assertions that follow in the chain
       * to be the value of the property from the original target object.
       *
       *     expect({a: 1}).to.have.property('a').that.is.a('number');
       *
       * `.property` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`. When not providing `val`, only use the
       * second form.
       *
       *     // Recommended
       *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
       *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
       *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
       *
       *     // Not recommended
       *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
       * 
       * The above assertion isn't the same thing as not providing `val`. Instead,
       * it's asserting that the target object has a `b` property that's equal to
       * `undefined`.
       *
       * The assertions `.ownProperty` and `.haveOwnProperty` can be used
       * interchangeably with `.own.property`.
       *
       * @name property
       * @param {String} name
       * @param {Mixed} val (optional)
       * @param {String} msg _optional_
       * @returns value of property for chaining
       * @namespace BDD
       * @api public
       */

      function assertProperty (name, val, msg) {
        if (msg) flag(this, 'message', msg);

        var isNested = flag(this, 'nested')
          , isOwn = flag(this, 'own')
          , flagMsg = flag(this, 'message')
          , obj = flag(this, 'object')
          , ssfi = flag(this, 'ssfi');

        if (isNested && isOwn) {
          flagMsg = flagMsg ? flagMsg + ': ' : '';
          throw new AssertionError(
            flagMsg + 'The "nested" and "own" flags cannot be combined.',
            undefined,
            ssfi
          );
        }

        if (obj === null || obj === undefined) {
          flagMsg = flagMsg ? flagMsg + ': ' : '';
          throw new AssertionError(
            flagMsg + 'Target cannot be null or undefined.',
            undefined,
            ssfi
          );
        }

        var isDeep = flag(this, 'deep')
          , negate = flag(this, 'negate')
          , pathInfo = isNested ? _.getPathInfo(obj, name) : null
          , value = isNested ? pathInfo.value : obj[name];

        var descriptor = '';
        if (isDeep) descriptor += 'deep ';
        if (isOwn) descriptor += 'own ';
        if (isNested) descriptor += 'nested ';
        descriptor += 'property ';

        var hasProperty;
        if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
        else if (isNested) hasProperty = pathInfo.exists;
        else hasProperty = _.hasProperty(obj, name);

        // When performing a negated assertion for both name and val, merely having
        // a property with the given name isn't enough to cause the assertion to
        // fail. It must both have a property with the given name, and the value of
        // that property must equal the given val. Therefore, skip this assertion in
        // favor of the next.
        if (!negate || arguments.length === 1) {
          this.assert(
              hasProperty
            , 'expected #{this} to have ' + descriptor + _.inspect(name)
            , 'expected #{this} to not have ' + descriptor + _.inspect(name));
        }

        if (arguments.length > 1) {
          this.assert(
              hasProperty && (isDeep ? _.eql(val, value) : val === value)
            , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
            , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'
            , val
            , value
          );
        }

        flag(this, 'object', value);
      }

      Assertion.addMethod('property', assertProperty);

      function assertOwnProperty (name, value, msg) {
        flag(this, 'own', true);
        assertProperty.apply(this, arguments);
      }

      Assertion.addMethod('ownProperty', assertOwnProperty);
      Assertion.addMethod('haveOwnProperty', assertOwnProperty);

      /**
       * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
       *
       * Asserts that the target has its own property descriptor with the given key
       * `name`. Enumerable and non-enumerable properties are included in the
       * search.
       *
       *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
       *
       * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
       * the property's descriptor is deeply equal to the given `descriptor`. See
       * the `deep-eql` project page for info on the deep equality algorithm:
       * https://github.com/chaijs/deep-eql.
       *
       *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 1,
       *     });
       *
       * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
       *
       *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
       * 
       * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
       * a `descriptor`. The problem is that it creates uncertain expectations by
       * asserting that the target either doesn't have a property descriptor with
       * the given key `name`, or that it does have a property descriptor with the
       * given key `name` but its not deeply equal to the given `descriptor`. It's
       * often best to identify the exact output that's expected, and then write an
       * assertion that only accepts that exact output.
       *
       * When the target isn't expected to have a property descriptor with the given
       * key `name`, it's often best to assert exactly that.
       *
       *     // Recommended
       *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
       *
       *     // Not recommended
       *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 1,
       *     });
       *
       * When the target is expected to have a property descriptor with the given
       * key `name`, it's often best to assert that the property has its expected
       * descriptor, rather than asserting that it doesn't have one of many
       * unexpected descriptors.
       *
       *     // Recommended
       *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 3,
       *     });
       *
       *     // Not recommended
       *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 1,
       *     });
       *
       * `.ownPropertyDescriptor` changes the target of any assertions that follow
       * in the chain to be the value of the property descriptor from the original
       * target object.
       *
       *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
       *       .that.has.property('enumerable', true);
       *
       * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
       * custom error message to show when the assertion fails. The message can also
       * be given as the second argument to `expect`. When not providing
       * `descriptor`, only use the second form.
       *
       *     // Recommended
       *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 2,
       *     }, 'nooo why fail??');
       *
       *     // Recommended
       *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
       *       configurable: true,
       *       enumerable: true,
       *       writable: true,
       *       value: 2,
       *     });
       * 
       *     // Recommended
       *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
       *
       *     // Not recommended
       *     expect({a: 1})
       *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
       *
       * The above assertion isn't the same thing as not providing `descriptor`.
       * Instead, it's asserting that the target object has a `b` property
       * descriptor that's deeply equal to `undefined`.
       *
       * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
       * `.ownPropertyDescriptor`.
       *
       * @name ownPropertyDescriptor
       * @alias haveOwnPropertyDescriptor
       * @param {String} name
       * @param {Object} descriptor _optional_
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertOwnPropertyDescriptor (name, descriptor, msg) {
        if (typeof descriptor === 'string') {
          msg = descriptor;
          descriptor = null;
        }
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
        if (actualDescriptor && descriptor) {
          this.assert(
              _.eql(descriptor, actualDescriptor)
            , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
            , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
            , descriptor
            , actualDescriptor
            , true
          );
        } else {
          this.assert(
              actualDescriptor
            , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
            , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
          );
        }
        flag(this, 'object', actualDescriptor);
      }

      Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
      Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

      /**
       * ### .lengthOf(n[, msg])
       *
       * Asserts that the target's `length` property is equal to the given number
       * `n`.
       *
       *     expect([1, 2, 3]).to.have.lengthOf(3);
       *     expect('foo').to.have.lengthOf(3);
       *
       * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
       * best to assert that the target's `length` property is equal to its expected
       * value, rather than not equal to one of many unexpected values.
       *
       *     expect('foo').to.have.lengthOf(3); // Recommended
       *     expect('foo').to.not.have.lengthOf(4); // Not recommended
       *
       * `.lengthOf` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
       *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
       *
       * `.lengthOf` can also be used as a language chain, causing all `.above`,
       * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
       * chain to use the target's `length` property as the target. However, it's
       * often best to assert that the target's `length` property is equal to its
       * expected length, rather than asserting that its `length` property falls
       * within some range of values.
       *
       *     // Recommended
       *     expect([1, 2, 3]).to.have.lengthOf(3);
       *
       *     // Not recommended
       *     expect([1, 2, 3]).to.have.lengthOf.above(2);
       *     expect([1, 2, 3]).to.have.lengthOf.below(4);
       *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
       *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
       *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
       *
       * Due to a compatibility issue, the alias `.length` can't be chained directly
       * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
       * interchangeably with `.lengthOf` in every situation. It's recommended to
       * always use `.lengthOf` instead of `.length`.
       *
       *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
       *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
       *
       * @name lengthOf
       * @alias length
       * @param {Number} n
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertLengthChain () {
        flag(this, 'doLength', true);
      }

      function assertLength (n, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        var len = obj.length;

        this.assert(
            len == n
          , 'expected #{this} to have a length of #{exp} but got #{act}'
          , 'expected #{this} to not have a length of #{act}'
          , n
          , len
        );
      }

      Assertion.addChainableMethod('length', assertLength, assertLengthChain);
      Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);

      /**
       * ### .match(re[, msg])
       *
       * Asserts that the target matches the given regular expression `re`.
       *
       *     expect('foobar').to.match(/^foo/);
       *
       * Add `.not` earlier in the chain to negate `.match`.
       *
       *     expect('foobar').to.not.match(/taco/);
       *
       * `.match` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect('foobar').to.match(/taco/, 'nooo why fail??');
       *     expect('foobar', 'nooo why fail??').to.match(/taco/);
       *
       * The alias `.matches` can be used interchangeably with `.match`.
       *
       * @name match
       * @alias matches
       * @param {RegExp} re
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */
      function assertMatch(re, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        this.assert(
            re.exec(obj)
          , 'expected #{this} to match ' + re
          , 'expected #{this} not to match ' + re
        );
      }

      Assertion.addMethod('match', assertMatch);
      Assertion.addMethod('matches', assertMatch);

      /**
       * ### .string(str[, msg])
       *
       * Asserts that the target string contains the given substring `str`.
       *
       *     expect('foobar').to.have.string('bar');
       *
       * Add `.not` earlier in the chain to negate `.string`.
       *
       *     expect('foobar').to.not.have.string('taco');
       *
       * `.string` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect('foobar').to.have.string(/taco/, 'nooo why fail??');
       *     expect('foobar', 'nooo why fail??').to.have.string(/taco/);
       *
       * @name string
       * @param {String} str
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      Assertion.addMethod('string', function (str, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(obj, flagMsg, ssfi, true).is.a('string');

        this.assert(
            ~obj.indexOf(str)
          , 'expected #{this} to contain ' + _.inspect(str)
          , 'expected #{this} to not contain ' + _.inspect(str)
        );
      });

      /**
       * ### .keys(key1[, key2[, ...]])
       *
       * Asserts that the target object, array, map, or set has the given keys. Only
       * the target's own inherited properties are included in the search. 
       *
       * When the target is an object or array, keys can be provided as one or more
       * string arguments, a single array argument, or a single object argument. In
       * the latter case, only the keys in the given object matter; the values are
       * ignored.
       *
       *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
       *     expect(['x', 'y']).to.have.all.keys(0, 1);
       *
       *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
       *     expect(['x', 'y']).to.have.all.keys([0, 1]);
       *
       *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
       *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
       *
       * When the target is a map or set, each key must be provided as a separate
       * argument.
       *
       *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
       *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
       *
       * Because `.keys` does different things based on the target's type, it's
       * important to check the target's type before using `.keys`. See the `.a` doc
       * for info on testing a target's type.
       *
       *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
       *
       * By default, strict (`===`) equality is used to compare keys of maps and
       * sets. Add `.deep` earlier in the chain to use deep equality instead. See
       * the `deep-eql` project page for info on the deep equality algorithm:
       * https://github.com/chaijs/deep-eql.
       *
       *     // Target set deeply (but not strictly) has key `{a: 1}`
       *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
       *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
       *
       * By default, the target must have all of the given keys and no more. Add
       * `.any` earlier in the chain to only require that the target have at least
       * one of the given keys. Also, add `.not` earlier in the chain to negate
       * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
       * `.all` when asserting `.keys` without negation.
       *
       * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
       * exactly what's expected of the output, whereas `.not.all.keys` creates
       * uncertain expectations.
       *
       *     // Recommended; asserts that target doesn't have any of the given keys
       *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
       *
       *     // Not recommended; asserts that target doesn't have all of the given
       *     // keys but may or may not have some of them
       *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
       *
       * When asserting `.keys` without negation, `.all` is preferred because
       * `.all.keys` asserts exactly what's expected of the output, whereas
       * `.any.keys` creates uncertain expectations.
       *
       *     // Recommended; asserts that target has all the given keys
       *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
       *
       *     // Not recommended; asserts that target has at least one of the given
       *     // keys but may or may not have more of them
       *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
       *
       * Note that `.all` is used by default when neither `.all` nor `.any` appear
       * earlier in the chain. However, it's often best to add `.all` anyway because
       * it improves readability.
       *
       *     // Both assertions are identical
       *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
       *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
       *
       * Add `.include` earlier in the chain to require that the target's keys be a
       * superset of the expected keys, rather than identical sets.
       *
       *     // Target object's keys are a superset of ['a', 'b'] but not identical
       *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
       *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
       *
       * However, if `.any` and `.include` are combined, only the `.any` takes
       * effect. The `.include` is ignored in this case.
       *
       *     // Both assertions are identical
       *     expect({a: 1}).to.have.any.keys('a', 'b');
       *     expect({a: 1}).to.include.any.keys('a', 'b');
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
       *
       * The alias `.key` can be used interchangeably with `.keys`.
       *
       * @name keys
       * @alias key
       * @param {...String|Array|Object} keys
       * @namespace BDD
       * @api public
       */

      function assertKeys (keys) {
        var obj = flag(this, 'object')
          , objType = _.type(obj)
          , keysType = _.type(keys)
          , ssfi = flag(this, 'ssfi')
          , isDeep = flag(this, 'deep')
          , str
          , deepStr = ''
          , ok = true
          , flagMsg = flag(this, 'message');

        flagMsg = flagMsg ? flagMsg + ': ' : '';
        var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

        if (objType === 'Map' || objType === 'Set') {
          deepStr = isDeep ? 'deeply ' : '';
          actual = [];

          // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
          obj.forEach(function (val, key) { actual.push(key); });

          if (keysType !== 'Array') {
            keys = Array.prototype.slice.call(arguments);
          }

        } else {
          actual = _.getOwnEnumerableProperties(obj);

          switch (keysType) {
            case 'Array':
              if (arguments.length > 1) {
                throw new AssertionError(mixedArgsMsg, undefined, ssfi);
              }
              break;
            case 'Object':
              if (arguments.length > 1) {
                throw new AssertionError(mixedArgsMsg, undefined, ssfi);
              }
              keys = Object.keys(keys);
              break;
            default:
              keys = Array.prototype.slice.call(arguments);
          }

          // Only stringify non-Symbols because Symbols would become "Symbol()"
          keys = keys.map(function (val) {
            return typeof val === 'symbol' ? val : String(val);
          });
        }

        if (!keys.length) {
          throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
        }

        var len = keys.length
          , any = flag(this, 'any')
          , all = flag(this, 'all')
          , expected = keys
          , actual;

        if (!any && !all) {
          all = true;
        }

        // Has any
        if (any) {
          ok = expected.some(function(expectedKey) {
            return actual.some(function(actualKey) {
              if (isDeep) {
                return _.eql(expectedKey, actualKey);
              } else {
                return expectedKey === actualKey;
              }
            });
          });
        }

        // Has all
        if (all) {
          ok = expected.every(function(expectedKey) {
            return actual.some(function(actualKey) {
              if (isDeep) {
                return _.eql(expectedKey, actualKey);
              } else {
                return expectedKey === actualKey;
              }
            });
          });

          if (!flag(this, 'contains')) {
            ok = ok && keys.length == actual.length;
          }
        }

        // Key string
        if (len > 1) {
          keys = keys.map(function(key) {
            return _.inspect(key);
          });
          var last = keys.pop();
          if (all) {
            str = keys.join(', ') + ', and ' + last;
          }
          if (any) {
            str = keys.join(', ') + ', or ' + last;
          }
        } else {
          str = _.inspect(keys[0]);
        }

        // Form
        str = (len > 1 ? 'keys ' : 'key ') + str;

        // Have / include
        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

        // Assertion
        this.assert(
            ok
          , 'expected #{this} to ' + deepStr + str
          , 'expected #{this} to not ' + deepStr + str
          , expected.slice(0).sort(_.compareByInspect)
          , actual.sort(_.compareByInspect)
          , true
        );
      }

      Assertion.addMethod('keys', assertKeys);
      Assertion.addMethod('key', assertKeys);

      /**
       * ### .throw([errorLike], [errMsgMatcher], [msg])
       *
       * When no arguments are provided, `.throw` invokes the target function and
       * asserts that an error is thrown.
       * 
       *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
       *
       *     expect(badFn).to.throw();
       *
       * When one argument is provided, and it's an error constructor, `.throw`
       * invokes the target function and asserts that an error is thrown that's an
       * instance of that error constructor.
       *
       *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
       *
       *     expect(badFn).to.throw(TypeError);
       *
       * When one argument is provided, and it's an error instance, `.throw` invokes
       * the target function and asserts that an error is thrown that's strictly
       * (`===`) equal to that error instance.
       *
       *     var err = new TypeError('Illegal salmon!');
       *     var badFn = function () { throw err; };
       *
       *     expect(badFn).to.throw(err);
       *
       * When one argument is provided, and it's a string, `.throw` invokes the
       * target function and asserts that an error is thrown with a message that
       * contains that string.
       *
       *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
       *
       *     expect(badFn).to.throw('salmon');
       *
       * When one argument is provided, and it's a regular expression, `.throw`
       * invokes the target function and asserts that an error is thrown with a
       * message that matches that regular expression.
       *
       *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
       *
       *     expect(badFn).to.throw(/salmon/);
       *
       * When two arguments are provided, and the first is an error instance or
       * constructor, and the second is a string or regular expression, `.throw`
       * invokes the function and asserts that an error is thrown that fulfills both
       * conditions as described above.
       *
       *     var err = new TypeError('Illegal salmon!');
       *     var badFn = function () { throw err; };
       *
       *     expect(badFn).to.throw(TypeError, 'salmon');
       *     expect(badFn).to.throw(TypeError, /salmon/);
       *     expect(badFn).to.throw(err, 'salmon');
       *     expect(badFn).to.throw(err, /salmon/);
       *
       * Add `.not` earlier in the chain to negate `.throw`.
       *     
       *     var goodFn = function () {};
       *
       *     expect(goodFn).to.not.throw();
       * 
       * However, it's dangerous to negate `.throw` when providing any arguments.
       * The problem is that it creates uncertain expectations by asserting that the
       * target either doesn't throw an error, or that it throws an error but of a
       * different type than the given type, or that it throws an error of the given
       * type but with a message that doesn't include the given string. It's often
       * best to identify the exact output that's expected, and then write an
       * assertion that only accepts that exact output.
       *
       * When the target isn't expected to throw an error, it's often best to assert
       * exactly that.
       *
       *     var goodFn = function () {};
       *
       *     expect(goodFn).to.not.throw(); // Recommended
       *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
       *
       * When the target is expected to throw an error, it's often best to assert
       * that the error is of its expected type, and has a message that includes an
       * expected string, rather than asserting that it doesn't have one of many
       * unexpected types, and doesn't have a message that includes some string.
       *
       *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
       *
       *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
       *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
       *
       * `.throw` changes the target of any assertions that follow in the chain to
       * be the error object that's thrown.
       *
       *     var err = new TypeError('Illegal salmon!');
       *     err.code = 42;
       *     var badFn = function () { throw err; };
       *
       *     expect(badFn).to.throw(TypeError).with.property('code', 42);
       *
       * `.throw` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`. When not providing two arguments, always use
       * the second form.
       *
       *     var goodFn = function () {};
       *
       *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
       *     expect(goodFn, 'nooo why fail??').to.throw();
       *
       * Due to limitations in ES5, `.throw` may not always work as expected when
       * using a transpiler such as Babel or TypeScript. In particular, it may
       * produce unexpected results when subclassing the built-in `Error` object and
       * then passing the subclassed constructor to `.throw`. See your transpiler's
       * docs for details:
       *
       * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
       * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
       *
       * Beware of some common mistakes when using the `throw` assertion. One common
       * mistake is to accidentally invoke the function yourself instead of letting
       * the `throw` assertion invoke the function for you. For example, when
       * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
       * the target for the assertion.
       *
       *     expect(fn).to.throw();     // Good! Tests `fn` as desired
       *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
       *
       * If you need to assert that your function `fn` throws when passed certain
       * arguments, then wrap a call to `fn` inside of another function.
       *
       *     expect(function () { fn(42); }).to.throw();  // Function expression
       *     expect(() => fn(42)).to.throw();             // ES6 arrow function
       *
       * Another common mistake is to provide an object method (or any stand-alone
       * function that relies on `this`) as the target of the assertion. Doing so is
       * problematic because the `this` context will be lost when the function is
       * invoked by `.throw`; there's no way for it to know what `this` is supposed
       * to be. There are two ways around this problem. One solution is to wrap the
       * method or function call inside of another function. Another solution is to
       * use `bind`.
       *
       *     expect(function () { cat.meow(); }).to.throw();  // Function expression
       *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
       *     expect(cat.meow.bind(cat)).to.throw();           // Bind
       *
       * Finally, it's worth mentioning that it's a best practice in JavaScript to
       * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
       * `TypeError`, and user-defined objects that extend `Error`. No other type of
       * value will generate a stack trace when initialized. With that said, the
       * `throw` assertion does technically support any type of value being thrown,
       * not just `Error` and its derivatives.
       *
       * The aliases `.throws` and `.Throw` can be used interchangeably with
       * `.throw`.
       *
       * @name throw
       * @alias throws
       * @alias Throw
       * @param {Error|ErrorConstructor} errorLike
       * @param {String|RegExp} errMsgMatcher error message
       * @param {String} msg _optional_
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @returns error for chaining (null if no error)
       * @namespace BDD
       * @api public
       */

      function assertThrows (errorLike, errMsgMatcher, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , ssfi = flag(this, 'ssfi')
          , flagMsg = flag(this, 'message')
          , negate = flag(this, 'negate') || false;
        new Assertion(obj, flagMsg, ssfi, true).is.a('function');

        if (errorLike instanceof RegExp || typeof errorLike === 'string') {
          errMsgMatcher = errorLike;
          errorLike = null;
        }

        var caughtErr;
        try {
          obj();
        } catch (err) {
          caughtErr = err;
        }

        // If we have the negate flag enabled and at least one valid argument it means we do expect an error
        // but we want it to match a given set of criteria
        var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;

        // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
        // See Issue #551 and PR #683@GitHub
        var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
        var errorLikeFail = false;
        var errMsgMatcherFail = false;

        // Checking if error was thrown
        if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
          // We need this to display results correctly according to their types
          var errorLikeString = 'an error';
          if (errorLike instanceof Error) {
            errorLikeString = '#{exp}';
          } else if (errorLike) {
            errorLikeString = _.checkError.getConstructorName(errorLike);
          }

          this.assert(
              caughtErr
            , 'expected #{this} to throw ' + errorLikeString
            , 'expected #{this} to not throw an error but #{act} was thrown'
            , errorLike && errorLike.toString()
            , (caughtErr instanceof Error ?
                caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&
                                        _.checkError.getConstructorName(caughtErr)))
          );
        }

        if (errorLike && caughtErr) {
          // We should compare instances only if `errorLike` is an instance of `Error`
          if (errorLike instanceof Error) {
            var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

            if (isCompatibleInstance === negate) {
              // These checks were created to ensure we won't fail too soon when we've got both args and a negate
              // See Issue #551 and PR #683@GitHub
              if (everyArgIsDefined && negate) {
                errorLikeFail = true;
              } else {
                this.assert(
                    negate
                  , 'expected #{this} to throw #{exp} but #{act} was thrown'
                  , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')
                  , errorLike.toString()
                  , caughtErr.toString()
                );
              }
            }
          }

          var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
          if (isCompatibleConstructor === negate) {
            if (everyArgIsDefined && negate) {
                errorLikeFail = true;
            } else {
              this.assert(
                  negate
                , 'expected #{this} to throw #{exp} but #{act} was thrown'
                , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
                , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
                , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
              );
            }
          }
        }

        if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
          // Here we check compatible messages
          var placeholder = 'including';
          if (errMsgMatcher instanceof RegExp) {
            placeholder = 'matching';
          }

          var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
          if (isCompatibleMessage === negate) {
            if (everyArgIsDefined && negate) {
                errMsgMatcherFail = true;
            } else {
              this.assert(
                negate
                , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'
                , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'
                ,  errMsgMatcher
                ,  _.checkError.getMessage(caughtErr)
              );
            }
          }
        }

        // If both assertions failed and both should've matched we throw an error
        if (errorLikeFail && errMsgMatcherFail) {
          this.assert(
            negate
            , 'expected #{this} to throw #{exp} but #{act} was thrown'
            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
          );
        }

        flag(this, 'object', caughtErr);
      }
      Assertion.addMethod('throw', assertThrows);
      Assertion.addMethod('throws', assertThrows);
      Assertion.addMethod('Throw', assertThrows);

      /**
       * ### .respondTo(method[, msg])
       *
       * When the target is a non-function object, `.respondTo` asserts that the
       * target has a method with the given name `method`. The method can be own or
       * inherited, and it can be enumerable or non-enumerable.
       *
       *     function Cat () {}
       *     Cat.prototype.meow = function () {};
       *
       *     expect(new Cat()).to.respondTo('meow');
       *
       * When the target is a function, `.respondTo` asserts that the target's
       * `prototype` property has a method with the given name `method`. Again, the
       * method can be own or inherited, and it can be enumerable or non-enumerable.
       *
       *     function Cat () {}
       *     Cat.prototype.meow = function () {};
       *
       *     expect(Cat).to.respondTo('meow');
       *
       * Add `.itself` earlier in the chain to force `.respondTo` to treat the
       * target as a non-function object, even if it's a function. Thus, it asserts
       * that the target has a method with the given name `method`, rather than
       * asserting that the target's `prototype` property has a method with the
       * given name `method`.
       *
       *     function Cat () {}
       *     Cat.prototype.meow = function () {};
       *     Cat.hiss = function () {};
       *
       *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
       *
       * When not adding `.itself`, it's important to check the target's type before
       * using `.respondTo`. See the `.a` doc for info on checking a target's type.
       *
       *     function Cat () {}
       *     Cat.prototype.meow = function () {};
       *
       *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
       *
       * Add `.not` earlier in the chain to negate `.respondTo`.
       *
       *     function Dog () {}
       *     Dog.prototype.bark = function () {};
       *
       *     expect(new Dog()).to.not.respondTo('meow');
       *
       * `.respondTo` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect({}).to.respondTo('meow', 'nooo why fail??');
       *     expect({}, 'nooo why fail??').to.respondTo('meow');
       *
       * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
       *
       * @name respondTo
       * @alias respondsTo
       * @param {String} method
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function respondTo (method, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , itself = flag(this, 'itself')
          , context = ('function' === typeof obj && !itself)
            ? obj.prototype[method]
            : obj[method];

        this.assert(
            'function' === typeof context
          , 'expected #{this} to respond to ' + _.inspect(method)
          , 'expected #{this} to not respond to ' + _.inspect(method)
        );
      }

      Assertion.addMethod('respondTo', respondTo);
      Assertion.addMethod('respondsTo', respondTo);

      /**
       * ### .itself
       *
       * Forces all `.respondTo` assertions that follow in the chain to behave as if
       * the target is a non-function object, even if it's a function. Thus, it
       * causes `.respondTo` to assert that the target has a method with the given
       * name, rather than asserting that the target's `prototype` property has a
       * method with the given name.
       *
       *     function Cat () {}
       *     Cat.prototype.meow = function () {};
       *     Cat.hiss = function () {};
       *
       *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
       *
       * @name itself
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('itself', function () {
        flag(this, 'itself', true);
      });

      /**
       * ### .satisfy(matcher[, msg])
       *
       * Invokes the given `matcher` function with the target being passed as the
       * first argument, and asserts that the value returned is truthy.
       *
       *     expect(1).to.satisfy(function(num) {
       *       return num > 0; 
       *     });
       *
       * Add `.not` earlier in the chain to negate `.satisfy`.
       *
       *     expect(1).to.not.satisfy(function(num) {
       *       return num > 2;
       *     });
       *
       * `.satisfy` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect(1).to.satisfy(function(num) {
       *       return num > 2;
       *     }, 'nooo why fail??');
       *
       *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
       *       return num > 2;
       *     });
       *
       * The alias `.satisfies` can be used interchangeably with `.satisfy`.
       *
       * @name satisfy
       * @alias satisfies
       * @param {Function} matcher
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function satisfy (matcher, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object');
        var result = matcher(obj);
        this.assert(
            result
          , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
          , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
          , flag(this, 'negate') ? false : true
          , result
        );
      }

      Assertion.addMethod('satisfy', satisfy);
      Assertion.addMethod('satisfies', satisfy);

      /**
       * ### .closeTo(expected, delta[, msg])
       *
       * Asserts that the target is a number that's within a given +/- `delta` range
       * of the given number `expected`. However, it's often best to assert that the
       * target is equal to its expected value.
       *
       *     // Recommended
       *     expect(1.5).to.equal(1.5);
       *
       *     // Not recommended
       *     expect(1.5).to.be.closeTo(1, 0.5);
       *     expect(1.5).to.be.closeTo(2, 0.5);
       *     expect(1.5).to.be.closeTo(1, 1);
       *
       * Add `.not` earlier in the chain to negate `.closeTo`.
       *
       *     expect(1.5).to.equal(1.5); // Recommended
       *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
       *
       * `.closeTo` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
       *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
       *
       * The alias `.approximately` can be used interchangeably with `.closeTo`.
       *
       * @name closeTo
       * @alias approximately
       * @param {Number} expected
       * @param {Number} delta
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function closeTo(expected, delta, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');

        new Assertion(obj, flagMsg, ssfi, true).is.a('number');
        if (typeof expected !== 'number' || typeof delta !== 'number') {
          flagMsg = flagMsg ? flagMsg + ': ' : '';
          throw new AssertionError(
              flagMsg + 'the arguments to closeTo or approximately must be numbers',
              undefined,
              ssfi
          );
        }

        this.assert(
            Math.abs(obj - expected) <= delta
          , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
          , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
        );
      }

      Assertion.addMethod('closeTo', closeTo);
      Assertion.addMethod('approximately', closeTo);

      // Note: Duplicates are ignored if testing for inclusion instead of sameness.
      function isSubsetOf(subset, superset, cmp, contains, ordered) {
        if (!contains) {
          if (subset.length !== superset.length) return false;
          superset = superset.slice();
        }

        return subset.every(function(elem, idx) {
          if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

          if (!cmp) {
            var matchIdx = superset.indexOf(elem);
            if (matchIdx === -1) return false;

            // Remove match from superset so not counted twice if duplicate in subset.
            if (!contains) superset.splice(matchIdx, 1);
            return true;
          }

          return superset.some(function(elem2, matchIdx) {
            if (!cmp(elem, elem2)) return false;

            // Remove match from superset so not counted twice if duplicate in subset.
            if (!contains) superset.splice(matchIdx, 1);
            return true;
          });
        });
      }

      /**
       * ### .members(set[, msg])
       *
       * Asserts that the target array has the same members as the given array
       * `set`.
       *
       *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
       *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
       *
       * By default, members are compared using strict (`===`) equality. Add `.deep`
       * earlier in the chain to use deep equality instead. See the `deep-eql`
       * project page for info on the deep equality algorithm:
       * https://github.com/chaijs/deep-eql.
       *
       *     // Target array deeply (but not strictly) has member `{a: 1}`
       *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
       *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
       *
       * By default, order doesn't matter. Add `.ordered` earlier in the chain to
       * require that members appear in the same order.
       *
       *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
       *     expect([1, 2, 3]).to.have.members([2, 1, 3])
       *       .but.not.ordered.members([2, 1, 3]);
       *
       * By default, both arrays must be the same size. Add `.include` earlier in
       * the chain to require that the target's members be a superset of the
       * expected members. Note that duplicates are ignored in the subset when
       * `.include` is added.
       *
       *     // Target array is a superset of [1, 2] but not identical
       *     expect([1, 2, 3]).to.include.members([1, 2]);
       *     expect([1, 2, 3]).to.not.have.members([1, 2]);
       *
       *     // Duplicates in the subset are ignored
       *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
       *
       * `.deep`, `.ordered`, and `.include` can all be combined. However, if
       * `.include` and `.ordered` are combined, the ordering begins at the start of
       * both arrays.
       *
       *     expect([{a: 1}, {b: 2}, {c: 3}])
       *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
       *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
       *
       * Add `.not` earlier in the chain to negate `.members`. However, it's
       * dangerous to do so. The problem is that it creates uncertain expectations
       * by asserting that the target array doesn't have all of the same members as
       * the given array `set` but may or may not have some of them. It's often best
       * to identify the exact output that's expected, and then write an assertion
       * that only accepts that exact output.
       *
       *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
       *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
       *
       * `.members` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`.
       *
       *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
       *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
       *
       * @name members
       * @param {Array} set
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      Assertion.addMethod('members', function (subset, msg) {
        if (msg) flag(this, 'message', msg);
        var obj = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');

        new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
        new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');

        var contains = flag(this, 'contains');
        var ordered = flag(this, 'ordered');

        var subject, failMsg, failNegateMsg;

        if (contains) {
          subject = ordered ? 'an ordered superset' : 'a superset';
          failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
          failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
        } else {
          subject = ordered ? 'ordered members' : 'members';
          failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
          failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
        }

        var cmp = flag(this, 'deep') ? _.eql : undefined;

        this.assert(
            isSubsetOf(subset, obj, cmp, contains, ordered)
          , failMsg
          , failNegateMsg
          , subset
          , obj
          , true
        );
      });

      /**
       * ### .oneOf(list[, msg])
       *
       * Asserts that the target is a member of the given array `list`. However,
       * it's often best to assert that the target is equal to its expected value.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
       *
       * Comparisons are performed using strict (`===`) equality.
       *
       * Add `.not` earlier in the chain to negate `.oneOf`.
       *
       *     expect(1).to.equal(1); // Recommended
       *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
       *
       * `.oneOf` accepts an optional `msg` argument which is a custom error message
       * to show when the assertion fails. The message can also be given as the
       * second argument to `expect`.
       *
       *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
       *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
       *
       * @name oneOf
       * @param {Array<*>} list
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function oneOf (list, msg) {
        if (msg) flag(this, 'message', msg);
        var expected = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(list, flagMsg, ssfi, true).to.be.an('array');

        this.assert(
            list.indexOf(expected) > -1
          , 'expected #{this} to be one of #{exp}'
          , 'expected #{this} to not be one of #{exp}'
          , list
          , expected
        );
      }

      Assertion.addMethod('oneOf', oneOf);


      /**
       * ### .change(subject[, prop[, msg]])
       *
       * When one argument is provided, `.change` asserts that the given function
       * `subject` returns a different value when it's invoked before the target
       * function compared to when it's invoked afterward. However, it's often best
       * to assert that `subject` is equal to its expected value.
       *
       *     var dots = ''
       *       , addDot = function () { dots += '.'; }
       *       , getDots = function () { return dots; };
       *
       *     // Recommended
       *     expect(getDots()).to.equal('');
       *     addDot();
       *     expect(getDots()).to.equal('.');
       *
       *     // Not recommended
       *     expect(addDot).to.change(getDots);
       *
       * When two arguments are provided, `.change` asserts that the value of the
       * given object `subject`'s `prop` property is different before invoking the
       * target function compared to afterward.
       *
       *     var myObj = {dots: ''}
       *       , addDot = function () { myObj.dots += '.'; };
       *
       *     // Recommended
       *     expect(myObj).to.have.property('dots', '');
       *     addDot();
       *     expect(myObj).to.have.property('dots', '.');
       *
       *     // Not recommended
       *     expect(addDot).to.change(myObj, 'dots');
       *
       * Strict (`===`) equality is used to compare before and after values.
       *
       * Add `.not` earlier in the chain to negate `.change`.
       *
       *     var dots = ''
       *       , noop = function () {}
       *       , getDots = function () { return dots; };
       *
       *     expect(noop).to.not.change(getDots);
       *
       *     var myObj = {dots: ''}
       *       , noop = function () {};
       *
       *     expect(noop).to.not.change(myObj, 'dots');
       *
       * `.change` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`. When not providing two arguments, always
       * use the second form.
       *
       *     var myObj = {dots: ''}
       *       , addDot = function () { myObj.dots += '.'; };
       *
       *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
       *
       *     var dots = ''
       *       , addDot = function () { dots += '.'; }
       *       , getDots = function () { return dots; };
       *
       *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
       *
       * `.change` also causes all `.by` assertions that follow in the chain to
       * assert how much a numeric subject was increased or decreased by. However,
       * it's dangerous to use `.change.by`. The problem is that it creates
       * uncertain expectations by asserting that the subject either increases by
       * the given delta, or that it decreases by the given delta. It's often best
       * to identify the exact output that's expected, and then write an assertion
       * that only accepts that exact output.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; }
       *       , subtractTwo = function () { myObj.val -= 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
       *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
       *
       *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
       *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
       *
       * The alias `.changes` can be used interchangeably with `.change`.
       *
       * @name change
       * @alias changes
       * @param {String} subject
       * @param {String} prop name _optional_
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertChanges (subject, prop, msg) {
        if (msg) flag(this, 'message', msg);
        var fn = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(fn, flagMsg, ssfi, true).is.a('function');

        var initial;
        if (!prop) {
          new Assertion(subject, flagMsg, ssfi, true).is.a('function');
          initial = subject();
        } else {
          new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial = subject[prop];
        }

        fn();

        var final = prop === undefined || prop === null ? subject() : subject[prop];
        var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

        // This gets flagged because of the .by(delta) assertion
        flag(this, 'deltaMsgObj', msgObj);
        flag(this, 'initialDeltaValue', initial);
        flag(this, 'finalDeltaValue', final);
        flag(this, 'deltaBehavior', 'change');
        flag(this, 'realDelta', final !== initial);

        this.assert(
          initial !== final
          , 'expected ' + msgObj + ' to change'
          , 'expected ' + msgObj + ' to not change'
        );
      }

      Assertion.addMethod('change', assertChanges);
      Assertion.addMethod('changes', assertChanges);

      /**
       * ### .increase(subject[, prop[, msg]])
       *
       * When one argument is provided, `.increase` asserts that the given function
       * `subject` returns a greater number when it's invoked after invoking the
       * target function compared to when it's invoked beforehand. `.increase` also
       * causes all `.by` assertions that follow in the chain to assert how much
       * greater of a number is returned. It's often best to assert that the return
       * value increased by the expected amount, rather than asserting it increased
       * by any amount.
       *
       *     var val = 1
       *       , addTwo = function () { val += 2; }
       *       , getVal = function () { return val; };
       *
       *     expect(addTwo).to.increase(getVal).by(2); // Recommended
       *     expect(addTwo).to.increase(getVal); // Not recommended
       *
       * When two arguments are provided, `.increase` asserts that the value of the
       * given object `subject`'s `prop` property is greater after invoking the
       * target function compared to beforehand.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
       *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.increase`. However, it's
       * dangerous to do so. The problem is that it creates uncertain expectations
       * by asserting that the subject either decreases, or that it stays the same.
       * It's often best to identify the exact output that's expected, and then
       * write an assertion that only accepts that exact output.
       *
       * When the subject is expected to decrease, it's often best to assert that it
       * decreased by the expected amount.
       *
       *     var myObj = {val: 1}
       *       , subtractTwo = function () { myObj.val -= 2; };
       *
       *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
       *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
       * 
       * When the subject is expected to stay the same, it's often best to assert
       * exactly that.
       *
       *     var myObj = {val: 1}
       *       , noop = function () {};
       *
       *     expect(noop).to.not.change(myObj, 'val'); // Recommended
       *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
       *
       * `.increase` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`. When not providing two arguments, always
       * use the second form.
       *
       *     var myObj = {val: 1}
       *       , noop = function () {};
       *
       *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
       *
       *     var val = 1
       *       , noop = function () {}
       *       , getVal = function () { return val; };
       *
       *     expect(noop, 'nooo why fail??').to.increase(getVal);
       *
       * The alias `.increases` can be used interchangeably with `.increase`.
       *
       * @name increase
       * @alias increases
       * @param {String|Function} subject
       * @param {String} prop name _optional_
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertIncreases (subject, prop, msg) {
        if (msg) flag(this, 'message', msg);
        var fn = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(fn, flagMsg, ssfi, true).is.a('function');

        var initial;
        if (!prop) {
          new Assertion(subject, flagMsg, ssfi, true).is.a('function');
          initial = subject();
        } else {
          new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial = subject[prop];
        }

        // Make sure that the target is a number
        new Assertion(initial, flagMsg, ssfi, true).is.a('number');

        fn();

        var final = prop === undefined || prop === null ? subject() : subject[prop];
        var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

        flag(this, 'deltaMsgObj', msgObj);
        flag(this, 'initialDeltaValue', initial);
        flag(this, 'finalDeltaValue', final);
        flag(this, 'deltaBehavior', 'increase');
        flag(this, 'realDelta', final - initial);

        this.assert(
          final - initial > 0
          , 'expected ' + msgObj + ' to increase'
          , 'expected ' + msgObj + ' to not increase'
        );
      }

      Assertion.addMethod('increase', assertIncreases);
      Assertion.addMethod('increases', assertIncreases);

      /**
       * ### .decrease(subject[, prop[, msg]])
       *
       * When one argument is provided, `.decrease` asserts that the given function
       * `subject` returns a lesser number when it's invoked after invoking the
       * target function compared to when it's invoked beforehand. `.decrease` also
       * causes all `.by` assertions that follow in the chain to assert how much
       * lesser of a number is returned. It's often best to assert that the return
       * value decreased by the expected amount, rather than asserting it decreased
       * by any amount.
       *
       *     var val = 1
       *       , subtractTwo = function () { val -= 2; }
       *       , getVal = function () { return val; };
       *
       *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
       *     expect(subtractTwo).to.decrease(getVal); // Not recommended
       *
       * When two arguments are provided, `.decrease` asserts that the value of the
       * given object `subject`'s `prop` property is lesser after invoking the
       * target function compared to beforehand. 
       *
       *     var myObj = {val: 1}
       *       , subtractTwo = function () { myObj.val -= 2; };
       *
       *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
       *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.decrease`. However, it's
       * dangerous to do so. The problem is that it creates uncertain expectations
       * by asserting that the subject either increases, or that it stays the same.
       * It's often best to identify the exact output that's expected, and then
       * write an assertion that only accepts that exact output.
       *
       * When the subject is expected to increase, it's often best to assert that it
       * increased by the expected amount.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
       *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
       * 
       * When the subject is expected to stay the same, it's often best to assert
       * exactly that.
       *
       *     var myObj = {val: 1}
       *       , noop = function () {};
       *
       *     expect(noop).to.not.change(myObj, 'val'); // Recommended
       *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
       *
       * `.decrease` accepts an optional `msg` argument which is a custom error
       * message to show when the assertion fails. The message can also be given as
       * the second argument to `expect`. When not providing two arguments, always
       * use the second form.
       *
       *     var myObj = {val: 1}
       *       , noop = function () {};
       *
       *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
       *
       *     var val = 1
       *       , noop = function () {}
       *       , getVal = function () { return val; };
       *
       *     expect(noop, 'nooo why fail??').to.decrease(getVal);
       *
       * The alias `.decreases` can be used interchangeably with `.decrease`.
       *
       * @name decrease
       * @alias decreases
       * @param {String|Function} subject
       * @param {String} prop name _optional_
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertDecreases (subject, prop, msg) {
        if (msg) flag(this, 'message', msg);
        var fn = flag(this, 'object')
          , flagMsg = flag(this, 'message')
          , ssfi = flag(this, 'ssfi');
        new Assertion(fn, flagMsg, ssfi, true).is.a('function');

        var initial;
        if (!prop) {
          new Assertion(subject, flagMsg, ssfi, true).is.a('function');
          initial = subject();
        } else {
          new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
          initial = subject[prop];
        }

        // Make sure that the target is a number
        new Assertion(initial, flagMsg, ssfi, true).is.a('number');

        fn();

        var final = prop === undefined || prop === null ? subject() : subject[prop];
        var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

        flag(this, 'deltaMsgObj', msgObj);
        flag(this, 'initialDeltaValue', initial);
        flag(this, 'finalDeltaValue', final);
        flag(this, 'deltaBehavior', 'decrease');
        flag(this, 'realDelta', initial - final);

        this.assert(
          final - initial < 0
          , 'expected ' + msgObj + ' to decrease'
          , 'expected ' + msgObj + ' to not decrease'
        );
      }

      Assertion.addMethod('decrease', assertDecreases);
      Assertion.addMethod('decreases', assertDecreases);

      /**
       * ### .by(delta[, msg])
       *
       * When following an `.increase` assertion in the chain, `.by` asserts that
       * the subject of the `.increase` assertion increased by the given `delta`.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(2);
       *
       * When following a `.decrease` assertion in the chain, `.by` asserts that the
       * subject of the `.decrease` assertion decreased by the given `delta`.
       *
       *     var myObj = {val: 1}
       *       , subtractTwo = function () { myObj.val -= 2; };
       *
       *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
       *
       * When following a `.change` assertion in the chain, `.by` asserts that the
       * subject of the `.change` assertion either increased or decreased by the
       * given `delta`. However, it's dangerous to use `.change.by`. The problem is
       * that it creates uncertain expectations. It's often best to identify the
       * exact output that's expected, and then write an assertion that only accepts
       * that exact output.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; }
       *       , subtractTwo = function () { myObj.val -= 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
       *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
       *
       *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
       *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
       *
       * Add `.not` earlier in the chain to negate `.by`. However, it's often best
       * to assert that the subject changed by its expected delta, rather than
       * asserting that it didn't change by one of countless unexpected deltas.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; };
       *
       *     // Recommended
       *     expect(addTwo).to.increase(myObj, 'val').by(2);
       *
       *     // Not recommended
       *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
       *
       * `.by` accepts an optional `msg` argument which is a custom error message to
       * show when the assertion fails. The message can also be given as the second
       * argument to `expect`.
       *
       *     var myObj = {val: 1}
       *       , addTwo = function () { myObj.val += 2; };
       *
       *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
       *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
       *
       * @name by
       * @param {Number} delta
       * @param {String} msg _optional_
       * @namespace BDD
       * @api public
       */

      function assertDelta(delta, msg) {
        if (msg) flag(this, 'message', msg);

        var msgObj = flag(this, 'deltaMsgObj');
        var initial = flag(this, 'initialDeltaValue');
        var final = flag(this, 'finalDeltaValue');
        var behavior = flag(this, 'deltaBehavior');
        var realDelta = flag(this, 'realDelta');

        var expression;
        if (behavior === 'change') {
          expression = Math.abs(final - initial) === Math.abs(delta);
        } else {
          expression = realDelta === Math.abs(delta);
        }

        this.assert(
          expression
          , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta
          , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta
        );
      }

      Assertion.addMethod('by', assertDelta);

      /**
       * ### .extensible
       *
       * Asserts that the target is extensible, which means that new properties can
       * be added to it. Primitives are never extensible.
       *
       *     expect({a: 1}).to.be.extensible;
       *
       * Add `.not` earlier in the chain to negate `.extensible`.
       *
       *     var nonExtensibleObject = Object.preventExtensions({})
       *       , sealedObject = Object.seal({})
       *       , frozenObject = Object.freeze({});
       *
       *     expect(nonExtensibleObject).to.not.be.extensible;
       *     expect(sealedObject).to.not.be.extensible;
       *     expect(frozenObject).to.not.be.extensible;
       *     expect(1).to.not.be.extensible;
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect(1, 'nooo why fail??').to.be.extensible;
       *
       * @name extensible
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('extensible', function() {
        var obj = flag(this, 'object');

        // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
        // The following provides ES6 behavior for ES5 environments.

        var isExtensible = obj === Object(obj) && Object.isExtensible(obj);

        this.assert(
          isExtensible
          , 'expected #{this} to be extensible'
          , 'expected #{this} to not be extensible'
        );
      });

      /**
       * ### .sealed
       *
       * Asserts that the target is sealed, which means that new properties can't be
       * added to it, and its existing properties can't be reconfigured or deleted.
       * However, it's possible that its existing properties can still be reassigned
       * to different values. Primitives are always sealed.
       *
       *     var sealedObject = Object.seal({});
       *     var frozenObject = Object.freeze({});
       *
       *     expect(sealedObject).to.be.sealed;
       *     expect(frozenObject).to.be.sealed;
       *     expect(1).to.be.sealed;
       *
       * Add `.not` earlier in the chain to negate `.sealed`.
       *
       *     expect({a: 1}).to.not.be.sealed;
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
       *
       * @name sealed
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('sealed', function() {
        var obj = flag(this, 'object');

        // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
        // The following provides ES6 behavior for ES5 environments.

        var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;

        this.assert(
          isSealed
          , 'expected #{this} to be sealed'
          , 'expected #{this} to not be sealed'
        );
      });

      /**
       * ### .frozen
       *
       * Asserts that the target is frozen, which means that new properties can't be
       * added to it, and its existing properties can't be reassigned to different
       * values, reconfigured, or deleted. Primitives are always frozen.
       *
       *     var frozenObject = Object.freeze({});
       *
       *     expect(frozenObject).to.be.frozen;
       *     expect(1).to.be.frozen;
       *
       * Add `.not` earlier in the chain to negate `.frozen`.
       *
       *     expect({a: 1}).to.not.be.frozen;
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
       *
       * @name frozen
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('frozen', function() {
        var obj = flag(this, 'object');

        // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
        // The following provides ES6 behavior for ES5 environments.

        var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;

        this.assert(
          isFrozen
          , 'expected #{this} to be frozen'
          , 'expected #{this} to not be frozen'
        );
      });

      /**
       * ### .finite
       *
       * Asserts that the target is a number, and isn't `NaN` or positive/negative
       * `Infinity`.
       *
       *     expect(1).to.be.finite;
       *
       * Add `.not` earlier in the chain to negate `.finite`. However, it's
       * dangerous to do so. The problem is that it creates uncertain expectations
       * by asserting that the subject either isn't a number, or that it's `NaN`, or
       * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
       * best to identify the exact output that's expected, and then write an
       * assertion that only accepts that exact output.
       *
       * When the target isn't expected to be a number, it's often best to assert
       * that it's the expected type, rather than asserting that it isn't one of
       * many unexpected types.
       *
       *     expect('foo').to.be.a('string'); // Recommended
       *     expect('foo').to.not.be.finite; // Not recommended
       *
       * When the target is expected to be `NaN`, it's often best to assert exactly
       * that.
       *
       *     expect(NaN).to.be.NaN; // Recommended
       *     expect(NaN).to.not.be.finite; // Not recommended
       *
       * When the target is expected to be positive infinity, it's often best to
       * assert exactly that.
       *
       *     expect(Infinity).to.equal(Infinity); // Recommended
       *     expect(Infinity).to.not.be.finite; // Not recommended
       *
       * When the target is expected to be negative infinity, it's often best to
       * assert exactly that.
       *
       *     expect(-Infinity).to.equal(-Infinity); // Recommended
       *     expect(-Infinity).to.not.be.finite; // Not recommended
       *
       * A custom error message can be given as the second argument to `expect`.
       *
       *     expect('foo', 'nooo why fail??').to.be.finite;
       *
       * @name finite
       * @namespace BDD
       * @api public
       */

      Assertion.addProperty('finite', function(msg) {
        var obj = flag(this, 'object');

        this.assert(
            typeof obj === "number" && isFinite(obj)
          , 'expected #{this} to be a finite number'
          , 'expected #{this} to not be a finite number'
        );
      });
    };

    /*!
     * chai
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var expect = function (chai, util$$1) {
      chai.expect = function (val, message) {
        return new chai.Assertion(val, message);
      };

      /**
       * ### .fail(actual, expected, [message], [operator])
       *
       * Throw a failure.
       *
       * @name fail
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @param {String} operator
       * @namespace BDD
       * @api public
       */

      chai.expect.fail = function (actual, expected, message, operator) {
        message = message || 'expect.fail()';
        throw new chai.AssertionError(message, {
            actual: actual
          , expected: expected
          , operator: operator
        }, chai.expect.fail);
      };
    };

    /*!
     * chai
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var should = function (chai, util$$1) {
      var Assertion = chai.Assertion;

      function loadShould () {
        // explicitly define this method as function as to have it's name to include as `ssfi`
        function shouldGetter() {
          if (this instanceof String
              || this instanceof Number
              || this instanceof Boolean
              || typeof Symbol === 'function' && this instanceof Symbol) {
            return new Assertion(this.valueOf(), null, shouldGetter);
          }
          return new Assertion(this, null, shouldGetter);
        }
        function shouldSetter(value) {
          // See https://github.com/chaijs/chai/issues/86: this makes
          // `whatever.should = someValue` actually set `someValue`, which is
          // especially useful for `global.should = require('chai').should()`.
          //
          // Note that we have to use [[DefineProperty]] instead of [[Put]]
          // since otherwise we would trigger this very setter!
          Object.defineProperty(this, 'should', {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        }
        // modify Object.prototype to have `should`
        Object.defineProperty(Object.prototype, 'should', {
          set: shouldSetter
          , get: shouldGetter
          , configurable: true
        });

        var should = {};

        /**
         * ### .fail(actual, expected, [message], [operator])
         *
         * Throw a failure.
         *
         * @name fail
         * @param {Mixed} actual
         * @param {Mixed} expected
         * @param {String} message
         * @param {String} operator
         * @namespace BDD
         * @api public
         */

        should.fail = function (actual, expected, message, operator) {
          message = message || 'should.fail()';
          throw new chai.AssertionError(message, {
              actual: actual
            , expected: expected
            , operator: operator
          }, should.fail);
        };

        /**
         * ### .equal(actual, expected, [message])
         *
         * Asserts non-strict equality (`==`) of `actual` and `expected`.
         *
         *     should.equal(3, '3', '== coerces values to strings');
         *
         * @name equal
         * @param {Mixed} actual
         * @param {Mixed} expected
         * @param {String} message
         * @namespace Should
         * @api public
         */

        should.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.equal(val2);
        };

        /**
         * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
         *
         * Asserts that `function` will throw an error that is an instance of
         * `constructor`, or alternately that it will throw an error with message
         * matching `regexp`.
         *
         *     should.throw(fn, 'function throws a reference error');
         *     should.throw(fn, /function throws a reference error/);
         *     should.throw(fn, ReferenceError);
         *     should.throw(fn, ReferenceError, 'function throws a reference error');
         *     should.throw(fn, ReferenceError, /function throws a reference error/);
         *
         * @name throw
         * @alias Throw
         * @param {Function} function
         * @param {ErrorConstructor} constructor
         * @param {RegExp} regexp
         * @param {String} message
         * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
         * @namespace Should
         * @api public
         */

        should.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.Throw(errt, errs);
        };

        /**
         * ### .exist
         *
         * Asserts that the target is neither `null` nor `undefined`.
         *
         *     var foo = 'hi';
         *
         *     should.exist(foo, 'foo exists');
         *
         * @name exist
         * @namespace Should
         * @api public
         */

        should.exist = function (val, msg) {
          new Assertion(val, msg).to.exist;
        };

        // negation
        should.not = {};

        /**
         * ### .not.equal(actual, expected, [message])
         *
         * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
         *
         *     should.not.equal(3, 4, 'these numbers are not equal');
         *
         * @name not.equal
         * @param {Mixed} actual
         * @param {Mixed} expected
         * @param {String} message
         * @namespace Should
         * @api public
         */

        should.not.equal = function (val1, val2, msg) {
          new Assertion(val1, msg).to.not.equal(val2);
        };

        /**
         * ### .throw(function, [constructor/regexp], [message])
         *
         * Asserts that `function` will _not_ throw an error that is an instance of
         * `constructor`, or alternately that it will not throw an error with message
         * matching `regexp`.
         *
         *     should.not.throw(fn, Error, 'function does not throw');
         *
         * @name not.throw
         * @alias not.Throw
         * @param {Function} function
         * @param {ErrorConstructor} constructor
         * @param {RegExp} regexp
         * @param {String} message
         * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
         * @namespace Should
         * @api public
         */

        should.not.Throw = function (fn, errt, errs, msg) {
          new Assertion(fn, msg).to.not.Throw(errt, errs);
        };

        /**
         * ### .not.exist
         *
         * Asserts that the target is neither `null` nor `undefined`.
         *
         *     var bar = null;
         *
         *     should.not.exist(bar, 'bar does not exist');
         *
         * @name not.exist
         * @namespace Should
         * @api public
         */

        should.not.exist = function (val, msg) {
          new Assertion(val, msg).to.not.exist;
        };

        should['throw'] = should['Throw'];
        should.not['throw'] = should.not['Throw'];

        return should;
      }
      chai.should = loadShould;
      chai.Should = loadShould;
    };

    /*!
     * chai
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */


    var assert$1 = function (chai, util$$1) {

      /*!
       * Chai dependencies.
       */

      var Assertion = chai.Assertion
        , flag = util$$1.flag;

      /*!
       * Module export.
       */

      /**
       * ### assert(expression, message)
       *
       * Write your own test expressions.
       *
       *     assert('foo' !== 'bar', 'foo is not bar');
       *     assert(Array.isArray([]), 'empty arrays are arrays');
       *
       * @param {Mixed} expression to test for truthiness
       * @param {String} message to display on error
       * @name assert
       * @namespace Assert
       * @api public
       */

      var assert$$1 = chai.assert = function (express, errmsg) {
        var test = new Assertion(null, null, chai.assert, true);
        test.assert(
            express
          , errmsg
          , '[ negation message unavailable ]'
        );
      };

      /**
       * ### .fail(actual, expected, [message], [operator])
       *
       * Throw a failure. Node.js `assert` module-compatible.
       *
       * @name fail
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @param {String} operator
       * @namespace Assert
       * @api public
       */

      assert$$1.fail = function (actual, expected, message, operator) {
        message = message || 'assert.fail()';
        throw new chai.AssertionError(message, {
            actual: actual
          , expected: expected
          , operator: operator
        }, assert$$1.fail);
      };

      /**
       * ### .isOk(object, [message])
       *
       * Asserts that `object` is truthy.
       *
       *     assert.isOk('everything', 'everything is ok');
       *     assert.isOk(false, 'this will fail');
       *
       * @name isOk
       * @alias ok
       * @param {Mixed} object to test
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isOk = function (val, msg) {
        new Assertion(val, msg, assert$$1.isOk, true).is.ok;
      };

      /**
       * ### .isNotOk(object, [message])
       *
       * Asserts that `object` is falsy.
       *
       *     assert.isNotOk('everything', 'this will fail');
       *     assert.isNotOk(false, 'this will pass');
       *
       * @name isNotOk
       * @alias notOk
       * @param {Mixed} object to test
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotOk = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotOk, true).is.not.ok;
      };

      /**
       * ### .equal(actual, expected, [message])
       *
       * Asserts non-strict equality (`==`) of `actual` and `expected`.
       *
       *     assert.equal(3, '3', '== coerces values to strings');
       *
       * @name equal
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.equal = function (act, exp, msg) {
        var test = new Assertion(act, msg, assert$$1.equal, true);

        test.assert(
            exp == flag(test, 'object')
          , 'expected #{this} to equal #{exp}'
          , 'expected #{this} to not equal #{act}'
          , exp
          , act
          , true
        );
      };

      /**
       * ### .notEqual(actual, expected, [message])
       *
       * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
       *
       *     assert.notEqual(3, 4, 'these numbers are not equal');
       *
       * @name notEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notEqual = function (act, exp, msg) {
        var test = new Assertion(act, msg, assert$$1.notEqual, true);

        test.assert(
            exp != flag(test, 'object')
          , 'expected #{this} to not equal #{exp}'
          , 'expected #{this} to equal #{act}'
          , exp
          , act
          , true
        );
      };

      /**
       * ### .strictEqual(actual, expected, [message])
       *
       * Asserts strict equality (`===`) of `actual` and `expected`.
       *
       *     assert.strictEqual(true, true, 'these booleans are strictly equal');
       *
       * @name strictEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.strictEqual = function (act, exp, msg) {
        new Assertion(act, msg, assert$$1.strictEqual, true).to.equal(exp);
      };

      /**
       * ### .notStrictEqual(actual, expected, [message])
       *
       * Asserts strict inequality (`!==`) of `actual` and `expected`.
       *
       *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
       *
       * @name notStrictEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notStrictEqual = function (act, exp, msg) {
        new Assertion(act, msg, assert$$1.notStrictEqual, true).to.not.equal(exp);
      };

      /**
       * ### .deepEqual(actual, expected, [message])
       *
       * Asserts that `actual` is deeply equal to `expected`.
       *
       *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
       *
       * @name deepEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @alias deepStrictEqual
       * @namespace Assert
       * @api public
       */

      assert$$1.deepEqual = assert$$1.deepStrictEqual = function (act, exp, msg) {
        new Assertion(act, msg, assert$$1.deepEqual, true).to.eql(exp);
      };

      /**
       * ### .notDeepEqual(actual, expected, [message])
       *
       * Assert that `actual` is not deeply equal to `expected`.
       *
       *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
       *
       * @name notDeepEqual
       * @param {Mixed} actual
       * @param {Mixed} expected
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notDeepEqual = function (act, exp, msg) {
        new Assertion(act, msg, assert$$1.notDeepEqual, true).to.not.eql(exp);
      };

       /**
       * ### .isAbove(valueToCheck, valueToBeAbove, [message])
       *
       * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
       *
       *     assert.isAbove(5, 2, '5 is strictly greater than 2');
       *
       * @name isAbove
       * @param {Mixed} valueToCheck
       * @param {Mixed} valueToBeAbove
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isAbove = function (val, abv, msg) {
        new Assertion(val, msg, assert$$1.isAbove, true).to.be.above(abv);
      };

       /**
       * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
       *
       * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
       *
       *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
       *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
       *
       * @name isAtLeast
       * @param {Mixed} valueToCheck
       * @param {Mixed} valueToBeAtLeast
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isAtLeast = function (val, atlst, msg) {
        new Assertion(val, msg, assert$$1.isAtLeast, true).to.be.least(atlst);
      };

       /**
       * ### .isBelow(valueToCheck, valueToBeBelow, [message])
       *
       * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
       *
       *     assert.isBelow(3, 6, '3 is strictly less than 6');
       *
       * @name isBelow
       * @param {Mixed} valueToCheck
       * @param {Mixed} valueToBeBelow
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isBelow = function (val, blw, msg) {
        new Assertion(val, msg, assert$$1.isBelow, true).to.be.below(blw);
      };

       /**
       * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
       *
       * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
       *
       *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
       *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
       *
       * @name isAtMost
       * @param {Mixed} valueToCheck
       * @param {Mixed} valueToBeAtMost
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isAtMost = function (val, atmst, msg) {
        new Assertion(val, msg, assert$$1.isAtMost, true).to.be.most(atmst);
      };

      /**
       * ### .isTrue(value, [message])
       *
       * Asserts that `value` is true.
       *
       *     var teaServed = true;
       *     assert.isTrue(teaServed, 'the tea has been served');
       *
       * @name isTrue
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isTrue = function (val, msg) {
        new Assertion(val, msg, assert$$1.isTrue, true).is['true'];
      };

      /**
       * ### .isNotTrue(value, [message])
       *
       * Asserts that `value` is not true.
       *
       *     var tea = 'tasty chai';
       *     assert.isNotTrue(tea, 'great, time for tea!');
       *
       * @name isNotTrue
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotTrue = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotTrue, true).to.not.equal(true);
      };

      /**
       * ### .isFalse(value, [message])
       *
       * Asserts that `value` is false.
       *
       *     var teaServed = false;
       *     assert.isFalse(teaServed, 'no tea yet? hmm...');
       *
       * @name isFalse
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isFalse = function (val, msg) {
        new Assertion(val, msg, assert$$1.isFalse, true).is['false'];
      };

      /**
       * ### .isNotFalse(value, [message])
       *
       * Asserts that `value` is not false.
       *
       *     var tea = 'tasty chai';
       *     assert.isNotFalse(tea, 'great, time for tea!');
       *
       * @name isNotFalse
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotFalse = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotFalse, true).to.not.equal(false);
      };

      /**
       * ### .isNull(value, [message])
       *
       * Asserts that `value` is null.
       *
       *     assert.isNull(err, 'there was no error');
       *
       * @name isNull
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNull = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNull, true).to.equal(null);
      };

      /**
       * ### .isNotNull(value, [message])
       *
       * Asserts that `value` is not null.
       *
       *     var tea = 'tasty chai';
       *     assert.isNotNull(tea, 'great, time for tea!');
       *
       * @name isNotNull
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotNull = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotNull, true).to.not.equal(null);
      };

      /**
       * ### .isNaN
       *
       * Asserts that value is NaN.
       *
       *     assert.isNaN(NaN, 'NaN is NaN');
       *
       * @name isNaN
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNaN = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNaN, true).to.be.NaN;
      };

      /**
       * ### .isNotNaN
       *
       * Asserts that value is not NaN.
       *
       *     assert.isNotNaN(4, '4 is not NaN');
       *
       * @name isNotNaN
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */
      assert$$1.isNotNaN = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotNaN, true).not.to.be.NaN;
      };

      /**
       * ### .exists
       *
       * Asserts that the target is neither `null` nor `undefined`.
       *
       *     var foo = 'hi';
       *
       *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
       *
       * @name exists
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.exists = function (val, msg) {
        new Assertion(val, msg, assert$$1.exists, true).to.exist;
      };

      /**
       * ### .notExists
       *
       * Asserts that the target is either `null` or `undefined`.
       *
       *     var bar = null
       *       , baz;
       *
       *     assert.notExists(bar);
       *     assert.notExists(baz, 'baz is either null or undefined');
       *
       * @name notExists
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notExists = function (val, msg) {
        new Assertion(val, msg, assert$$1.notExists, true).to.not.exist;
      };

      /**
       * ### .isUndefined(value, [message])
       *
       * Asserts that `value` is `undefined`.
       *
       *     var tea;
       *     assert.isUndefined(tea, 'no tea defined');
       *
       * @name isUndefined
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isUndefined = function (val, msg) {
        new Assertion(val, msg, assert$$1.isUndefined, true).to.equal(undefined);
      };

      /**
       * ### .isDefined(value, [message])
       *
       * Asserts that `value` is not `undefined`.
       *
       *     var tea = 'cup of chai';
       *     assert.isDefined(tea, 'tea has been defined');
       *
       * @name isDefined
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isDefined = function (val, msg) {
        new Assertion(val, msg, assert$$1.isDefined, true).to.not.equal(undefined);
      };

      /**
       * ### .isFunction(value, [message])
       *
       * Asserts that `value` is a function.
       *
       *     function serveTea() { return 'cup of tea'; };
       *     assert.isFunction(serveTea, 'great, we can have tea now');
       *
       * @name isFunction
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isFunction = function (val, msg) {
        new Assertion(val, msg, assert$$1.isFunction, true).to.be.a('function');
      };

      /**
       * ### .isNotFunction(value, [message])
       *
       * Asserts that `value` is _not_ a function.
       *
       *     var serveTea = [ 'heat', 'pour', 'sip' ];
       *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
       *
       * @name isNotFunction
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotFunction = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotFunction, true).to.not.be.a('function');
      };

      /**
       * ### .isObject(value, [message])
       *
       * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
       * _The assertion does not match subclassed objects._
       *
       *     var selection = { name: 'Chai', serve: 'with spices' };
       *     assert.isObject(selection, 'tea selection is an object');
       *
       * @name isObject
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isObject = function (val, msg) {
        new Assertion(val, msg, assert$$1.isObject, true).to.be.a('object');
      };

      /**
       * ### .isNotObject(value, [message])
       *
       * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
       *
       *     var selection = 'chai'
       *     assert.isNotObject(selection, 'tea selection is not an object');
       *     assert.isNotObject(null, 'null is not an object');
       *
       * @name isNotObject
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotObject = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotObject, true).to.not.be.a('object');
      };

      /**
       * ### .isArray(value, [message])
       *
       * Asserts that `value` is an array.
       *
       *     var menu = [ 'green', 'chai', 'oolong' ];
       *     assert.isArray(menu, 'what kind of tea do we want?');
       *
       * @name isArray
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isArray = function (val, msg) {
        new Assertion(val, msg, assert$$1.isArray, true).to.be.an('array');
      };

      /**
       * ### .isNotArray(value, [message])
       *
       * Asserts that `value` is _not_ an array.
       *
       *     var menu = 'green|chai|oolong';
       *     assert.isNotArray(menu, 'what kind of tea do we want?');
       *
       * @name isNotArray
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotArray = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotArray, true).to.not.be.an('array');
      };

      /**
       * ### .isString(value, [message])
       *
       * Asserts that `value` is a string.
       *
       *     var teaOrder = 'chai';
       *     assert.isString(teaOrder, 'order placed');
       *
       * @name isString
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isString = function (val, msg) {
        new Assertion(val, msg, assert$$1.isString, true).to.be.a('string');
      };

      /**
       * ### .isNotString(value, [message])
       *
       * Asserts that `value` is _not_ a string.
       *
       *     var teaOrder = 4;
       *     assert.isNotString(teaOrder, 'order placed');
       *
       * @name isNotString
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotString = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotString, true).to.not.be.a('string');
      };

      /**
       * ### .isNumber(value, [message])
       *
       * Asserts that `value` is a number.
       *
       *     var cups = 2;
       *     assert.isNumber(cups, 'how many cups');
       *
       * @name isNumber
       * @param {Number} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNumber = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNumber, true).to.be.a('number');
      };

      /**
       * ### .isNotNumber(value, [message])
       *
       * Asserts that `value` is _not_ a number.
       *
       *     var cups = '2 cups please';
       *     assert.isNotNumber(cups, 'how many cups');
       *
       * @name isNotNumber
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotNumber = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotNumber, true).to.not.be.a('number');
      };

       /**
       * ### .isFinite(value, [message])
       *
       * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
       *
       *     var cups = 2;
       *     assert.isFinite(cups, 'how many cups');
       *
       *     assert.isFinite(NaN); // throws
       *
       * @name isFinite
       * @param {Number} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isFinite = function (val, msg) {
        new Assertion(val, msg, assert$$1.isFinite, true).to.be.finite;
      };

      /**
       * ### .isBoolean(value, [message])
       *
       * Asserts that `value` is a boolean.
       *
       *     var teaReady = true
       *       , teaServed = false;
       *
       *     assert.isBoolean(teaReady, 'is the tea ready');
       *     assert.isBoolean(teaServed, 'has tea been served');
       *
       * @name isBoolean
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isBoolean = function (val, msg) {
        new Assertion(val, msg, assert$$1.isBoolean, true).to.be.a('boolean');
      };

      /**
       * ### .isNotBoolean(value, [message])
       *
       * Asserts that `value` is _not_ a boolean.
       *
       *     var teaReady = 'yep'
       *       , teaServed = 'nope';
       *
       *     assert.isNotBoolean(teaReady, 'is the tea ready');
       *     assert.isNotBoolean(teaServed, 'has tea been served');
       *
       * @name isNotBoolean
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotBoolean = function (val, msg) {
        new Assertion(val, msg, assert$$1.isNotBoolean, true).to.not.be.a('boolean');
      };

      /**
       * ### .typeOf(value, name, [message])
       *
       * Asserts that `value`'s type is `name`, as determined by
       * `Object.prototype.toString`.
       *
       *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
       *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
       *     assert.typeOf('tea', 'string', 'we have a string');
       *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
       *     assert.typeOf(null, 'null', 'we have a null');
       *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
       *
       * @name typeOf
       * @param {Mixed} value
       * @param {String} name
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.typeOf = function (val, type, msg) {
        new Assertion(val, msg, assert$$1.typeOf, true).to.be.a(type);
      };

      /**
       * ### .notTypeOf(value, name, [message])
       *
       * Asserts that `value`'s type is _not_ `name`, as determined by
       * `Object.prototype.toString`.
       *
       *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
       *
       * @name notTypeOf
       * @param {Mixed} value
       * @param {String} typeof name
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notTypeOf = function (val, type, msg) {
        new Assertion(val, msg, assert$$1.notTypeOf, true).to.not.be.a(type);
      };

      /**
       * ### .instanceOf(object, constructor, [message])
       *
       * Asserts that `value` is an instance of `constructor`.
       *
       *     var Tea = function (name) { this.name = name; }
       *       , chai = new Tea('chai');
       *
       *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
       *
       * @name instanceOf
       * @param {Object} object
       * @param {Constructor} constructor
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.instanceOf = function (val, type, msg) {
        new Assertion(val, msg, assert$$1.instanceOf, true).to.be.instanceOf(type);
      };

      /**
       * ### .notInstanceOf(object, constructor, [message])
       *
       * Asserts `value` is not an instance of `constructor`.
       *
       *     var Tea = function (name) { this.name = name; }
       *       , chai = new String('chai');
       *
       *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
       *
       * @name notInstanceOf
       * @param {Object} object
       * @param {Constructor} constructor
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notInstanceOf = function (val, type, msg) {
        new Assertion(val, msg, assert$$1.notInstanceOf, true)
          .to.not.be.instanceOf(type);
      };

      /**
       * ### .include(haystack, needle, [message])
       *
       * Asserts that `haystack` includes `needle`. Can be used to assert the
       * inclusion of a value in an array, a substring in a string, or a subset of
       * properties in an object.
       *
       *     assert.include([1,2,3], 2, 'array contains value');
       *     assert.include('foobar', 'foo', 'string contains substring');
       *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
       *
       * Strict equality (===) is used. When asserting the inclusion of a value in
       * an array, the array is searched for an element that's strictly equal to the
       * given value. When asserting a subset of properties in an object, the object
       * is searched for the given property keys, checking that each one is present
       * and stricty equal to the given property value. For instance:
       *
       *     var obj1 = {a: 1}
       *       , obj2 = {b: 2};
       *     assert.include([obj1, obj2], obj1);
       *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
       *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
       *
       * @name include
       * @param {Array|String} haystack
       * @param {Mixed} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.include = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.include, true).include(inc);
      };

      /**
       * ### .notInclude(haystack, needle, [message])
       *
       * Asserts that `haystack` does not include `needle`. Can be used to assert
       * the absence of a value in an array, a substring in a string, or a subset of
       * properties in an object.
       *
       *     assert.notInclude([1,2,3], 4, 'array doesn't contain value');
       *     assert.notInclude('foobar', 'baz', 'string doesn't contain substring');
       *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
       *
       * Strict equality (===) is used. When asserting the absence of a value in an
       * array, the array is searched to confirm the absence of an element that's
       * strictly equal to the given value. When asserting a subset of properties in
       * an object, the object is searched to confirm that at least one of the given
       * property keys is either not present or not strictly equal to the given
       * property value. For instance:
       *
       *     var obj1 = {a: 1}
       *       , obj2 = {b: 2};
       *     assert.notInclude([obj1, obj2], {a: 1});
       *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
       *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
       *
       * @name notInclude
       * @param {Array|String} haystack
       * @param {Mixed} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notInclude, true).not.include(inc);
      };

      /**
       * ### .deepInclude(haystack, needle, [message])
       *
       * Asserts that `haystack` includes `needle`. Can be used to assert the
       * inclusion of a value in an array or a subset of properties in an object.
       * Deep equality is used.
       *
       *     var obj1 = {a: 1}
       *       , obj2 = {b: 2};
       *     assert.deepInclude([obj1, obj2], {a: 1});
       *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
       *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
       *
       * @name deepInclude
       * @param {Array|String} haystack
       * @param {Mixed} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.deepInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.deepInclude, true).deep.include(inc);
      };

      /**
       * ### .notDeepInclude(haystack, needle, [message])
       *
       * Asserts that `haystack` does not include `needle`. Can be used to assert
       * the absence of a value in an array or a subset of properties in an object.
       * Deep equality is used.
       *
       *     var obj1 = {a: 1}
       *       , obj2 = {b: 2};
       *     assert.notDeepInclude([obj1, obj2], {a: 9});
       *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
       *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
       *
       * @name notDeepInclude
       * @param {Array|String} haystack
       * @param {Mixed} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notDeepInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notDeepInclude, true).not.deep.include(inc);
      };

      /**
       * ### .nestedInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'. 
       * Can be used to assert the inclusion of a subset of properties in an 
       * object.
       * Enables the use of dot- and bracket-notation for referencing nested 
       * properties.
       * '[]' and '.' in property names can be escaped using double backslashes.
       * 
       *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
       *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
       * 
       * @name nestedInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public 
       */ 

      assert$$1.nestedInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.nestedInclude, true).nested.include(inc);
      };

      /**
       * ### .notNestedInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' does not include 'needle'. 
       * Can be used to assert the absence of a subset of properties in an 
       * object.
       * Enables the use of dot- and bracket-notation for referencing nested 
       * properties. 
       * '[]' and '.' in property names can be escaped using double backslashes.
       * 
       *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
       *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
       * 
       * @name notNestedInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public 
       */ 

      assert$$1.notNestedInclude = function (exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notNestedInclude, true)
          .not.nested.include(inc);
      };

      /**
       * ### .deepNestedInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'.
       * Can be used to assert the inclusion of a subset of properties in an 
       * object while checking for deep equality.
       * Enables the use of dot- and bracket-notation for referencing nested 
       * properties.
       * '[]' and '.' in property names can be escaped using double backslashes.
       * 
       *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
       *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
       *    
       * @name deepNestedInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public 
       */

      assert$$1.deepNestedInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.deepNestedInclude, true)
          .deep.nested.include(inc);
      };

      /**
       * ### .notDeepNestedInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' does not include 'needle'.
       * Can be used to assert the absence of a subset of properties in an 
       * object while checking for deep equality.
       * Enables the use of dot- and bracket-notation for referencing nested 
       * properties.
       * '[]' and '.' in property names can be escaped using double backslashes.
       * 
       *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
       *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
       *    
       * @name notDeepNestedInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public 
       */

      assert$$1.notDeepNestedInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notDeepNestedInclude, true)
          .not.deep.nested.include(inc);
      };

      /**
       * ### .ownInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'.
       * Can be used to assert the inclusion of a subset of properties in an 
       * object while ignoring inherited properties.
       * 
       *     assert.ownInclude({ a: 1 }, { a: 1 });
       * 
       * @name ownInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.ownInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.ownInclude, true).own.include(inc);
      };

      /**
       * ### .notOwnInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'.
       * Can be used to assert the absence of a subset of properties in an 
       * object while ignoring inherited properties.
       * 
       *     Object.prototype.b = 2;
       * 
       *     assert.notOwnInclude({ a: 1 }, { b: 2 });
       * 
       * @name notOwnInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notOwnInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notOwnInclude, true).not.own.include(inc);
      };

      /**
       * ### .deepOwnInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'.
       * Can be used to assert the inclusion of a subset of properties in an 
       * object while ignoring inherited properties and checking for deep equality.
       * 
       *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
       *      
       * @name deepOwnInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.deepOwnInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.deepOwnInclude, true)
          .deep.own.include(inc);
      };

       /**
       * ### .notDeepOwnInclude(haystack, needle, [message])
       * 
       * Asserts that 'haystack' includes 'needle'.
       * Can be used to assert the absence of a subset of properties in an 
       * object while ignoring inherited properties and checking for deep equality.
       * 
       *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
       *      
       * @name notDeepOwnInclude
       * @param {Object} haystack
       * @param {Object} needle
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notDeepOwnInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert$$1.notDeepOwnInclude, true)
          .not.deep.own.include(inc);
      };

      /**
       * ### .match(value, regexp, [message])
       *
       * Asserts that `value` matches the regular expression `regexp`.
       *
       *     assert.match('foobar', /^foo/, 'regexp matches');
       *
       * @name match
       * @param {Mixed} value
       * @param {RegExp} regexp
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.match = function (exp, re, msg) {
        new Assertion(exp, msg, assert$$1.match, true).to.match(re);
      };

      /**
       * ### .notMatch(value, regexp, [message])
       *
       * Asserts that `value` does not match the regular expression `regexp`.
       *
       *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
       *
       * @name notMatch
       * @param {Mixed} value
       * @param {RegExp} regexp
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notMatch = function (exp, re, msg) {
        new Assertion(exp, msg, assert$$1.notMatch, true).to.not.match(re);
      };

      /**
       * ### .property(object, property, [message])
       *
       * Asserts that `object` has a direct or inherited property named by
       * `property`.
       *
       *     assert.property({ tea: { green: 'matcha' }}, 'tea');
       *     assert.property({ tea: { green: 'matcha' }}, 'toString');
       *
       * @name property
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.property = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.property, true).to.have.property(prop);
      };

      /**
       * ### .notProperty(object, property, [message])
       *
       * Asserts that `object` does _not_ have a direct or inherited property named
       * by `property`.
       *
       *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
       *
       * @name notProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notProperty = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.notProperty, true)
          .to.not.have.property(prop);
      };

      /**
       * ### .propertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a direct or inherited property named by
       * `property` with a value given by `value`. Uses a strict equality check
       * (===).
       *
       *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
       *
       * @name propertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.propertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.propertyVal, true)
          .to.have.property(prop, val);
      };

      /**
       * ### .notPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a direct or inherited property named
       * by `property` with value given by `value`. Uses a strict equality check
       * (===).
       *
       *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
       *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
       *
       * @name notPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.notPropertyVal, true)
          .to.not.have.property(prop, val);
      };

      /**
       * ### .deepPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a direct or inherited property named by
       * `property` with a value given by `value`. Uses a deep equality check.
       *
       *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
       *
       * @name deepPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.deepPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.deepPropertyVal, true)
          .to.have.deep.property(prop, val);
      };

      /**
       * ### .notDeepPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a direct or inherited property named
       * by `property` with value given by `value`. Uses a deep equality check.
       *
       *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
       *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
       *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
       *
       * @name notDeepPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notDeepPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.notDeepPropertyVal, true)
          .to.not.have.deep.property(prop, val);
      };

      /**
       * ### .ownProperty(object, property, [message])
       *
       * Asserts that `object` has a direct property named by `property`. Inherited
       * properties aren't checked.
       *
       *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
       *
       * @name ownProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert$$1.ownProperty = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.ownProperty, true)
          .to.have.own.property(prop);
      };

      /**
       * ### .notOwnProperty(object, property, [message])
       *
       * Asserts that `object` does _not_ have a direct property named by
       * `property`. Inherited properties aren't checked.
       *
       *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
       *     assert.notOwnProperty({}, 'toString');
       *
       * @name notOwnProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @api public
       */

      assert$$1.notOwnProperty = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.notOwnProperty, true)
          .to.not.have.own.property(prop);
      };

      /**
       * ### .ownPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a direct property named by `property` and a value
       * equal to the provided `value`. Uses a strict equality check (===).
       * Inherited properties aren't checked.
       *
       *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
       *
       * @name ownPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert$$1.ownPropertyVal = function (obj, prop, value, msg) {
        new Assertion(obj, msg, assert$$1.ownPropertyVal, true)
          .to.have.own.property(prop, value);
      };

      /**
       * ### .notOwnPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a direct property named by `property`
       * with a value equal to the provided `value`. Uses a strict equality check
       * (===). Inherited properties aren't checked.
       *
       *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
       *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
       *
       * @name notOwnPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert$$1.notOwnPropertyVal = function (obj, prop, value, msg) {
        new Assertion(obj, msg, assert$$1.notOwnPropertyVal, true)
          .to.not.have.own.property(prop, value);
      };

      /**
       * ### .deepOwnPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a direct property named by `property` and a value
       * equal to the provided `value`. Uses a deep equality check. Inherited
       * properties aren't checked.
       *
       *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
       *
       * @name deepOwnPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert$$1.deepOwnPropertyVal = function (obj, prop, value, msg) {
        new Assertion(obj, msg, assert$$1.deepOwnPropertyVal, true)
          .to.have.deep.own.property(prop, value);
      };

      /**
       * ### .notDeepOwnPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a direct property named by `property`
       * with a value equal to the provided `value`. Uses a deep equality check.
       * Inherited properties aren't checked.
       *
       *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
       *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
       *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
       *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
       *
       * @name notDeepOwnPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @api public
       */

      assert$$1.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
        new Assertion(obj, msg, assert$$1.notDeepOwnPropertyVal, true)
          .to.not.have.deep.own.property(prop, value);
      };

      /**
       * ### .nestedProperty(object, property, [message])
       *
       * Asserts that `object` has a direct or inherited property named by
       * `property`, which can be a string using dot- and bracket-notation for
       * nested reference.
       *
       *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
       *
       * @name nestedProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.nestedProperty = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.nestedProperty, true)
          .to.have.nested.property(prop);
      };

      /**
       * ### .notNestedProperty(object, property, [message])
       *
       * Asserts that `object` does _not_ have a property named by `property`, which
       * can be a string using dot- and bracket-notation for nested reference. The
       * property cannot exist on the object nor anywhere in its prototype chain.
       *
       *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
       *
       * @name notNestedProperty
       * @param {Object} object
       * @param {String} property
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notNestedProperty = function (obj, prop, msg) {
        new Assertion(obj, msg, assert$$1.notNestedProperty, true)
          .to.not.have.nested.property(prop);
      };

      /**
       * ### .nestedPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property` with value given
       * by `value`. `property` can use dot- and bracket-notation for nested
       * reference. Uses a strict equality check (===).
       *
       *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
       *
       * @name nestedPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.nestedPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.nestedPropertyVal, true)
          .to.have.nested.property(prop, val);
      };

      /**
       * ### .notNestedPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a property named by `property` with
       * value given by `value`. `property` can use dot- and bracket-notation for
       * nested reference. Uses a strict equality check (===).
       *
       *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
       *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
       *
       * @name notNestedPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notNestedPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.notNestedPropertyVal, true)
          .to.not.have.nested.property(prop, val);
      };

      /**
       * ### .deepNestedPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` has a property named by `property` with a value given
       * by `value`. `property` can use dot- and bracket-notation for nested
       * reference. Uses a deep equality check.
       *
       *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
       *
       * @name deepNestedPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.deepNestedPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.deepNestedPropertyVal, true)
          .to.have.deep.nested.property(prop, val);
      };

      /**
       * ### .notDeepNestedPropertyVal(object, property, value, [message])
       *
       * Asserts that `object` does _not_ have a property named by `property` with
       * value given by `value`. `property` can use dot- and bracket-notation for
       * nested reference. Uses a deep equality check.
       *
       *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
       *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
       *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
       *
       * @name notDeepNestedPropertyVal
       * @param {Object} object
       * @param {String} property
       * @param {Mixed} value
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
        new Assertion(obj, msg, assert$$1.notDeepNestedPropertyVal, true)
          .to.not.have.deep.nested.property(prop, val);
      };

      /**
       * ### .lengthOf(object, length, [message])
       *
       * Asserts that `object` has a `length` property with the expected value.
       *
       *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
       *     assert.lengthOf('foobar', 6, 'string has length of 6');
       *
       * @name lengthOf
       * @param {Mixed} object
       * @param {Number} length
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.lengthOf = function (exp, len, msg) {
        new Assertion(exp, msg, assert$$1.lengthOf, true).to.have.lengthOf(len);
      };

      /**
       * ### .hasAnyKeys(object, [keys], [message])
       *
       * Asserts that `object` has at least one of the `keys` provided.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
       *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
       *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
       *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
       *
       * @name hasAnyKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.hasAnyKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.hasAnyKeys, true).to.have.any.keys(keys);
      };

      /**
       * ### .hasAllKeys(object, [keys], [message])
       *
       * Asserts that `object` has all and only all of the `keys` provided.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
       *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
       *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
       *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
       *
       * @name hasAllKeys
       * @param {Mixed} object
       * @param {String[]} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.hasAllKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.hasAllKeys, true).to.have.all.keys(keys);
      };

      /**
       * ### .containsAllKeys(object, [keys], [message])
       *
       * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
       *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
       *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
       *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
       *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
       *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
       *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
       *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
       *
       * @name containsAllKeys
       * @param {Mixed} object
       * @param {String[]} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.containsAllKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.containsAllKeys, true)
          .to.contain.all.keys(keys);
      };

      /**
       * ### .doesNotHaveAnyKeys(object, [keys], [message])
       *
       * Asserts that `object` has none of the `keys` provided.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
       *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
       *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
       *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
       *
       * @name doesNotHaveAnyKeys
       * @param {Mixed} object
       * @param {String[]} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotHaveAnyKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.doesNotHaveAnyKeys, true)
          .to.not.have.any.keys(keys);
      };

      /**
       * ### .doesNotHaveAllKeys(object, [keys], [message])
       *
       * Asserts that `object` does not have at least one of the `keys` provided.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
       *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
       *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
       *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
       *
       * @name doesNotHaveAllKeys
       * @param {Mixed} object
       * @param {String[]} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotHaveAllKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.doesNotHaveAllKeys, true)
          .to.not.have.all.keys(keys);
      };

      /**
       * ### .hasAnyDeepKeys(object, [keys], [message])
       *
       * Asserts that `object` has at least one of the `keys` provided.
       * Since Sets and Maps can have objects as keys you can use this assertion to perform
       * a deep comparison.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
       *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
       *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
       *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
       *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
       *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
       *
       * @name doesNotHaveAllKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.hasAnyDeepKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.hasAnyDeepKeys, true)
          .to.have.any.deep.keys(keys);
      };

     /**
       * ### .hasAllDeepKeys(object, [keys], [message])
       *
       * Asserts that `object` has all and only all of the `keys` provided.
       * Since Sets and Maps can have objects as keys you can use this assertion to perform
       * a deep comparison.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
       *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
       *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
       *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
       *
       * @name hasAllDeepKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.hasAllDeepKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.hasAllDeepKeys, true)
          .to.have.all.deep.keys(keys);
      };

     /**
       * ### .containsAllDeepKeys(object, [keys], [message])
       *
       * Asserts that `object` contains all of the `keys` provided.
       * Since Sets and Maps can have objects as keys you can use this assertion to perform
       * a deep comparison.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
       *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
       *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
       *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
       *
       * @name containsAllDeepKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.containsAllDeepKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.containsAllDeepKeys, true)
          .to.contain.all.deep.keys(keys);
      };

     /**
       * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
       *
       * Asserts that `object` has none of the `keys` provided.
       * Since Sets and Maps can have objects as keys you can use this assertion to perform
       * a deep comparison.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
       *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
       *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
       *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
       *
       * @name doesNotHaveAnyDeepKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.doesNotHaveAnyDeepKeys, true)
          .to.not.have.any.deep.keys(keys);
      };

     /**
       * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
       *
       * Asserts that `object` does not have at least one of the `keys` provided.
       * Since Sets and Maps can have objects as keys you can use this assertion to perform
       * a deep comparison.
       * You can also provide a single object instead of a `keys` array and its keys
       * will be used as the expected set of keys.
       *
       *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
       *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
       *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
       *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
       *
       * @name doesNotHaveAllDeepKeys
       * @param {Mixed} object
       * @param {Array|Object} keys
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
        new Assertion(obj, msg, assert$$1.doesNotHaveAllDeepKeys, true)
          .to.not.have.all.deep.keys(keys);
      };

     /**
       * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
       *
       * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
       * instance of `errorLike`.
       * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
       * instance as `errorLike`.
       * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
       * message matching `errMsgMatcher`.
       *
       *     assert.throws(fn, 'function throws a reference error');
       *     assert.throws(fn, /function throws a reference error/);
       *     assert.throws(fn, ReferenceError);
       *     assert.throws(fn, errorInstance);
       *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
       *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
       *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
       *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
       *
       * @name throws
       * @alias throw
       * @alias Throw
       * @param {Function} fn
       * @param {ErrorConstructor|Error} errorLike
       * @param {RegExp|String} errMsgMatcher
       * @param {String} message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @namespace Assert
       * @api public
       */

      assert$$1.throws = function (fn, errorLike, errMsgMatcher, msg) {
        if ('string' === typeof errorLike || errorLike instanceof RegExp) {
          errMsgMatcher = errorLike;
          errorLike = null;
        }

        var assertErr = new Assertion(fn, msg, assert$$1.throws, true)
          .to.throw(errorLike, errMsgMatcher);
        return flag(assertErr, 'object');
      };

      /**
       * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
       *
       * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
       * instance of `errorLike`.
       * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
       * instance as `errorLike`.
       * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
       * message matching `errMsgMatcher`.
       *
       *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
       *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
       *     assert.doesNotThrow(fn, Error);
       *     assert.doesNotThrow(fn, errorInstance);
       *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
       *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
       *     assert.doesNotThrow(fn, Error, /Error must not match this/);
       *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
       *
       * @name doesNotThrow
       * @param {Function} fn
       * @param {ErrorConstructor} errorLike
       * @param {RegExp|String} errMsgMatcher
       * @param {String} message
       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
        if ('string' === typeof errorLike || errorLike instanceof RegExp) {
          errMsgMatcher = errorLike;
          errorLike = null;
        }

        new Assertion(fn, msg, assert$$1.doesNotThrow, true)
          .to.not.throw(errorLike, errMsgMatcher);
      };

      /**
       * ### .operator(val1, operator, val2, [message])
       *
       * Compares two values using `operator`.
       *
       *     assert.operator(1, '<', 2, 'everything is ok');
       *     assert.operator(1, '>', 2, 'this will fail');
       *
       * @name operator
       * @param {Mixed} val1
       * @param {String} operator
       * @param {Mixed} val2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.operator = function (val, operator, val2, msg) {
        var ok;
        switch(operator) {
          case '==':
            ok = val == val2;
            break;
          case '===':
            ok = val === val2;
            break;
          case '>':
            ok = val > val2;
            break;
          case '>=':
            ok = val >= val2;
            break;
          case '<':
            ok = val < val2;
            break;
          case '<=':
            ok = val <= val2;
            break;
          case '!=':
            ok = val != val2;
            break;
          case '!==':
            ok = val !== val2;
            break;
          default:
            msg = msg ? msg + ': ' : msg;
            throw new chai.AssertionError(
              msg + 'Invalid operator "' + operator + '"',
              undefined,
              assert$$1.operator
            );
        }
        var test = new Assertion(ok, msg, assert$$1.operator, true);
        test.assert(
            true === flag(test, 'object')
          , 'expected ' + util$$1.inspect(val) + ' to be ' + operator + ' ' + util$$1.inspect(val2)
          , 'expected ' + util$$1.inspect(val) + ' to not be ' + operator + ' ' + util$$1.inspect(val2) );
      };

      /**
       * ### .closeTo(actual, expected, delta, [message])
       *
       * Asserts that the target is equal `expected`, to within a +/- `delta` range.
       *
       *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
       *
       * @name closeTo
       * @param {Number} actual
       * @param {Number} expected
       * @param {Number} delta
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.closeTo = function (act, exp, delta, msg) {
        new Assertion(act, msg, assert$$1.closeTo, true).to.be.closeTo(exp, delta);
      };

      /**
       * ### .approximately(actual, expected, delta, [message])
       *
       * Asserts that the target is equal `expected`, to within a +/- `delta` range.
       *
       *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
       *
       * @name approximately
       * @param {Number} actual
       * @param {Number} expected
       * @param {Number} delta
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.approximately = function (act, exp, delta, msg) {
        new Assertion(act, msg, assert$$1.approximately, true)
          .to.be.approximately(exp, delta);
      };

      /**
       * ### .sameMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` have the same members in any order. Uses a
       * strict equality check (===).
       *
       *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
       *
       * @name sameMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.sameMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.sameMembers, true)
          .to.have.same.members(set2);
      };

      /**
       * ### .notSameMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` don't have the same members in any order.
       * Uses a strict equality check (===).
       *
       *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
       *
       * @name notSameMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notSameMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.notSameMembers, true)
          .to.not.have.same.members(set2);
      };

      /**
       * ### .sameDeepMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` have the same members in any order. Uses a
       * deep equality check.
       *
       *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
       *
       * @name sameDeepMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.sameDeepMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.sameDeepMembers, true)
          .to.have.same.deep.members(set2);
      };

      /**
       * ### .notSameDeepMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` don't have the same members in any order.
       * Uses a deep equality check.
       *
       *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
       *
       * @name notSameDeepMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notSameDeepMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.notSameDeepMembers, true)
          .to.not.have.same.deep.members(set2);
      };

      /**
       * ### .sameOrderedMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` have the same members in the same order.
       * Uses a strict equality check (===).
       *
       *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
       *
       * @name sameOrderedMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.sameOrderedMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.sameOrderedMembers, true)
          .to.have.same.ordered.members(set2);
      };

      /**
       * ### .notSameOrderedMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` don't have the same members in the same
       * order. Uses a strict equality check (===).
       *
       *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
       *
       * @name notSameOrderedMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notSameOrderedMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.notSameOrderedMembers, true)
          .to.not.have.same.ordered.members(set2);
      };

      /**
       * ### .sameDeepOrderedMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` have the same members in the same order.
       * Uses a deep equality check.
       *
       * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
       *
       * @name sameDeepOrderedMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.sameDeepOrderedMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.sameDeepOrderedMembers, true)
          .to.have.same.deep.ordered.members(set2);
      };

      /**
       * ### .notSameDeepOrderedMembers(set1, set2, [message])
       *
       * Asserts that `set1` and `set2` don't have the same members in the same
       * order. Uses a deep equality check.
       *
       * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
       * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
       *
       * @name notSameDeepOrderedMembers
       * @param {Array} set1
       * @param {Array} set2
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notSameDeepOrderedMembers = function (set1, set2, msg) {
        new Assertion(set1, msg, assert$$1.notSameDeepOrderedMembers, true)
          .to.not.have.same.deep.ordered.members(set2);
      };

      /**
       * ### .includeMembers(superset, subset, [message])
       *
       * Asserts that `subset` is included in `superset` in any order. Uses a
       * strict equality check (===). Duplicates are ignored.
       *
       *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
       *
       * @name includeMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.includeMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.includeMembers, true)
          .to.include.members(subset);
      };

      /**
       * ### .notIncludeMembers(superset, subset, [message])
       *
       * Asserts that `subset` isn't included in `superset` in any order. Uses a
       * strict equality check (===). Duplicates are ignored.
       *
       *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
       *
       * @name notIncludeMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notIncludeMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.notIncludeMembers, true)
          .to.not.include.members(subset);
      };

      /**
       * ### .includeDeepMembers(superset, subset, [message])
       *
       * Asserts that `subset` is included in `superset` in any order. Uses a deep
       * equality check. Duplicates are ignored.
       *
       *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
       *
       * @name includeDeepMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.includeDeepMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.includeDeepMembers, true)
          .to.include.deep.members(subset);
      };

      /**
       * ### .notIncludeDeepMembers(superset, subset, [message])
       *
       * Asserts that `subset` isn't included in `superset` in any order. Uses a
       * deep equality check. Duplicates are ignored.
       *
       *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
       *
       * @name notIncludeDeepMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notIncludeDeepMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.notIncludeDeepMembers, true)
          .to.not.include.deep.members(subset);
      };

      /**
       * ### .includeOrderedMembers(superset, subset, [message])
       *
       * Asserts that `subset` is included in `superset` in the same order
       * beginning with the first element in `superset`. Uses a strict equality
       * check (===).
       *
       *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
       *
       * @name includeOrderedMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.includeOrderedMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.includeOrderedMembers, true)
          .to.include.ordered.members(subset);
      };

      /**
       * ### .notIncludeOrderedMembers(superset, subset, [message])
       *
       * Asserts that `subset` isn't included in `superset` in the same order
       * beginning with the first element in `superset`. Uses a strict equality
       * check (===).
       *
       *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
       *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
       *
       * @name notIncludeOrderedMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notIncludeOrderedMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.notIncludeOrderedMembers, true)
          .to.not.include.ordered.members(subset);
      };

      /**
       * ### .includeDeepOrderedMembers(superset, subset, [message])
       *
       * Asserts that `subset` is included in `superset` in the same order
       * beginning with the first element in `superset`. Uses a deep equality
       * check.
       *
       *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
       *
       * @name includeDeepOrderedMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.includeDeepOrderedMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.includeDeepOrderedMembers, true)
          .to.include.deep.ordered.members(subset);
      };

      /**
       * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
       *
       * Asserts that `subset` isn't included in `superset` in the same order
       * beginning with the first element in `superset`. Uses a deep equality
       * check.
       *
       *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
       *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
       *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
       *
       * @name notIncludeDeepOrderedMembers
       * @param {Array} superset
       * @param {Array} subset
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
        new Assertion(superset, msg, assert$$1.notIncludeDeepOrderedMembers, true)
          .to.not.include.deep.ordered.members(subset);
      };

      /**
       * ### .oneOf(inList, list, [message])
       *
       * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
       *
       *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
       *
       * @name oneOf
       * @param {*} inList
       * @param {Array<*>} list
       * @param {String} message
       * @namespace Assert
       * @api public
       */

      assert$$1.oneOf = function (inList, list, msg) {
        new Assertion(inList, msg, assert$$1.oneOf, true).to.be.oneOf(list);
      };

      /**
       * ### .changes(function, object, property, [message])
       *
       * Asserts that a function changes the value of a property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 22 };
       *     assert.changes(fn, obj, 'val');
       *
       * @name changes
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.changes = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.changes, true).to.change(obj, prop);
      };

       /**
       * ### .changesBy(function, object, property, delta, [message])
       *
       * Asserts that a function changes the value of a property by an amount (delta).
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val += 2 };
       *     assert.changesBy(fn, obj, 'val', 2);
       *
       * @name changesBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.changesBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.changesBy, true)
          .to.change(obj, prop).by(delta);
      };

       /**
       * ### .doesNotChange(function, object, property, [message])
       *
       * Asserts that a function does not change the value of a property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { console.log('foo'); };
       *     assert.doesNotChange(fn, obj, 'val');
       *
       * @name doesNotChange
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotChange = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.doesNotChange, true)
          .to.not.change(obj, prop);
      };

      /**
       * ### .changesButNotBy(function, object, property, delta, [message])
       *
       * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val += 10 };
       *     assert.changesButNotBy(fn, obj, 'val', 5);
       *
       * @name changesButNotBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.changesButNotBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.changesButNotBy, true)
          .to.change(obj, prop).but.not.by(delta);
      };

      /**
       * ### .increases(function, object, property, [message])
       *
       * Asserts that a function increases a numeric object property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 13 };
       *     assert.increases(fn, obj, 'val');
       *
       * @name increases
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.increases = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.increases, true)
          .to.increase(obj, prop);
      };

      /**
       * ### .increasesBy(function, object, property, delta, [message])
       *
       * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val += 10 };
       *     assert.increasesBy(fn, obj, 'val', 10);
       *
       * @name increasesBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.increasesBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.increasesBy, true)
          .to.increase(obj, prop).by(delta);
      };

      /**
       * ### .doesNotIncrease(function, object, property, [message])
       *
       * Asserts that a function does not increase a numeric object property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 8 };
       *     assert.doesNotIncrease(fn, obj, 'val');
       *
       * @name doesNotIncrease
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotIncrease = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.doesNotIncrease, true)
          .to.not.increase(obj, prop);
      };

      /**
       * ### .increasesButNotBy(function, object, property, [message])
       *
       * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 15 };
       *     assert.increasesButNotBy(fn, obj, 'val', 10);
       *
       * @name increasesButNotBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.increasesButNotBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.increasesButNotBy, true)
          .to.increase(obj, prop).but.not.by(delta);
      };

      /**
       * ### .decreases(function, object, property, [message])
       *
       * Asserts that a function decreases a numeric object property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 5 };
       *     assert.decreases(fn, obj, 'val');
       *
       * @name decreases
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.decreases = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.decreases, true)
          .to.decrease(obj, prop);
      };

      /**
       * ### .decreasesBy(function, object, property, delta, [message])
       *
       * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val -= 5 };
       *     assert.decreasesBy(fn, obj, 'val', 5);
       *
       * @name decreasesBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.decreasesBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.decreasesBy, true)
          .to.decrease(obj, prop).by(delta);
      };

      /**
       * ### .doesNotDecrease(function, object, property, [message])
       *
       * Asserts that a function does not decreases a numeric object property.
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 15 };
       *     assert.doesNotDecrease(fn, obj, 'val');
       *
       * @name doesNotDecrease
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotDecrease = function (fn, obj, prop, msg) {
        if (arguments.length === 3 && typeof obj === 'function') {
          msg = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.doesNotDecrease, true)
          .to.not.decrease(obj, prop);
      };

      /**
       * ### .doesNotDecreaseBy(function, object, property, delta, [message])
       *
       * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 5 };
       *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
       *
       * @name doesNotDecrease
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        return new Assertion(fn, msg, assert$$1.doesNotDecreaseBy, true)
          .to.not.decrease(obj, prop).by(delta);
      };

      /**
       * ### .decreasesButNotBy(function, object, property, delta, [message])
       *
       * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
       *
       *     var obj = { val: 10 };
       *     var fn = function() { obj.val = 5 };
       *     assert.decreasesButNotBy(fn, obj, 'val', 1);
       *
       * @name decreasesButNotBy
       * @param {Function} modifier function
       * @param {Object} object or getter function
       * @param {String} property name _optional_
       * @param {Number} change amount (delta)
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
        if (arguments.length === 4 && typeof obj === 'function') {
          var tmpMsg = delta;
          delta = prop;
          msg = tmpMsg;
        } else if (arguments.length === 3) {
          delta = prop;
          prop = null;
        }

        new Assertion(fn, msg, assert$$1.decreasesButNotBy, true)
          .to.decrease(obj, prop).but.not.by(delta);
      };

      /*!
       * ### .ifError(object)
       *
       * Asserts if value is not a false value, and throws if it is a true value.
       * This is added to allow for chai to be a drop-in replacement for Node's
       * assert class.
       *
       *     var err = new Error('I am a custom error');
       *     assert.ifError(err); // Rethrows err!
       *
       * @name ifError
       * @param {Object} object
       * @namespace Assert
       * @api public
       */

      assert$$1.ifError = function (val) {
        if (val) {
          throw(val);
        }
      };

      /**
       * ### .isExtensible(object)
       *
       * Asserts that `object` is extensible (can have new properties added to it).
       *
       *     assert.isExtensible({});
       *
       * @name isExtensible
       * @alias extensible
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isExtensible = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isExtensible, true).to.be.extensible;
      };

      /**
       * ### .isNotExtensible(object)
       *
       * Asserts that `object` is _not_ extensible.
       *
       *     var nonExtensibleObject = Object.preventExtensions({});
       *     var sealedObject = Object.seal({});
       *     var frozenObject = Object.freeze({});
       *
       *     assert.isNotExtensible(nonExtensibleObject);
       *     assert.isNotExtensible(sealedObject);
       *     assert.isNotExtensible(frozenObject);
       *
       * @name isNotExtensible
       * @alias notExtensible
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotExtensible = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isNotExtensible, true).to.not.be.extensible;
      };

      /**
       * ### .isSealed(object)
       *
       * Asserts that `object` is sealed (cannot have new properties added to it
       * and its existing properties cannot be removed).
       *
       *     var sealedObject = Object.seal({});
       *     var frozenObject = Object.seal({});
       *
       *     assert.isSealed(sealedObject);
       *     assert.isSealed(frozenObject);
       *
       * @name isSealed
       * @alias sealed
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isSealed = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isSealed, true).to.be.sealed;
      };

      /**
       * ### .isNotSealed(object)
       *
       * Asserts that `object` is _not_ sealed.
       *
       *     assert.isNotSealed({});
       *
       * @name isNotSealed
       * @alias notSealed
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotSealed = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isNotSealed, true).to.not.be.sealed;
      };

      /**
       * ### .isFrozen(object)
       *
       * Asserts that `object` is frozen (cannot have new properties added to it
       * and its existing properties cannot be modified).
       *
       *     var frozenObject = Object.freeze({});
       *     assert.frozen(frozenObject);
       *
       * @name isFrozen
       * @alias frozen
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isFrozen = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isFrozen, true).to.be.frozen;
      };

      /**
       * ### .isNotFrozen(object)
       *
       * Asserts that `object` is _not_ frozen.
       *
       *     assert.isNotFrozen({});
       *
       * @name isNotFrozen
       * @alias notFrozen
       * @param {Object} object
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotFrozen = function (obj, msg) {
        new Assertion(obj, msg, assert$$1.isNotFrozen, true).to.not.be.frozen;
      };

      /**
       * ### .isEmpty(target)
       *
       * Asserts that the target does not contain any values.
       * For arrays and strings, it checks the `length` property.
       * For `Map` and `Set` instances, it checks the `size` property.
       * For non-function objects, it gets the count of own
       * enumerable string keys.
       *
       *     assert.isEmpty([]);
       *     assert.isEmpty('');
       *     assert.isEmpty(new Map);
       *     assert.isEmpty({});
       *
       * @name isEmpty
       * @alias empty
       * @param {Object|Array|String|Map|Set} target
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isEmpty = function(val, msg) {
        new Assertion(val, msg, assert$$1.isEmpty, true).to.be.empty;
      };

      /**
       * ### .isNotEmpty(target)
       *
       * Asserts that the target contains values.
       * For arrays and strings, it checks the `length` property.
       * For `Map` and `Set` instances, it checks the `size` property.
       * For non-function objects, it gets the count of own
       * enumerable string keys.
       *
       *     assert.isNotEmpty([1, 2]);
       *     assert.isNotEmpty('34');
       *     assert.isNotEmpty(new Set([5, 6]));
       *     assert.isNotEmpty({ key: 7 });
       *
       * @name isNotEmpty
       * @alias notEmpty
       * @param {Object|Array|String|Map|Set} target
       * @param {String} message _optional_
       * @namespace Assert
       * @api public
       */

      assert$$1.isNotEmpty = function(val, msg) {
        new Assertion(val, msg, assert$$1.isNotEmpty, true).to.not.be.empty;
      };

      /*!
       * Aliases.
       */

      (function alias(name, as){
        assert$$1[as] = assert$$1[name];
        return alias;
      })
      ('isOk', 'ok')
      ('isNotOk', 'notOk')
      ('throws', 'throw')
      ('throws', 'Throw')
      ('isExtensible', 'extensible')
      ('isNotExtensible', 'notExtensible')
      ('isSealed', 'sealed')
      ('isNotSealed', 'notSealed')
      ('isFrozen', 'frozen')
      ('isNotFrozen', 'notFrozen')
      ('isEmpty', 'empty')
      ('isNotEmpty', 'notEmpty');
    };

    var chai = createCommonjsModule(function (module, exports) {
    /*!
     * chai
     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var used = [];

    /*!
     * Chai version
     */

    exports.version = '4.1.2';

    /*!
     * Assertion Error
     */

    exports.AssertionError = assertionError;

    /*!
     * Utils for plugins (not exported)
     */



    /**
     * # .use(function)
     *
     * Provides a way to extend the internals of Chai.
     *
     * @param {Function}
     * @returns {this} for chaining
     * @api public
     */

    exports.use = function (fn) {
      if (!~used.indexOf(fn)) {
        fn(exports, utils);
        used.push(fn);
      }

      return exports;
    };

    /*!
     * Utility Functions
     */

    exports.util = utils;

    /*!
     * Configuration
     */


    exports.config = config;

    /*!
     * Primary `Assertion` prototype
     */


    exports.use(assertion);

    /*!
     * Core Assertions
     */


    exports.use(assertions);

    /*!
     * Expect interface
     */


    exports.use(expect);

    /*!
     * Should interface
     */


    exports.use(should);

    /*!
     * Assert interface
     */


    exports.use(assert$1);
    });
    var chai_1 = chai.version;
    var chai_2 = chai.AssertionError;
    var chai_3 = chai.use;
    var chai_4 = chai.util;
    var chai_5 = chai.config;

    var chai$1 = chai;
    var chai_1$1 = chai$1.expect;

    var M = {
        num: 1,
        nul: null,
        undef: void 0,
        obj: { hi: 'there' },
        fun: function () { },
        arr: [],
        fwd: function (arr) { arr.push("M"); },
        bck: function (arr) { arr.push("M"); }
    };
    var C = (function () {
        function C() {
        }
        C.prototype.b = function () { };
        C.prototype.fwd = function (arr) { arr.push("C"); };
        C.prototype.bck = function (arr) { arr.push("C"); };
        C.a = 1;
        return C;
    }());
    describe("Forward declarations", function () {
        it('@predefine calls onExtend hook', function () {
            var called = 0;
            var X = (function () {
                function X() {
                }
                X.onExtend = function (BaseClass) {
                    chai_1$1(BaseClass).to.eql(Object);
                    called++;
                };
                X = __decorate([
                    predefine
                ], X);
                return X;
            }());
            chai_1$1(called).to.eql(1);
        });
    });
    describe("@define decorator", function () {
        it('@define makes plain class mixable', function () {
            var X = (function () {
                function X() {
                }
                X = __decorate([
                    define
                ], X);
                return X;
            }());
            chai_1$1(X.define).to.exist;
        });
        it('@define calls onDefine hook', function () {
            var called = 0;
            var X = (function () {
                function X() {
                }
                X.onDefine = function (spec, BaseClass) {
                    called++;
                    chai_1$1(spec).to.eql({});
                    chai_1$1(BaseClass).to.eql(Object);
                };
                X = __decorate([
                    define({ a: 1 })
                ], X);
                return X;
            }());
            chai_1$1(X.define).to.exist;
            chai_1$1(called).to.eql(1);
        });
        it('@define does nothing when extend mixable', function () {
            var X = (function (_super) {
                __extends(X, _super);
                function X() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                X = __decorate([
                    define
                ], X);
                return X;
            }(Mixable));
            chai_1$1(X.__super__).to.eql(Mixable.prototype);
        });
        it('@define( props ) assign members to class proto', function () {
            var X = (function () {
                function X() {
                }
                X.prototype.a = function () { };
                X = __decorate([
                    define({
                        a: 1,
                        b: 2
                    })
                ], X);
                return X;
            }());
            chai_1$1(X.prototype.b).to.eql(2);
            chai_1$1(X.prototype.a).to.eql(1);
        });
        it('Mixable.extend creates the subclass', function () {
            var X = Mixable.extend({ a: 5 });
            var x = new X();
            chai_1$1(x.a).to.eql(5);
            chai_1$1(x).to.be.instanceof(Mixable);
        });
        it('allows toString() and valueOf() override', function () {
            var Base = (function (_super) {
                __extends(Base, _super);
                function Base() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Base.prototype.toString = function () { return "base"; };
                Base.prototype.valueOf = function () { return 'base'; };
                Base = __decorate([
                    define
                ], Base);
                return Base;
            }(Mixable));
            var Sub = (function (_super) {
                __extends(Sub, _super);
                function Sub() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Sub.prototype.toString = function () { return "sub"; };
                Sub.prototype.valueOf = function () { return 'sub'; };
                Sub = __decorate([
                    define
                ], Sub);
                return Sub;
            }(Base));
            var base = new Base(), sub = new Sub();
            chai_1$1(base.toString()).to.eql('base');
            chai_1$1(base.valueOf()).to.eql('base');
            chai_1$1(sub.toString()).to.eql('sub');
            chai_1$1(sub.valueOf()).to.eql('sub');
        });
        it('allows toString() and valueOf() override with .extend()', function () {
            var Base = Mixable.extend({
                toString: function () { return "base"; },
                valueOf: function () { return 'base'; }
            });
            var Sub = Base.extend({
                toString: function () { return "sub"; },
                valueOf: function () { return 'sub'; }
            });
            var base = new Base(), sub = new Sub();
            chai_1$1(base.toString()).to.eql('base');
            chai_1$1(base.valueOf()).to.eql('base');
            chai_1$1(sub.toString()).to.eql('sub');
            chai_1$1(sub.valueOf()).to.eql('sub');
        });
        it("gives priority to the class definition", function () {
            var X = (function (_super) {
                __extends(X, _super);
                function X() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                X.prototype.nul = function () { };
                X = __decorate([
                    define({
                        undef: 1
                    }),
                    mixins(M)
                ], X);
                return X;
            }(Mixable));
            chai_1$1(X.prototype.nul).to.be.instanceof(Function);
            chai_1$1(X.prototype.undef).to.be.eql(1);
        });
    });
    describe('@mixins', function () {
        it("merges in the plain objects", function () {
            var X = (function (_super) {
                __extends(X, _super);
                function X() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                X = __decorate([
                    define,
                    mixins(M)
                ], X);
                return X;
            }(Mixable));
            chai_1$1(X.prototype).to.contain(M);
        });
        it("don't merge same mixin twice", function () {
            var X = (function (_super) {
                __extends(X, _super);
                function X() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                X = __decorate([
                    define,
                    mixins(M, M)
                ], X);
                return X;
            }(Mixable));
            chai_1$1(X.mixins.appliedMixins.length).to.equal(1);
            var Y = (function (_super) {
                __extends(Y, _super);
                function Y() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Y = __decorate([
                    define, mixins(M)
                ], Y);
                return Y;
            }(X));
            chai_1$1(Y.mixins.appliedMixins.length).to.equal(1);
        });
        it("mix in classes", function () {
            var X = (function () {
                function X() {
                }
                X = __decorate([
                    define, mixins(C)
                ], X);
                return X;
            }());
            var x = new X();
            chai_1$1(X.a).to.eql(1);
            chai_1$1(x.b).to.be.instanceof(Function);
        });
        it("mix in sequence", function () {
            var A = { a: 1, b: 1 }, B = { a: 2 };
            var X = (function () {
                function X() {
                }
                X = __decorate([
                    define, mixins(B, A)
                ], X);
                return X;
            }());
            var x = new X();
            chai_1$1(x.a).to.eql(2);
            chai_1$1(x.b).to.eql(1);
        });
        it('merge methods from mixin if they are not locally defined', function () {
            var Base = (function () {
                function Base() {
                }
                Base.prototype.first = function () { };
                Base = __decorate([
                    define
                ], Base);
                return Base;
            }());
            var Mix = {
                first: function () { },
                second: function () { }
            };
            var Y = (function (_super) {
                __extends(Y, _super);
                function Y() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Y.prototype.second = function () { };
                Y = __decorate([
                    define, mixins(Mix)
                ], Y);
                return Y;
            }(Base));
            chai_1$1(Y.prototype.second).to.not.eql(Mix.second);
            chai_1$1(Y.prototype.first).to.eql(Mix.first);
        });
    });
    describe('mixin rules', function () {
        var X = (function () {
            function X() {
            }
            X = __decorate([
                define,
                mixins(M, C),
                mixinRules({
                    fwd: mixinRules.classFirst,
                    bck: mixinRules.classLast
                })
            ], X);
            return X;
        }());
        it('chains functions when merge rules are defined', function () {
            var x = new X();
            var fwda = [], bcka = [];
            x.fwd(fwda);
            chai_1$1(fwda).to.have.ordered.members(["M", "C"]);
            x.bck(bcka);
            chai_1$1(bcka).to.have.ordered.members(["C", "M"]);
        });
        it('chains function on inheritance', function () {
            var Y = (function (_super) {
                __extends(Y, _super);
                function Y() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Y.prototype.fwd = function (arr) { arr.push('Y'); };
                Y.prototype.bck = function (arr) { arr.push('Y'); };
                Y = __decorate([
                    define,
                    mixins({
                        fwd: function (arr) { arr.push('Z'); },
                        bck: function (arr) { arr.push('Z'); }
                    })
                ], Y);
                return Y;
            }(X));
            var y = new Y();
            var fwda = [], bcka = [];
            y.fwd(fwda);
            chai_1$1(fwda).to.have.ordered.members(["Y", "Z", "M", "C"]);
            y.bck(bcka);
            chai_1$1(bcka).to.have.ordered.members(["C", "M", "Z", "Y"]);
        });
    });
    describe('@definitions', function () {
        it('extract definitions from statics', function () {
            var Y = (function () {
                function Y() {
                }
                Y.onDefine = function (spec) {
                    chai_1$1(spec).to.deep.equal({ a: 'a', b: { a: 1 } });
                    this.prototype.zzz = 'Hurrah!';
                };
                Y.a = 'a';
                Y.b = { a: 1 };
                Y = __decorate([
                    define,
                    definitions({
                        a: mixinRules.value,
                        b: mixinRules.merge
                    })
                ], Y);
                return Y;
            }());
        });
        it('extract definitions from @define parameter', function () {
            var Y = (function () {
                function Y() {
                }
                Y.onDefine = function (spec) {
                    chai_1$1(spec).to.deep.equal({ a: 'a', b: { a: 1 } });
                    this.prototype.zzz = 'Hurrah!';
                };
                Y = __decorate([
                    define({
                        a: 'a',
                        b: { a: 1 }
                    }),
                    definitions({
                        a: mixinRules.value,
                        b: mixinRules.merge
                    })
                ], Y);
                return Y;
            }());
        });
        it('extract definitions from mixins', function () {
            var Y = (function () {
                function Y() {
                }
                Y.onDefine = function (spec) {
                    chai_1$1(spec).to.deep.equal({ a: 'a', b: { a: 1, b: 1, c: 1 } });
                    this.prototype.zzz = 'Hurrah!';
                };
                Y.b = { c: 1 };
                Y = __decorate([
                    define({
                        a: 'a',
                        b: { a: 1 }
                    }),
                    mixins({
                        a: 'no',
                        b: { b: 1, a: 2 }
                    }),
                    definitions({
                        a: mixinRules.value,
                        b: mixinRules.merge
                    })
                ], Y);
                return Y;
            }());
        });
    });

    /*! *****************************************************************************
    Copyright (C) Microsoft. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var Reflect$1;
    (function (Reflect) {
        // Metadata Proposal
        // https://rbuckton.github.io/reflect-metadata/
        (function (factory) {
            var root = typeof commonjsGlobal === "object" ? commonjsGlobal :
                typeof self === "object" ? self :
                    typeof this === "object" ? this :
                        Function("return this;")();
            var exporter = makeExporter(Reflect);
            if (typeof root.Reflect === "undefined") {
                root.Reflect = Reflect;
            }
            else {
                exporter = makeExporter(root.Reflect, exporter);
            }
            factory(exporter);
            function makeExporter(target, previous) {
                return function (key, value) {
                    if (typeof target[key] !== "function") {
                        Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                    }
                    if (previous)
                        previous(key, value);
                };
            }
        })(function (exporter) {
            var hasOwn = Object.prototype.hasOwnProperty;
            // feature test for Symbol support
            var supportsSymbol = typeof Symbol === "function";
            var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
            var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
            var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
            var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
            var downLevel = !supportsCreate && !supportsProto;
            var HashMap = {
                // create an object in dictionary mode (a.k.a. "slow" mode in v8)
                create: supportsCreate
                    ? function () { return MakeDictionary(Object.create(null)); }
                    : supportsProto
                        ? function () { return MakeDictionary({ __proto__: null }); }
                        : function () { return MakeDictionary({}); },
                has: downLevel
                    ? function (map, key) { return hasOwn.call(map, key); }
                    : function (map, key) { return key in map; },
                get: downLevel
                    ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                    : function (map, key) { return map[key]; },
            };
            // Load global or shim versions of Map, Set, and WeakMap
            var functionPrototype = Object.getPrototypeOf(Function);
            var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
            var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
            var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
            var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
            // [[Metadata]] internal slot
            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
            var Metadata = new _WeakMap();
            /**
             * Applies a set of decorators to a property of a target object.
             * @param decorators An array of decorators.
             * @param target The target object.
             * @param propertyKey (Optional) The property key to decorate.
             * @param attributes (Optional) The property descriptor for the target key.
             * @remarks Decorators are applied in reverse order.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     Example = Reflect.decorate(decoratorsArray, Example);
             *
             *     // property (on constructor)
             *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
             *
             *     // property (on prototype)
             *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
             *
             *     // method (on constructor)
             *     Object.defineProperty(Example, "staticMethod",
             *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
             *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
             *
             *     // method (on prototype)
             *     Object.defineProperty(Example.prototype, "method",
             *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
             *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
             *
             */
            function decorate(decorators, target, propertyKey, attributes) {
                if (!IsUndefined(propertyKey)) {
                    if (!IsArray(decorators))
                        throw new TypeError();
                    if (!IsObject(target))
                        throw new TypeError();
                    if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                        throw new TypeError();
                    if (IsNull(attributes))
                        attributes = undefined;
                    propertyKey = ToPropertyKey(propertyKey);
                    return DecorateProperty(decorators, target, propertyKey, attributes);
                }
                else {
                    if (!IsArray(decorators))
                        throw new TypeError();
                    if (!IsConstructor(target))
                        throw new TypeError();
                    return DecorateConstructor(decorators, target);
                }
            }
            exporter("decorate", decorate);
            // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
            // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
            /**
             * A default metadata decorator factory that can be used on a class, class member, or parameter.
             * @param metadataKey The key for the metadata entry.
             * @param metadataValue The value for the metadata entry.
             * @returns A decorator function.
             * @remarks
             * If `metadataKey` is already defined for the target and target key, the
             * metadataValue for that key will be overwritten.
             * @example
             *
             *     // constructor
             *     @Reflect.metadata(key, value)
             *     class Example {
             *     }
             *
             *     // property (on constructor, TypeScript only)
             *     class Example {
             *         @Reflect.metadata(key, value)
             *         static staticProperty;
             *     }
             *
             *     // property (on prototype, TypeScript only)
             *     class Example {
             *         @Reflect.metadata(key, value)
             *         property;
             *     }
             *
             *     // method (on constructor)
             *     class Example {
             *         @Reflect.metadata(key, value)
             *         static staticMethod() { }
             *     }
             *
             *     // method (on prototype)
             *     class Example {
             *         @Reflect.metadata(key, value)
             *         method() { }
             *     }
             *
             */
            function metadata(metadataKey, metadataValue) {
                function decorator(target, propertyKey) {
                    if (!IsObject(target))
                        throw new TypeError();
                    if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                        throw new TypeError();
                    OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
                }
                return decorator;
            }
            exporter("metadata", metadata);
            /**
             * Define a unique metadata entry on the target.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param metadataValue A value that contains attached metadata.
             * @param target The target object on which to define metadata.
             * @param propertyKey (Optional) The property key for the target.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     Reflect.defineMetadata("custom:annotation", options, Example);
             *
             *     // property (on constructor)
             *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
             *
             *     // property (on prototype)
             *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
             *
             *     // method (on constructor)
             *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
             *
             *     // method (on prototype)
             *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
             *
             *     // decorator factory as metadata-producing annotation.
             *     function MyAnnotation(options): Decorator {
             *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
             *     }
             *
             */
            function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            exporter("defineMetadata", defineMetadata);
            /**
             * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.hasMetadata("custom:annotation", Example);
             *
             *     // property (on constructor)
             *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
             *
             */
            function hasMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasMetadata(metadataKey, target, propertyKey);
            }
            exporter("hasMetadata", hasMetadata);
            /**
             * Gets a value indicating whether the target object has the provided metadata key defined.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
             *
             *     // property (on constructor)
             *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
             *
             */
            function hasOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
            }
            exporter("hasOwnMetadata", hasOwnMetadata);
            /**
             * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.getMetadata("custom:annotation", Example);
             *
             *     // property (on constructor)
             *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
             *
             */
            function getMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetMetadata(metadataKey, target, propertyKey);
            }
            exporter("getMetadata", getMetadata);
            /**
             * Gets the metadata value for the provided metadata key on the target object.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.getOwnMetadata("custom:annotation", Example);
             *
             *     // property (on constructor)
             *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
             *
             */
            function getOwnMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
            }
            exporter("getOwnMetadata", getOwnMetadata);
            /**
             * Gets the metadata keys defined on the target object or its prototype chain.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns An array of unique metadata keys.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.getMetadataKeys(Example);
             *
             *     // property (on constructor)
             *     result = Reflect.getMetadataKeys(Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.getMetadataKeys(Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.getMetadataKeys(Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.getMetadataKeys(Example.prototype, "method");
             *
             */
            function getMetadataKeys(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryMetadataKeys(target, propertyKey);
            }
            exporter("getMetadataKeys", getMetadataKeys);
            /**
             * Gets the unique metadata keys defined on the target object.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns An array of unique metadata keys.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.getOwnMetadataKeys(Example);
             *
             *     // property (on constructor)
             *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
             *
             */
            function getOwnMetadataKeys(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                return OrdinaryOwnMetadataKeys(target, propertyKey);
            }
            exporter("getOwnMetadataKeys", getOwnMetadataKeys);
            /**
             * Deletes the metadata entry from the target object with the provided key.
             * @param metadataKey A key used to store and retrieve metadata.
             * @param target The target object on which the metadata is defined.
             * @param propertyKey (Optional) The property key for the target.
             * @returns `true` if the metadata entry was found and deleted; otherwise, false.
             * @example
             *
             *     class Example {
             *         // property declarations are not part of ES6, though they are valid in TypeScript:
             *         // static staticProperty;
             *         // property;
             *
             *         constructor(p) { }
             *         static staticMethod(p) { }
             *         method(p) { }
             *     }
             *
             *     // constructor
             *     result = Reflect.deleteMetadata("custom:annotation", Example);
             *
             *     // property (on constructor)
             *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
             *
             *     // property (on prototype)
             *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
             *
             *     // method (on constructor)
             *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
             *
             *     // method (on prototype)
             *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
             *
             */
            function deleteMetadata(metadataKey, target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey))
                    propertyKey = ToPropertyKey(propertyKey);
                var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                if (!metadataMap.delete(metadataKey))
                    return false;
                if (metadataMap.size > 0)
                    return true;
                var targetMetadata = Metadata.get(target);
                targetMetadata.delete(propertyKey);
                if (targetMetadata.size > 0)
                    return true;
                Metadata.delete(target);
                return true;
            }
            exporter("deleteMetadata", deleteMetadata);
            function DecorateConstructor(decorators, target) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                    var decorator = decorators[i];
                    var decorated = decorator(target);
                    if (!IsUndefined(decorated) && !IsNull(decorated)) {
                        if (!IsConstructor(decorated))
                            throw new TypeError();
                        target = decorated;
                    }
                }
                return target;
            }
            function DecorateProperty(decorators, target, propertyKey, descriptor) {
                for (var i = decorators.length - 1; i >= 0; --i) {
                    var decorator = decorators[i];
                    var decorated = decorator(target, propertyKey, descriptor);
                    if (!IsUndefined(decorated) && !IsNull(decorated)) {
                        if (!IsObject(decorated))
                            throw new TypeError();
                        descriptor = decorated;
                    }
                }
                return descriptor;
            }
            function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = Metadata.get(O);
                if (IsUndefined(targetMetadata)) {
                    if (!Create)
                        return undefined;
                    targetMetadata = new _Map();
                    Metadata.set(O, targetMetadata);
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                    if (!Create)
                        return undefined;
                    metadataMap = new _Map();
                    targetMetadata.set(P, metadataMap);
                }
                return metadataMap;
            }
            // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
            function OrdinaryHasMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn)
                    return true;
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent))
                    return OrdinaryHasMetadata(MetadataKey, parent, P);
                return false;
            }
            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                return ToBoolean(metadataMap.has(MetadataKey));
            }
            // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
            function OrdinaryGetMetadata(MetadataKey, O, P) {
                var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
                if (hasOwn)
                    return OrdinaryGetOwnMetadata(MetadataKey, O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (!IsNull(parent))
                    return OrdinaryGetMetadata(MetadataKey, parent, P);
                return undefined;
            }
            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return undefined;
                return metadataMap.get(MetadataKey);
            }
            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
                metadataMap.set(MetadataKey, MetadataValue);
            }
            // 3.1.6.1 OrdinaryMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
            function OrdinaryMetadataKeys(O, P) {
                var ownKeys = OrdinaryOwnMetadataKeys(O, P);
                var parent = OrdinaryGetPrototypeOf(O);
                if (parent === null)
                    return ownKeys;
                var parentKeys = OrdinaryMetadataKeys(parent, P);
                if (parentKeys.length <= 0)
                    return ownKeys;
                if (ownKeys.length <= 0)
                    return parentKeys;
                var set = new _Set();
                var keys = [];
                for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                    var key = ownKeys_1[_i];
                    var hasKey = set.has(key);
                    if (!hasKey) {
                        set.add(key);
                        keys.push(key);
                    }
                }
                for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                    var key = parentKeys_1[_a];
                    var hasKey = set.has(key);
                    if (!hasKey) {
                        set.add(key);
                        keys.push(key);
                    }
                }
                return keys;
            }
            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
            function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                        keys.length = k;
                        return keys;
                    }
                    var nextValue = IteratorValue(next);
                    try {
                        keys[k] = nextValue;
                    }
                    catch (e) {
                        try {
                            IteratorClose(iterator);
                        }
                        finally {
                            throw e;
                        }
                    }
                    k++;
                }
            }
            // 6 ECMAScript Data Typ0es and Values
            // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
            function Type(x) {
                if (x === null)
                    return 1 /* Null */;
                switch (typeof x) {
                    case "undefined": return 0 /* Undefined */;
                    case "boolean": return 2 /* Boolean */;
                    case "string": return 3 /* String */;
                    case "symbol": return 4 /* Symbol */;
                    case "number": return 5 /* Number */;
                    case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                    default: return 6 /* Object */;
                }
            }
            // 6.1.1 The Undefined Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
            function IsUndefined(x) {
                return x === undefined;
            }
            // 6.1.2 The Null Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
            function IsNull(x) {
                return x === null;
            }
            // 6.1.5 The Symbol Type
            // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
            function IsSymbol(x) {
                return typeof x === "symbol";
            }
            // 6.1.7 The Object Type
            // https://tc39.github.io/ecma262/#sec-object-type
            function IsObject(x) {
                return typeof x === "object" ? x !== null : typeof x === "function";
            }
            // 7.1 Type Conversion
            // https://tc39.github.io/ecma262/#sec-type-conversion
            // 7.1.1 ToPrimitive(input [, PreferredType])
            // https://tc39.github.io/ecma262/#sec-toprimitive
            function ToPrimitive(input, PreferredType) {
                switch (Type(input)) {
                    case 0 /* Undefined */: return input;
                    case 1 /* Null */: return input;
                    case 2 /* Boolean */: return input;
                    case 3 /* String */: return input;
                    case 4 /* Symbol */: return input;
                    case 5 /* Number */: return input;
                }
                var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
                var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
                if (exoticToPrim !== undefined) {
                    var result = exoticToPrim.call(input, hint);
                    if (IsObject(result))
                        throw new TypeError();
                    return result;
                }
                return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
            }
            // 7.1.1.1 OrdinaryToPrimitive(O, hint)
            // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
            function OrdinaryToPrimitive(O, hint) {
                if (hint === "string") {
                    var toString_1 = O.toString;
                    if (IsCallable(toString_1)) {
                        var result = toString_1.call(O);
                        if (!IsObject(result))
                            return result;
                    }
                    var valueOf = O.valueOf;
                    if (IsCallable(valueOf)) {
                        var result = valueOf.call(O);
                        if (!IsObject(result))
                            return result;
                    }
                }
                else {
                    var valueOf = O.valueOf;
                    if (IsCallable(valueOf)) {
                        var result = valueOf.call(O);
                        if (!IsObject(result))
                            return result;
                    }
                    var toString_2 = O.toString;
                    if (IsCallable(toString_2)) {
                        var result = toString_2.call(O);
                        if (!IsObject(result))
                            return result;
                    }
                }
                throw new TypeError();
            }
            // 7.1.2 ToBoolean(argument)
            // https://tc39.github.io/ecma262/2016/#sec-toboolean
            function ToBoolean(argument) {
                return !!argument;
            }
            // 7.1.12 ToString(argument)
            // https://tc39.github.io/ecma262/#sec-tostring
            function ToString(argument) {
                return "" + argument;
            }
            // 7.1.14 ToPropertyKey(argument)
            // https://tc39.github.io/ecma262/#sec-topropertykey
            function ToPropertyKey(argument) {
                var key = ToPrimitive(argument, 3 /* String */);
                if (IsSymbol(key))
                    return key;
                return ToString(key);
            }
            // 7.2 Testing and Comparison Operations
            // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
            // 7.2.2 IsArray(argument)
            // https://tc39.github.io/ecma262/#sec-isarray
            function IsArray(argument) {
                return Array.isArray
                    ? Array.isArray(argument)
                    : argument instanceof Object
                        ? argument instanceof Array
                        : Object.prototype.toString.call(argument) === "[object Array]";
            }
            // 7.2.3 IsCallable(argument)
            // https://tc39.github.io/ecma262/#sec-iscallable
            function IsCallable(argument) {
                // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
                return typeof argument === "function";
            }
            // 7.2.4 IsConstructor(argument)
            // https://tc39.github.io/ecma262/#sec-isconstructor
            function IsConstructor(argument) {
                // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
                return typeof argument === "function";
            }
            // 7.2.7 IsPropertyKey(argument)
            // https://tc39.github.io/ecma262/#sec-ispropertykey
            function IsPropertyKey(argument) {
                switch (Type(argument)) {
                    case 3 /* String */: return true;
                    case 4 /* Symbol */: return true;
                    default: return false;
                }
            }
            // 7.3 Operations on Objects
            // https://tc39.github.io/ecma262/#sec-operations-on-objects
            // 7.3.9 GetMethod(V, P)
            // https://tc39.github.io/ecma262/#sec-getmethod
            function GetMethod(V, P) {
                var func = V[P];
                if (func === undefined || func === null)
                    return undefined;
                if (!IsCallable(func))
                    throw new TypeError();
                return func;
            }
            // 7.4 Operations on Iterator Objects
            // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
            function GetIterator(obj) {
                var method = GetMethod(obj, iteratorSymbol);
                if (!IsCallable(method))
                    throw new TypeError(); // from Call
                var iterator = method.call(obj);
                if (!IsObject(iterator))
                    throw new TypeError();
                return iterator;
            }
            // 7.4.4 IteratorValue(iterResult)
            // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
            function IteratorValue(iterResult) {
                return iterResult.value;
            }
            // 7.4.5 IteratorStep(iterator)
            // https://tc39.github.io/ecma262/#sec-iteratorstep
            function IteratorStep(iterator) {
                var result = iterator.next();
                return result.done ? false : result;
            }
            // 7.4.6 IteratorClose(iterator, completion)
            // https://tc39.github.io/ecma262/#sec-iteratorclose
            function IteratorClose(iterator) {
                var f = iterator["return"];
                if (f)
                    f.call(iterator);
            }
            // 9.1 Ordinary Object Internal Methods and Internal Slots
            // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
            // 9.1.1.1 OrdinaryGetPrototypeOf(O)
            // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
            function OrdinaryGetPrototypeOf(O) {
                var proto = Object.getPrototypeOf(O);
                if (typeof O !== "function" || O === functionPrototype)
                    return proto;
                // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
                // Try to determine the superclass constructor. Compatible implementations
                // must either set __proto__ on a subclass constructor to the superclass constructor,
                // or ensure each class has a valid `constructor` property on its prototype that
                // points back to the constructor.
                // If this is not the same as Function.[[Prototype]], then this is definately inherited.
                // This is the case when in ES6 or when using __proto__ in a compatible browser.
                if (proto !== functionPrototype)
                    return proto;
                // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
                var prototype = O.prototype;
                var prototypeProto = prototype && Object.getPrototypeOf(prototype);
                if (prototypeProto == null || prototypeProto === Object.prototype)
                    return proto;
                // If the constructor was not a function, then we cannot determine the heritage.
                var constructor = prototypeProto.constructor;
                if (typeof constructor !== "function")
                    return proto;
                // If we have some kind of self-reference, then we cannot determine the heritage.
                if (constructor === O)
                    return proto;
                // we have a pretty good guess at the heritage.
                return constructor;
            }
            // naive Map shim
            function CreateMapPolyfill() {
                var cacheSentinel = {};
                var arraySentinel = [];
                var MapIterator = (function () {
                    function MapIterator(keys, values, selector) {
                        this._index = 0;
                        this._keys = keys;
                        this._values = values;
                        this._selector = selector;
                    }
                    MapIterator.prototype["@@iterator"] = function () { return this; };
                    MapIterator.prototype[iteratorSymbol] = function () { return this; };
                    MapIterator.prototype.next = function () {
                        var index = this._index;
                        if (index >= 0 && index < this._keys.length) {
                            var result = this._selector(this._keys[index], this._values[index]);
                            if (index + 1 >= this._keys.length) {
                                this._index = -1;
                                this._keys = arraySentinel;
                                this._values = arraySentinel;
                            }
                            else {
                                this._index++;
                            }
                            return { value: result, done: false };
                        }
                        return { value: undefined, done: true };
                    };
                    MapIterator.prototype.throw = function (error) {
                        if (this._index >= 0) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        throw error;
                    };
                    MapIterator.prototype.return = function (value) {
                        if (this._index >= 0) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        return { value: value, done: true };
                    };
                    return MapIterator;
                }());
                return (function () {
                    function Map() {
                        this._keys = [];
                        this._values = [];
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    Object.defineProperty(Map.prototype, "size", {
                        get: function () { return this._keys.length; },
                        enumerable: true,
                        configurable: true
                    });
                    Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                    Map.prototype.get = function (key) {
                        var index = this._find(key, /*insert*/ false);
                        return index >= 0 ? this._values[index] : undefined;
                    };
                    Map.prototype.set = function (key, value) {
                        var index = this._find(key, /*insert*/ true);
                        this._values[index] = value;
                        return this;
                    };
                    Map.prototype.delete = function (key) {
                        var index = this._find(key, /*insert*/ false);
                        if (index >= 0) {
                            var size = this._keys.length;
                            for (var i = index + 1; i < size; i++) {
                                this._keys[i - 1] = this._keys[i];
                                this._values[i - 1] = this._values[i];
                            }
                            this._keys.length--;
                            this._values.length--;
                            if (key === this._cacheKey) {
                                this._cacheKey = cacheSentinel;
                                this._cacheIndex = -2;
                            }
                            return true;
                        }
                        return false;
                    };
                    Map.prototype.clear = function () {
                        this._keys.length = 0;
                        this._values.length = 0;
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    };
                    Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                    Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                    Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                    Map.prototype["@@iterator"] = function () { return this.entries(); };
                    Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                    Map.prototype._find = function (key, insert) {
                        if (this._cacheKey !== key) {
                            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                        }
                        if (this._cacheIndex < 0 && insert) {
                            this._cacheIndex = this._keys.length;
                            this._keys.push(key);
                            this._values.push(undefined);
                        }
                        return this._cacheIndex;
                    };
                    return Map;
                }());
                function getKey(key, _) {
                    return key;
                }
                function getValue(_, value) {
                    return value;
                }
                function getEntry(key, value) {
                    return [key, value];
                }
            }
            // naive Set shim
            function CreateSetPolyfill() {
                return (function () {
                    function Set() {
                        this._map = new _Map();
                    }
                    Object.defineProperty(Set.prototype, "size", {
                        get: function () { return this._map.size; },
                        enumerable: true,
                        configurable: true
                    });
                    Set.prototype.has = function (value) { return this._map.has(value); };
                    Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                    Set.prototype.delete = function (value) { return this._map.delete(value); };
                    Set.prototype.clear = function () { this._map.clear(); };
                    Set.prototype.keys = function () { return this._map.keys(); };
                    Set.prototype.values = function () { return this._map.values(); };
                    Set.prototype.entries = function () { return this._map.entries(); };
                    Set.prototype["@@iterator"] = function () { return this.keys(); };
                    Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                    return Set;
                }());
            }
            // naive WeakMap shim
            function CreateWeakMapPolyfill() {
                var UUID_SIZE = 16;
                var keys = HashMap.create();
                var rootKey = CreateUniqueKey();
                return (function () {
                    function WeakMap() {
                        this._key = CreateUniqueKey();
                    }
                    WeakMap.prototype.has = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                        return table !== undefined ? HashMap.has(table, this._key) : false;
                    };
                    WeakMap.prototype.get = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                        return table !== undefined ? HashMap.get(table, this._key) : undefined;
                    };
                    WeakMap.prototype.set = function (target, value) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                        table[this._key] = value;
                        return this;
                    };
                    WeakMap.prototype.delete = function (target) {
                        var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                        return table !== undefined ? delete table[this._key] : false;
                    };
                    WeakMap.prototype.clear = function () {
                        // NOTE: not a real clear, just makes the previous data unreachable
                        this._key = CreateUniqueKey();
                    };
                    return WeakMap;
                }());
                function CreateUniqueKey() {
                    var key;
                    do
                        key = "@@WeakMap@@" + CreateUUID();
                    while (HashMap.has(keys, key));
                    keys[key] = true;
                    return key;
                }
                function GetOrCreateWeakMapTable(target, create) {
                    if (!hasOwn.call(target, rootKey)) {
                        if (!create)
                            return undefined;
                        Object.defineProperty(target, rootKey, { value: HashMap.create() });
                    }
                    return target[rootKey];
                }
                function FillRandomBytes(buffer, size) {
                    for (var i = 0; i < size; ++i)
                        buffer[i] = Math.random() * 0xff | 0;
                    return buffer;
                }
                function GenRandomBytes(size) {
                    if (typeof Uint8Array === "function") {
                        if (typeof crypto !== "undefined")
                            return crypto.getRandomValues(new Uint8Array(size));
                        if (typeof msCrypto !== "undefined")
                            return msCrypto.getRandomValues(new Uint8Array(size));
                        return FillRandomBytes(new Uint8Array(size), size);
                    }
                    return FillRandomBytes(new Array(size), size);
                }
                function CreateUUID() {
                    var data = GenRandomBytes(UUID_SIZE);
                    // mark as random - RFC 4122  4.4
                    data[6] = data[6] & 0x4f | 0x40;
                    data[8] = data[8] & 0xbf | 0x80;
                    var result = "";
                    for (var offset = 0; offset < UUID_SIZE; ++offset) {
                        var byte = data[offset];
                        if (offset === 4 || offset === 6 || offset === 8)
                            result += "-";
                        if (byte < 16)
                            result += "0";
                        result += byte.toString(16).toLowerCase();
                    }
                    return result;
                }
            }
            // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
            function MakeDictionary(obj) {
                obj.__ = undefined;
                delete obj.__;
                return obj;
            }
        });
    })(Reflect$1 || (Reflect$1 = {}));

    describe('Record', function () {
        it("can be instantiated", function () {
            new Record();
        });
        describe('Subclass', function () {
            it("attaches properties to prototype", function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    M = __decorate([
                        define({
                            a: 'a'
                        })
                    ], M);
                    return M;
                }(Record));
                chai_1$1(M.prototype.a).to.eql('a');
            });
        });
        describe("Attribute spec", function () {
            describe('...as constructors', function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr(String),
                        __metadata("design:type", Object)
                    ], M.prototype, "s", void 0);
                    __decorate([
                        attr(Number),
                        __metadata("design:type", Object)
                    ], M.prototype, "n", void 0);
                    __decorate([
                        attr(Boolean),
                        __metadata("design:type", Object)
                    ], M.prototype, "b", void 0);
                    __decorate([
                        attr(Object),
                        __metadata("design:type", Object)
                    ], M.prototype, "o", void 0);
                    __decorate([
                        attr(Array),
                        __metadata("design:type", Object)
                    ], M.prototype, "a", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Date)
                    ], M.prototype, "d", void 0);
                    M = __decorate([
                        define
                    ], M);
                    return M;
                }(Record));
                it("invokes constructor to create defaults", function () {
                    var m = new M();
                    chai_1$1(m.s).to.equal('');
                    chai_1$1(m.n).to.equal(0);
                    chai_1$1(m.b).to.equal(false);
                    chai_1$1(m.o).to.eql({});
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
                it("convert values to defined type in 'new'", function () {
                    var m = new M({
                        s: 55,
                        n: "1",
                        b: 'not bool',
                        o: "not an object",
                        a: "not an array",
                        d: 678678678
                    });
                    chai_1$1(m.s).to.equal('55');
                    chai_1$1(m.n).to.equal(1);
                    chai_1$1(m.b).to.equal(true);
                    chai_1$1(m.o).to.be.an.instanceOf(Object);
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
                it("convert values to defined types on assignment", function () {
                    var m = new M();
                    m.s = 55;
                    m.n = "1";
                    m.b = 'not bool';
                    m.o = "not an object";
                    m.a = "not an array";
                    m.d = 678678678;
                    chai_1$1(m.s).to.equal('55');
                    chai_1$1(m.n).to.equal(1);
                    chai_1$1(m.b).to.equal(true);
                    chai_1$1(m.o).to.be.an.instanceOf(Object);
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
                it("convert values to defined types on set", function () {
                    var m = new M();
                    m.set({
                        s: 55,
                        n: "1",
                        b: 'not bool',
                        o: "not an object",
                        a: "not an array",
                        d: 678678678
                    });
                    chai_1$1(m.s).to.equal('55');
                    chai_1$1(m.n).to.equal(1);
                    chai_1$1(m.b).to.equal(true);
                    chai_1$1(m.o).to.be.an.instanceOf(Object);
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
            });
            describe('...as default values', function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        _this.s = 'b';
                        _this.n = 1;
                        _this.b = true;
                        _this.o = {};
                        _this.a = [];
                        return _this;
                    }
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], M.prototype, "s", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Number)
                    ], M.prototype, "n", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Boolean)
                    ], M.prototype, "b", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Object)
                    ], M.prototype, "o", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Array)
                    ], M.prototype, "a", void 0);
                    __decorate([
                        attr,
                        __metadata("design:type", Date)
                    ], M.prototype, "d", void 0);
                    M = __decorate([
                        define
                    ], M);
                    return M;
                }(Record));
                it("accepts values as type spec", function () {
                    var m = new M();
                    chai_1$1(m.s).to.equal('b');
                    chai_1$1(m.n).to.equal(1);
                    chai_1$1(m.b).to.equal(true);
                    chai_1$1(m.o).to.not.equal({});
                    chai_1$1(m.o).to.be.an.instanceOf(Object);
                    chai_1$1(m.a).to.not.equal([]);
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
                it("infers types from values", function () {
                    var m = new M(), _attributes = m._attributes;
                    chai_1$1(_attributes.s.type).to.equal(String);
                    chai_1$1(_attributes.n.type).to.equal(Number);
                    chai_1$1(_attributes.b.type).to.equal(Boolean);
                    chai_1$1(_attributes.o.type).to.equal(Object);
                    chai_1$1(_attributes.a.type).to.equal(Array);
                    chai_1$1(_attributes.d.type).to.equal(Date);
                });
            });
            describe('...as constructors with values', function () {
                it("converts default values to defined types", function () {
                    var M = (function (_super) {
                        __extends(M, _super);
                        function M() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        M = __decorate([
                            define({
                                attributes: {
                                    s: String.value(55),
                                    n: Number.value("1"),
                                    b: Boolean.value("some"),
                                    o: Object.value("not an object"),
                                    a: Array.value("not an array"),
                                    d: Date.value(22222)
                                }
                            })
                        ], M);
                        return M;
                    }(Record));
                    var m = new M();
                    chai_1$1(m.s).to.equal('55');
                    chai_1$1(m.n).to.equal(1);
                    chai_1$1(m.b).to.equal(true);
                    chai_1$1(m.o).to.be.an.instanceOf(Object);
                    chai_1$1(m.a).to.eql([]);
                    chai_1$1(m.d).to.be.instanceof(Date);
                });
                it("accepts null as default value", function () {
                    var M = (function (_super) {
                        __extends(M, _super);
                        function M() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        M = __decorate([
                            define({
                                attributes: {
                                    s: String.value(null),
                                    n: Number.value(null),
                                    b: Boolean.value(null),
                                    o: Object.value(null),
                                    a: Array.value(null),
                                    d: Date.value(null)
                                }
                            })
                        ], M);
                        return M;
                    }(Record));
                    var m = new M();
                    chai_1$1(m.s).to.equal(null);
                    chai_1$1(m.n).to.equal(null);
                    chai_1$1(m.b).to.equal(null);
                    chai_1$1(m.o).to.eql(null);
                    chai_1$1(m.a).to.eql(null);
                    chai_1$1(m.d).to.eql(null);
                });
            });
        });
        describe("Record's collection", function () {
            it("is defined in the base Record", function () {
                chai_1$1(Record.Collection).to.be.a('function');
                chai_1$1(Record.Collection.prototype.model).to.eql(Record);
            });
            it("is created on Record's extension", function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    M = __decorate([
                        define
                    ], M);
                    return M;
                }(Record));
                var prototype = M.Collection.prototype;
                chai_1$1(prototype).to.be.instanceof(Record.Collection);
                chai_1$1(prototype.model).to.eql(M);
            });
            it("takes properties from .collection", function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    M = __decorate([
                        define({
                            collection: {
                                a: 'a'
                            }
                        })
                    ], M);
                    return M;
                }(Record));
                chai_1$1(M.Collection.prototype.a).to.eql('a');
            });
            it("can be defined separately", function () {
                var C = (function (_super) {
                    __extends(C, _super);
                    function C() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    C = __decorate([
                        define({
                            a: 'a'
                        })
                    ], C);
                    return C;
                }(Collection));
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    M.Collection = C;
                    M = __decorate([
                        define
                    ], M);
                    return M;
                }(Record));
                chai_1$1(M.Collection).to.equal(C);
                var prototype = M.Collection.prototype;
                chai_1$1(prototype).to.be.instanceof(Record.Collection);
                chai_1$1(prototype.a).to.eql('a');
                chai_1$1(prototype.model).to.eql(M);
            });
        });
        describe('Attribute types', function () {
            var Test = (function (_super) {
                __extends(Test, _super);
                function Test() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                __decorate([
                    attr(Function.value(null)),
                    __metadata("design:type", Function)
                ], Test.prototype, "fun", void 0);
                Test = __decorate([
                    define
                ], Test);
                return Test;
            }(Record));
            it('Supports function type', function () {
                var t = new Test();
                var t2 = t.clone();
                chai_1$1(t.fun).to.eql(t2.fun);
            });
        });
        describe('Record pre-definition', function () {
            var M1 = (function (_super) {
                __extends(M1, _super);
                function M1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                M1 = __decorate([
                    define
                ], M1);
                return M1;
            }(Record));
            var M2 = (function (_super) {
                __extends(M2, _super);
                function M2() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                M2 = __decorate([
                    predefine
                ], M2);
                return M2;
            }(Record));
            M2.define();
            it('predefine collection types', function () {
                chai_1$1(M1.Collection).to.be.instanceOf(Function);
                chai_1$1(M2.Collection).to.be.instanceOf(Function);
            });
            it("can't be instantiated", function () {
                new M1();
            });
            it('support forward declaration', function () {
                var M = (function (_super) {
                    __extends(M, _super);
                    function M() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    M = __decorate([
                        define
                    ], M);
                    return M;
                }(Record));
                chai_1$1(M.Collection).to.be.a('function');
                chai_1$1(M.Collection.prototype.model).to.eql(M);
                M.define({
                    a: 'a'
                });
                chai_1$1(M.prototype.a).to.eql('a');
            });
            it('can be defined', function () {
                M1.define({
                    a: 'first',
                    collection: {
                        b: 'second'
                    }
                });
                M2.define({
                    a: 'first'
                });
                M2.Collection.define({
                    b: 'second'
                });
            });
        });
    });

    var SecondsInterval = Record.extend({
        units: [
            'seconds',
            'minutes',
            'hours',
            'days',
            'weeks',
            'months',
            'years'
        ],
        defaults: {
            value: 1,
            interval: String.value('months')
        },
        properties: {
            seconds: function () { return this.getUnitValue(1); },
            minutes: function () { return this.getUnitValue(60); },
            hours: function () { return this.getUnitValue(3600); },
            days: function () { return this.getUnitValue(86400); },
            weeks: function () { return this.getUnitValue(604800); },
            months: function () { return this.getUnitValue(2628000); },
            years: function () { return this.getUnitValue(31536000); }
        },
        getUnitValue: function (value$$1) {
            return value$$1;
        },
        parse: function (data) {
            var res = {
                value: 1,
                interval: 'months'
            };
            data = typeof data === 'object' ? 0 : data;
            for (var i = this.units.length; i > 0; i--) {
                var l = this.units[i - 1];
                if (data % this[l] == 0) {
                    res.value = Math.floor(data / this[l]);
                    res.interval = l;
                    return res;
                }
            }
            return res;
        },
        toInteger: function () {
            return this.value * this[this.interval];
        },
        toJSON: function () {
            return this.toInteger();
        },
        getUnits: function () {
            var _this = this;
            var units = {};
            Object.keys(this.units).forEach(function (name) {
                units[name] = _this[name];
            });
            return units;
        }
    });
    var MinutesInterval = SecondsInterval.extend({
        units: [
            'minutes',
            'hours',
            'days',
            'weeks',
            'months',
            'years'
        ],
        getUnitValue: function (value$$1) {
            return value$$1 / 60;
        },
    });

    describe('Bugs from Volicon Observer', function () {
        describe('Serialization', function () {
            it('null attribute values should call has.parse()', function () {
                var Test = (function (_super) {
                    __extends(Test, _super);
                    function Test() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        type(String)
                            .parse(function (x) { return 'bla-bla'; })
                            .as,
                        __metadata("design:type", String)
                    ], Test.prototype, "a", void 0);
                    Test = __decorate([
                        define
                    ], Test);
                    return Test;
                }(Record));
                var t = new Test({ a: null }, { parse: true });
                chai_1$1(t.a).to.eql('bla-bla');
            });
        });
        describe('Attribute definitions', function () {
            it('@attr( value ) must work as expected', function () {
                var Test = (function (_super) {
                    __extends(Test, _super);
                    function Test() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr(5),
                        __metadata("design:type", Number)
                    ], Test.prototype, "num", void 0);
                    __decorate([
                        attr("5"),
                        __metadata("design:type", String)
                    ], Test.prototype, "str", void 0);
                    Test = __decorate([
                        define
                    ], Test);
                    return Test;
                }(Record));
                var t = new Test();
                chai_1$1(t.num).to.eql(5);
                chai_1$1(t.str).to.eql("5");
                t.str = 6;
                chai_1$1(t.str).to.eql("6");
            });
        });
        describe('Attribute change watcher', function () {
            it('works in base class and subclass', function () {
                var calls = [];
                var Base = (function (_super) {
                    __extends(Base, _super);
                    function Base() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        type(String).watcher(function (x) { return calls.push('inherited'); }).as,
                        __metadata("design:type", String)
                    ], Base.prototype, "inherited", void 0);
                    __decorate([
                        type(String).watcher('onNamedWatcher').as,
                        __metadata("design:type", String)
                    ], Base.prototype, "namedWatcher", void 0);
                    __decorate([
                        type(String).watcher(function (x) { return calls.push('base'); }).as,
                        __metadata("design:type", String)
                    ], Base.prototype, "overriden", void 0);
                    Base = __decorate([
                        define
                    ], Base);
                    return Base;
                }(Record));
                var Subclass = (function (_super) {
                    __extends(Subclass, _super);
                    function Subclass() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Subclass.prototype.onNamedWatcher = function () {
                        calls.push('named');
                    };
                    __decorate([
                        attr(String.has.watcher(function (x) { return calls.push('added'); })),
                        __metadata("design:type", String)
                    ], Subclass.prototype, "added", void 0);
                    __decorate([
                        attr(String.has.watcher(function (x) { return calls.push('subclass'); })),
                        __metadata("design:type", String)
                    ], Subclass.prototype, "overriden", void 0);
                    Subclass = __decorate([
                        define
                    ], Subclass);
                    return Subclass;
                }(Base));
                var subclass = new Subclass();
                subclass.inherited = "a";
                subclass.added = "b";
                subclass.overriden = "b";
                subclass.namedWatcher = "t";
                chai_1$1(calls).to.eql(['inherited', 'added', 'subclass', 'base', 'named']);
            });
        });
        describe('Validation', function () {
            it('performs validation if collection item is changed', function () {
                var BitrateModel = Record.extend({
                    defaults: {
                        bitrate: Number.value(512)
                    },
                    properties: {
                        bitrates: function () {
                            var available_bitrate = [128, 256, 384, 450, 512, 768, 896, 1000, 1500, 2000, 2500, 3000, 4500, 6000, 6500, 9000, 12000, 15000];
                            if (available_bitrate.indexOf(this.bitrate) === -1) {
                                available_bitrate.push(this.bitrate);
                            }
                            return available_bitrate.sort(function (a, b) {
                                return a - b;
                            });
                        }
                    },
                    initialize: function (options) {
                        Record.prototype.initialize.apply(this, arguments);
                    },
                    parse: function (data) {
                        return { bitrate: data / 1000 };
                    },
                    toJSON: function () {
                        var json = Record.prototype.toJSON.apply(this, arguments), bitrate = json.bitrate * 1000;
                        return bitrate;
                    }
                });
                var SubEncoder = Record.extend({
                    defaults: {
                        Bitrate: BitrateModel,
                        HistoryDepth: type(MinutesInterval).value(43800),
                        BitrateAsString: null,
                        ResolutionHeight: Number,
                        ResolutionWidth: Number,
                        resolution: String.has.toJSON(false)
                    },
                    collection: {
                        get: function (a) {
                            return Collection.prototype.get.apply(this, arguments) || this.models[a];
                        },
                        comparator: function (model1, model2) {
                            if (model1.Bitrate.bitrate > model2.Bitrate.bitrate) {
                                return 1;
                            }
                            else if (model1.Bitrate.bitrate < model2.Bitrate.bitrate) {
                                return -1;
                            }
                            else {
                                if (model1.ResolutionWidth > model2.ResolutionWidth) {
                                    return 1;
                                }
                                else if (model1.ResolutionWidth < model2.ResolutionWidth) {
                                    return -1;
                                }
                                else {
                                    if (model1.ResolutionHeight > model2.ResolutionHeight) {
                                        return 1;
                                    }
                                    else if (model1.ResolutionHeight < model2.ResolutionHeight) {
                                        return -1;
                                    }
                                    else {
                                        return 0;
                                    }
                                }
                            }
                        },
                        localEvents: {
                            change: function () {
                                this.sort();
                            }
                        }
                    }
                });
                var Placeholder = Record.extend({
                    attributes: {
                        subEncoders: SubEncoder.Collection.has.check(function (x) {
                            return x.length > 0;
                        }, 'ccccc')
                    }
                });
                var p = new Placeholder(), subEncoders = p.subEncoders;
                chai_1$1(p.isValid()).to.be.false;
                chai_1$1(subEncoders.isValid()).to.be.true;
                subEncoders.add({});
                chai_1$1(p._validationError).to.be.undefined;
                chai_1$1(p.isValid()).to.be.true;
                subEncoders.first().HistoryDepth.value = 2;
                chai_1$1(p._validationError).to.be.undefined;
                chai_1$1(p.isValid()).to.be.true;
                chai_1$1(subEncoders.isValid()).to.be.true;
                chai_1$1(p._validationError).not.to.be.undefined;
            });
        });
        describe('assignFrom', function () {
            it('copy the value if the target is null', function () {
                var Inner = (function (_super) {
                    __extends(Inner, _super);
                    function Inner() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], Inner.prototype, "name", void 0);
                    Inner = __decorate([
                        define
                    ], Inner);
                    return Inner;
                }(Record));
                var Test = (function (_super) {
                    __extends(Test, _super);
                    function Test() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr(Inner.value(null)),
                        __metadata("design:type", Inner)
                    ], Test.prototype, "inner", void 0);
                    Test = __decorate([
                        define
                    ], Test);
                    return Test;
                }(Record));
                var target = new Test(), source = new Test({ inner: { name: "ron" } });
                chai_1$1(target.inner).to.be.null;
                target.assignFrom(source);
                chai_1$1(target.inner !== source.inner).to.be.true;
            });
            it('assign object of similar shape', function () {
                var A = (function (_super) {
                    __extends(A, _super);
                    function A() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], A.prototype, "a", void 0);
                    A = __decorate([
                        define
                    ], A);
                    return A;
                }(Record));
                var B = (function (_super) {
                    __extends(B, _super);
                    function B() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], B.prototype, "b", void 0);
                    B = __decorate([
                        define
                    ], B);
                    return B;
                }(A));
                var b = new B({ b: "b" }), a = new A({ a: "a" });
                b.assignFrom(a);
            });
        });
        describe('Mixins', function () {
            it('can work with overriden atribute', function () {
                var Source = (function (_super) {
                    __extends(Source, _super);
                    function Source() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(Source.prototype, "hi", {
                        get: function () {
                            return 'hi';
                        },
                        enumerable: true,
                        configurable: true
                    });
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], Source.prototype, "name", void 0);
                    Source = __decorate([
                        define
                    ], Source);
                    return Source;
                }(Record));
                var Target = (function (_super) {
                    __extends(Target, _super);
                    function Target() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    __decorate([
                        attr,
                        __metadata("design:type", Number)
                    ], Target.prototype, "name", void 0);
                    Target = __decorate([
                        define,
                        mixins(Source)
                    ], Target);
                    return Target;
                }(Record));
                var t = new Target();
                t.name = "1";
                chai_1$1(t.name).to.eql(1);
                chai_1$1(t.hi).to.eql('hi');
            });
        });
    });

    var isStream_1 = createCommonjsModule(function (module) {

    var isStream = module.exports = function (stream$$1) {
    	return stream$$1 !== null && typeof stream$$1 === 'object' && typeof stream$$1.pipe === 'function';
    };

    isStream.writable = function (stream$$1) {
    	return isStream(stream$$1) && stream$$1.writable !== false && typeof stream$$1._write === 'function' && typeof stream$$1._writableState === 'object';
    };

    isStream.readable = function (stream$$1) {
    	return isStream(stream$$1) && stream$$1.readable !== false && typeof stream$$1._read === 'function' && typeof stream$$1._readableState === 'object';
    };

    isStream.duplex = function (stream$$1) {
    	return isStream.writable(stream$$1) && isStream.readable(stream$$1);
    };

    isStream.transform = function (stream$$1) {
    	return isStream.duplex(stream$$1) && typeof stream$$1._transform === 'function' && typeof stream$$1._transformState === 'object';
    };
    });

    /**
     * fetch-error.js
     *
     * FetchError interface for operational errors
     */

    var fetchError = FetchError;

    /**
     * Create FetchError instance
     *
     * @param   String      message      Error message for human
     * @param   String      type         Error type for machine
     * @param   String      systemError  For Node.js system error
     * @return  FetchError
     */
    function FetchError(message, type, systemError) {

    	this.name = this.constructor.name;
    	this.message = message;
    	this.type = type;

    	// when err.type is `system`, err.code contains system error code
    	if (systemError) {
    		this.code = this.errno = systemError.code;
    	}

    	// hide custom error implementation details from end-users
    	Error.captureStackTrace(this, this.constructor);
    }

    util.inherits(FetchError, Error);

    /**
     * body.js
     *
     * Body interface provides common methods for Request and Response
     */

    var convert = encoding.convert;

    var PassThrough = stream.PassThrough;


    var body = Body;

    /**
     * Body class
     *
     * @param   Stream  body  Readable stream
     * @param   Object  opts  Response options
     * @return  Void
     */
    function Body(body, opts) {

    	opts = opts || {};

    	this.body = body;
    	this.bodyUsed = false;
    	this.size = opts.size || 0;
    	this.timeout = opts.timeout || 0;
    	this._raw = [];
    	this._abort = false;

    }

    /**
     * Decode response as json
     *
     * @return  Promise
     */
    Body.prototype.json = function() {

    	var self = this;

    	return this._decode().then(function(buffer) {
    		try {
    			return JSON.parse(buffer.toString());
    		} catch (err) {
    			return Body.Promise.reject(new fetchError('invalid json response body at ' + self.url + ' reason: ' + err.message, 'invalid-json'));
    		}
    	});

    };

    /**
     * Decode response as text
     *
     * @return  Promise
     */
    Body.prototype.text = function() {

    	return this._decode().then(function(buffer) {
    		return buffer.toString();
    	});

    };

    /**
     * Decode response as buffer (non-spec api)
     *
     * @return  Promise
     */
    Body.prototype.buffer = function() {

    	return this._decode();

    };

    /**
     * Decode buffers into utf-8 string
     *
     * @return  Promise
     */
    Body.prototype._decode = function() {

    	var self = this;

    	if (this.bodyUsed) {
    		return Body.Promise.reject(new Error('body used already for: ' + this.url));
    	}

    	this.bodyUsed = true;
    	this._bytes = 0;
    	this._abort = false;
    	this._raw = [];

    	return new Body.Promise(function(resolve, reject) {
    		var resTimeout;

    		// body is string
    		if (typeof self.body === 'string') {
    			self._bytes = self.body.length;
    			self._raw = [new Buffer(self.body)];
    			return resolve(self._convert());
    		}

    		// body is buffer
    		if (self.body instanceof Buffer) {
    			self._bytes = self.body.length;
    			self._raw = [self.body];
    			return resolve(self._convert());
    		}

    		// allow timeout on slow response body
    		if (self.timeout) {
    			resTimeout = setTimeout(function() {
    				self._abort = true;
    				reject(new fetchError('response timeout at ' + self.url + ' over limit: ' + self.timeout, 'body-timeout'));
    			}, self.timeout);
    		}

    		// handle stream error, such as incorrect content-encoding
    		self.body.on('error', function(err) {
    			reject(new fetchError('invalid response body at: ' + self.url + ' reason: ' + err.message, 'system', err));
    		});

    		// body is stream
    		self.body.on('data', function(chunk) {
    			if (self._abort || chunk === null) {
    				return;
    			}

    			if (self.size && self._bytes + chunk.length > self.size) {
    				self._abort = true;
    				reject(new fetchError('content size at ' + self.url + ' over limit: ' + self.size, 'max-size'));
    				return;
    			}

    			self._bytes += chunk.length;
    			self._raw.push(chunk);
    		});

    		self.body.on('end', function() {
    			if (self._abort) {
    				return;
    			}

    			clearTimeout(resTimeout);
    			resolve(self._convert());
    		});
    	});

    };

    /**
     * Detect buffer encoding and convert to target encoding
     * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
     *
     * @param   String  encoding  Target encoding
     * @return  String
     */
    Body.prototype._convert = function(encoding$$1) {

    	encoding$$1 = encoding$$1 || 'utf-8';

    	var ct = this.headers.get('content-type');
    	var charset = 'utf-8';
    	var res, str;

    	// header
    	if (ct) {
    		// skip encoding detection altogether if not html/xml/plain text
    		if (!/text\/html|text\/plain|\+xml|\/xml/i.test(ct)) {
    			return Buffer.concat(this._raw);
    		}

    		res = /charset=([^;]*)/i.exec(ct);
    	}

    	// no charset in content type, peek at response body for at most 1024 bytes
    	if (!res && this._raw.length > 0) {
    		for (var i = 0; i < this._raw.length; i++) {
    			str += this._raw[i].toString();
    			if (str.length > 1024) {
    				break;
    			}
    		}
    		str = str.substr(0, 1024);
    	}

    	// html5
    	if (!res && str) {
    		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    	}

    	// html4
    	if (!res && str) {
    		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

    		if (res) {
    			res = /charset=(.*)/i.exec(res.pop());
    		}
    	}

    	// xml
    	if (!res && str) {
    		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    	}

    	// found charset
    	if (res) {
    		charset = res.pop();

    		// prevent decode issues when sites use incorrect encoding
    		// ref: https://hsivonen.fi/encoding-menu/
    		if (charset === 'gb2312' || charset === 'gbk') {
    			charset = 'gb18030';
    		}
    	}

    	// turn raw buffers into a single utf-8 buffer
    	return convert(
    		Buffer.concat(this._raw)
    		, encoding$$1
    		, charset
    	);

    };

    /**
     * Clone body given Res/Req instance
     *
     * @param   Mixed  instance  Response or Request instance
     * @return  Mixed
     */
    Body.prototype._clone = function(instance) {
    	var p1, p2;
    	var body = instance.body;

    	// don't allow cloning a used body
    	if (instance.bodyUsed) {
    		throw new Error('cannot clone body after it is used');
    	}

    	// check that body is a stream and not form-data object
    	// note: we can't clone the form-data object without having it as a dependency
    	if (isStream_1(body) && typeof body.getBoundary !== 'function') {
    		// tee instance body
    		p1 = new PassThrough();
    		p2 = new PassThrough();
    		body.pipe(p1);
    		body.pipe(p2);
    		// set instance body to teed body and return the other teed body
    		instance.body = p1;
    		body = p2;
    	}

    	return body;
    };

    // expose Promise
    Body.Promise = commonjsGlobal.Promise;

    /**
     * headers.js
     *
     * Headers class offers convenient helpers
     */

    var headers = Headers;

    /**
     * Headers class
     *
     * @param   Object  headers  Response headers
     * @return  Void
     */
    function Headers(headers) {

    	var self = this;
    	this._headers = {};

    	// Headers
    	if (headers instanceof Headers) {
    		headers = headers.raw();
    	}

    	// plain object
    	for (var prop in headers) {
    		if (!headers.hasOwnProperty(prop)) {
    			continue;
    		}

    		if (typeof headers[prop] === 'string') {
    			this.set(prop, headers[prop]);

    		} else if (typeof headers[prop] === 'number' && !isNaN(headers[prop])) {
    			this.set(prop, headers[prop].toString());

    		} else if (Array.isArray(headers[prop])) {
    			headers[prop].forEach(function(item) {
    				self.append(prop, item.toString());
    			});
    		}
    	}

    }

    /**
     * Return first header value given name
     *
     * @param   String  name  Header name
     * @return  Mixed
     */
    Headers.prototype.get = function(name) {
    	var list = this._headers[name.toLowerCase()];
    	return list ? list[0] : null;
    };

    /**
     * Return all header values given name
     *
     * @param   String  name  Header name
     * @return  Array
     */
    Headers.prototype.getAll = function(name) {
    	if (!this.has(name)) {
    		return [];
    	}

    	return this._headers[name.toLowerCase()];
    };

    /**
     * Iterate over all headers
     *
     * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
     * @param   Boolean   thisArg   `this` context for callback function
     * @return  Void
     */
    Headers.prototype.forEach = function(callback, thisArg) {
    	Object.getOwnPropertyNames(this._headers).forEach(function(name) {
    		this._headers[name].forEach(function(value) {
    			callback.call(thisArg, value, name, this);
    		}, this);
    	}, this);
    };

    /**
     * Overwrite header values given name
     *
     * @param   String  name   Header name
     * @param   String  value  Header value
     * @return  Void
     */
    Headers.prototype.set = function(name, value) {
    	this._headers[name.toLowerCase()] = [value];
    };

    /**
     * Append a value onto existing header
     *
     * @param   String  name   Header name
     * @param   String  value  Header value
     * @return  Void
     */
    Headers.prototype.append = function(name, value) {
    	if (!this.has(name)) {
    		this.set(name, value);
    		return;
    	}

    	this._headers[name.toLowerCase()].push(value);
    };

    /**
     * Check for header name existence
     *
     * @param   String   name  Header name
     * @return  Boolean
     */
    Headers.prototype.has = function(name) {
    	return this._headers.hasOwnProperty(name.toLowerCase());
    };

    /**
     * Delete all header values given name
     *
     * @param   String  name  Header name
     * @return  Void
     */
    Headers.prototype['delete'] = function(name) {
    	delete this._headers[name.toLowerCase()];
    };

    /**
     * Return raw headers (non-spec api)
     *
     * @return  Object
     */
    Headers.prototype.raw = function() {
    	return this._headers;
    };

    /**
     * response.js
     *
     * Response class provides content decoding
     */





    var response = Response;

    /**
     * Response class
     *
     * @param   Stream  body  Readable stream
     * @param   Object  opts  Response options
     * @return  Void
     */
    function Response(body$$1, opts) {

    	opts = opts || {};

    	this.url = opts.url;
    	this.status = opts.status || 200;
    	this.statusText = opts.statusText || http.STATUS_CODES[this.status];
    	this.headers = new headers(opts.headers);
    	this.ok = this.status >= 200 && this.status < 300;

    	body.call(this, body$$1, opts);

    }

    Response.prototype = Object.create(body.prototype);

    /**
     * Clone this response
     *
     * @return  Response
     */
    Response.prototype.clone = function() {
    	return new Response(this._clone(this), {
    		url: this.url
    		, status: this.status
    		, statusText: this.statusText
    		, headers: this.headers
    		, ok: this.ok
    	});
    };

    /**
     * request.js
     *
     * Request class contains server only options
     */

    var parse_url = url.parse;



    var request = Request;

    /**
     * Request class
     *
     * @param   Mixed   input  Url or Request instance
     * @param   Object  init   Custom options
     * @return  Void
     */
    function Request(input, init) {
    	var url$$1, url_parsed;

    	// normalize input
    	if (!(input instanceof Request)) {
    		url$$1 = input;
    		url_parsed = parse_url(url$$1);
    		input = {};
    	} else {
    		url$$1 = input.url;
    		url_parsed = parse_url(url$$1);
    	}

    	// normalize init
    	init = init || {};

    	// fetch spec options
    	this.method = init.method || input.method || 'GET';
    	this.redirect = init.redirect || input.redirect || 'follow';
    	this.headers = new headers(init.headers || input.headers || {});
    	this.url = url$$1;

    	// server only options
    	this.follow = init.follow !== undefined ?
    		init.follow : input.follow !== undefined ?
    		input.follow : 20;
    	this.compress = init.compress !== undefined ?
    		init.compress : input.compress !== undefined ?
    		input.compress : true;
    	this.counter = init.counter || input.counter || 0;
    	this.agent = init.agent || input.agent;

    	body.call(this, init.body || this._clone(input), {
    		timeout: init.timeout || input.timeout || 0,
    		size: init.size || input.size || 0
    	});

    	// server request options
    	this.protocol = url_parsed.protocol;
    	this.hostname = url_parsed.hostname;
    	this.port = url_parsed.port;
    	this.path = url_parsed.path;
    	this.auth = url_parsed.auth;
    }

    Request.prototype = Object.create(body.prototype);

    /**
     * Clone this request
     *
     * @return  Request
     */
    Request.prototype.clone = function() {
    	return new Request(this);
    };

    var nodeFetch = createCommonjsModule(function (module) {
    /**
     * index.js
     *
     * a request API compatible with window.fetch
     */

    var parse_url = url.parse;
    var resolve_url = url.resolve;











    // commonjs
    module.exports = Fetch;
    // es6 default export compatibility
    module.exports.default = module.exports;

    /**
     * Fetch class
     *
     * @param   Mixed    url   Absolute url or Request instance
     * @param   Object   opts  Fetch options
     * @return  Promise
     */
    function Fetch(url$$1, opts) {

    	// allow call as function
    	if (!(this instanceof Fetch))
    		return new Fetch(url$$1, opts);

    	// allow custom promise
    	if (!Fetch.Promise) {
    		throw new Error('native promise missing, set Fetch.Promise to your favorite alternative');
    	}

    	body.Promise = Fetch.Promise;

    	var self = this;

    	// wrap http.request into fetch
    	return new Fetch.Promise(function(resolve, reject) {
    		// build request object
    		var options = new request(url$$1, opts);

    		if (!options.protocol || !options.hostname) {
    			throw new Error('only absolute urls are supported');
    		}

    		if (options.protocol !== 'http:' && options.protocol !== 'https:') {
    			throw new Error('only http(s) protocols are supported');
    		}

    		var send;
    		if (options.protocol === 'https:') {
    			send = https.request;
    		} else {
    			send = http.request;
    		}

    		// normalize headers
    		var headers$$1 = new headers(options.headers);

    		if (options.compress) {
    			headers$$1.set('accept-encoding', 'gzip,deflate');
    		}

    		if (!headers$$1.has('user-agent')) {
    			headers$$1.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    		}

    		if (!headers$$1.has('connection') && !options.agent) {
    			headers$$1.set('connection', 'close');
    		}

    		if (!headers$$1.has('accept')) {
    			headers$$1.set('accept', '*/*');
    		}

    		// detect form data input from form-data module, this hack avoid the need to pass multipart header manually
    		if (!headers$$1.has('content-type') && options.body && typeof options.body.getBoundary === 'function') {
    			headers$$1.set('content-type', 'multipart/form-data; boundary=' + options.body.getBoundary());
    		}

    		// bring node-fetch closer to browser behavior by setting content-length automatically
    		if (!headers$$1.has('content-length') && /post|put|patch|delete/i.test(options.method)) {
    			if (typeof options.body === 'string') {
    				headers$$1.set('content-length', Buffer.byteLength(options.body));
    			// detect form data input from form-data module, this hack avoid the need to add content-length header manually
    			} else if (options.body && typeof options.body.getLengthSync === 'function') {
    				// for form-data 1.x
    				if (options.body._lengthRetrievers && options.body._lengthRetrievers.length == 0) {
    					headers$$1.set('content-length', options.body.getLengthSync().toString());
    				// for form-data 2.x
    				} else if (options.body.hasKnownLength && options.body.hasKnownLength()) {
    					headers$$1.set('content-length', options.body.getLengthSync().toString());
    				}
    			// this is only necessary for older nodejs releases (before iojs merge)
    			} else if (options.body === undefined || options.body === null) {
    				headers$$1.set('content-length', '0');
    			}
    		}

    		options.headers = headers$$1.raw();

    		// http.request only support string as host header, this hack make custom host header possible
    		if (options.headers.host) {
    			options.headers.host = options.headers.host[0];
    		}

    		// send request
    		var req = send(options);
    		var reqTimeout;

    		if (options.timeout) {
    			req.once('socket', function(socket) {
    				reqTimeout = setTimeout(function() {
    					req.abort();
    					reject(new fetchError('network timeout at: ' + options.url, 'request-timeout'));
    				}, options.timeout);
    			});
    		}

    		req.on('error', function(err) {
    			clearTimeout(reqTimeout);
    			reject(new fetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system', err));
    		});

    		req.on('response', function(res) {
    			clearTimeout(reqTimeout);

    			// handle redirect
    			if (self.isRedirect(res.statusCode) && options.redirect !== 'manual') {
    				if (options.redirect === 'error') {
    					reject(new fetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));
    					return;
    				}

    				if (options.counter >= options.follow) {
    					reject(new fetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));
    					return;
    				}

    				if (!res.headers.location) {
    					reject(new fetchError('redirect location header missing at: ' + options.url, 'invalid-redirect'));
    					return;
    				}

    				// per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect
    				if (res.statusCode === 303
    					|| ((res.statusCode === 301 || res.statusCode === 302) && options.method === 'POST'))
    				{
    					options.method = 'GET';
    					delete options.body;
    					delete options.headers['content-length'];
    				}

    				options.counter++;

    				resolve(Fetch(resolve_url(options.url, res.headers.location), options));
    				return;
    			}

    			// normalize location header for manual redirect mode
    			var headers$$1 = new headers(res.headers);
    			if (options.redirect === 'manual' && headers$$1.has('location')) {
    				headers$$1.set('location', resolve_url(options.url, headers$$1.get('location')));
    			}

    			// prepare response
    			var body$$1 = res.pipe(new stream.PassThrough());
    			var response_options = {
    				url: options.url
    				, status: res.statusCode
    				, statusText: res.statusMessage
    				, headers: headers$$1
    				, size: options.size
    				, timeout: options.timeout
    			};

    			// response object
    			var output;

    			// in following scenarios we ignore compression support
    			// 1. compression support is disabled
    			// 2. HEAD request
    			// 3. no content-encoding header
    			// 4. no content response (204)
    			// 5. content not modified response (304)
    			if (!options.compress || options.method === 'HEAD' || !headers$$1.has('content-encoding') || res.statusCode === 204 || res.statusCode === 304) {
    				output = new response(body$$1, response_options);
    				resolve(output);
    				return;
    			}

    			// otherwise, check for gzip or deflate
    			var name = headers$$1.get('content-encoding');

    			// for gzip
    			if (name == 'gzip' || name == 'x-gzip') {
    				body$$1 = body$$1.pipe(zlib.createGunzip());
    				output = new response(body$$1, response_options);
    				resolve(output);
    				return;

    			// for deflate
    			} else if (name == 'deflate' || name == 'x-deflate') {
    				// handle the infamous raw deflate response from old servers
    				// a hack for old IIS and Apache servers
    				var raw = res.pipe(new stream.PassThrough());
    				raw.once('data', function(chunk) {
    					// see http://stackoverflow.com/questions/37519828
    					if ((chunk[0] & 0x0F) === 0x08) {
    						body$$1 = body$$1.pipe(zlib.createInflate());
    					} else {
    						body$$1 = body$$1.pipe(zlib.createInflateRaw());
    					}
    					output = new response(body$$1, response_options);
    					resolve(output);
    				});
    				return;
    			}

    			// otherwise, use response as-is
    			output = new response(body$$1, response_options);
    			resolve(output);
    			return;
    		});

    		// accept string, buffer or readable stream as body
    		// per spec we will call tostring on non-stream objects
    		if (typeof options.body === 'string') {
    			req.write(options.body);
    			req.end();
    		} else if (options.body instanceof Buffer) {
    			req.write(options.body);
    			req.end();
    		} else if (typeof options.body === 'object' && options.body.pipe) {
    			options.body.pipe(req);
    		} else if (typeof options.body === 'object') {
    			req.write(options.body.toString());
    			req.end();
    		} else {
    			req.end();
    		}
    	});

    }
    /**
     * Redirect code matching
     *
     * @param   Number   code  Status code
     * @return  Boolean
     */
    Fetch.prototype.isRedirect = function(code) {
    	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };

    // expose Promise
    Fetch.Promise = commonjsGlobal.Promise;
    Fetch.Response = response;
    Fetch.Headers = headers;
    Fetch.Request = request;
    });

    var fetchNpmNode = createCommonjsModule(function (module) {


    module.exports = function(url$$1, options) {
    	if (/^\/\//.test(url$$1)) {
    		url$$1 = 'https:' + url$$1;
    	}
    	return nodeFetch.call(this, url$$1, options);
    };

    if (!commonjsGlobal.fetch) {
    	commonjsGlobal.fetch = module.exports;
    	commonjsGlobal.Response = nodeFetch.Response;
    	commonjsGlobal.Headers = nodeFetch.Headers;
    	commonjsGlobal.Request = nodeFetch.Request;
    }
    });

    function create(init, delay) {
        if (init === void 0) { init = []; }
        if (delay === void 0) { delay = 50; }
        return new MemoryEndpoint(init, delay);
    }
    var MemoryEndpoint = (function () {
        function MemoryEndpoint(init, delay) {
            this.delay = delay;
            this.index = [0];
            this.items = {};
            for (var _i = 0, init_1 = init; _i < init_1.length; _i++) {
                var obj = init_1[_i];
                this.create(obj, {});
            }
        }
        MemoryEndpoint.prototype.resolve = function (value$$1) {
            var _this = this;
            return createIOPromise(function (resolve, reject) {
                setTimeout(function () { return resolve(value$$1); }, _this.delay);
            });
        };
        MemoryEndpoint.prototype.reject = function (value$$1) {
            var _this = this;
            return createIOPromise(function (resolve, reject) {
                setTimeout(function () { return reject(value$$1); }, _this.delay);
            });
        };
        MemoryEndpoint.prototype.generateId = function (a_id) {
            var id = Number(a_id);
            if (!isNaN(id)) {
                this.index[0] = Math.max(this.index[0], id);
            }
            return a_id || String(this.index[0]++);
        };
        MemoryEndpoint.prototype.create = function (json, options) {
            var id = json.id = this.generateId(json.id);
            this.index.push(id);
            this.items[id] = json;
            return this.resolve({ id: id });
        };
        MemoryEndpoint.prototype.update = function (id, json, options) {
            this.items[id] = json;
            return this.resolve({});
        };
        MemoryEndpoint.prototype.read = function (id, options) {
            var existing = this.items[id];
            return existing ?
                this.resolve(existing) :
                this.reject("Not found");
        };
        MemoryEndpoint.prototype.destroy = function (id, options) {
            var existing = this.items[id];
            if (existing) {
                delete this.items[id];
                this.index = this.index.filter(function (x) { return x !== id; });
                return this.resolve({});
            }
            else {
                return this.reject("Not found");
            }
        };
        MemoryEndpoint.prototype.list = function (options) {
            var _this = this;
            return this.resolve(this.index.slice(1).map(function (id) { return _this.items[id]; }));
        };
        MemoryEndpoint.prototype.subscribe = function (events$$1) { };
        MemoryEndpoint.prototype.unsubscribe = function (events$$1) { };
        return MemoryEndpoint;
    }());

    function create$1() {
        return new AttributesEndpoint();
    }
    var AttributesEndpoint = (function () {
        function AttributesEndpoint() {
        }
        AttributesEndpoint.prototype.create = function (json, options) {
            throw new Error('Method is not supported.');
        };
        AttributesEndpoint.prototype.update = function (id, json, options) {
            throw new Error('Method is not supported.');
        };
        AttributesEndpoint.prototype.read = function (id, options, record) {
            var names = record.keys().filter(function (name) { return record[name] && record[name].fetch; }), promises = names.map(function (name) { return record[name].fetch(options); }), promise = Promise.all(promises).then(function () { });
            promise.abort = function () {
                promises.forEach(function (x) { return x.abort && x.abort(); });
            };
            return promise;
        };
        AttributesEndpoint.prototype.destroy = function (id, options) {
            throw new Error('Method is not supported.');
        };
        AttributesEndpoint.prototype.list = function (options) {
            throw new Error('Method is not supported.');
        };
        AttributesEndpoint.prototype.subscribe = function (events$$1) { };
        AttributesEndpoint.prototype.unsubscribe = function (events$$1) { };
        return AttributesEndpoint;
    }());

    function create$2(key) {
        return new LocalStorageEndpoint(key);
    }
    var LocalStorageEndpoint = (function () {
        function LocalStorageEndpoint(key) {
            this.key = key;
        }
        LocalStorageEndpoint.prototype.resolve = function (value$$1) {
            return createIOPromise(function (resolve, reject) {
                setTimeout(function () {
                    resolve(value$$1);
                }, 0);
            });
        };
        LocalStorageEndpoint.prototype.reject = function (value$$1) {
            return createIOPromise(function (resolve, reject) {
                setTimeout(function () { return reject(value$$1); }, 0);
            });
        };
        LocalStorageEndpoint.prototype.create = function (json, options) {
            var index = this.index;
            index.push(json.id = String(index[0]++));
            this.index = index;
            this.set(json);
            return this.resolve({ id: json.id });
        };
        LocalStorageEndpoint.prototype.set = function (json) {
            localStorage.setItem(this.key + '#' + json.id, JSON.stringify(json));
        };
        LocalStorageEndpoint.prototype.get = function (id) {
            return JSON.parse(localStorage.getItem(this.key + '#' + id));
        };
        LocalStorageEndpoint.prototype.update = function (id, json, options) {
            json.id = id;
            this.set(json);
            return this.resolve({});
        };
        LocalStorageEndpoint.prototype.read = function (id, options) {
            var existing = this.get(id);
            return existing ?
                this.resolve(existing) :
                this.reject("Not found");
        };
        LocalStorageEndpoint.prototype.destroy = function (id, options) {
            var existing = this.get(id);
            if (existing) {
                localStorage.removeItem(this.key + '#' + id);
                this.index = this.index.filter(function (x) { return x !== id; });
                return this.resolve({});
            }
            else {
                return this.reject("Not found");
            }
        };
        Object.defineProperty(LocalStorageEndpoint.prototype, "index", {
            get: function () {
                return JSON.parse(localStorage.getItem(this.key)) || [0];
            },
            set: function (x) {
                localStorage.setItem(this.key, JSON.stringify(x));
            },
            enumerable: true,
            configurable: true
        });
        LocalStorageEndpoint.prototype.list = function (options) {
            var _this = this;
            var index = this.index;
            return this.resolve(this.index.slice(1).map(function (id) { return _this.get(id); }));
        };
        LocalStorageEndpoint.prototype.subscribe = function (events$$1) { };
        LocalStorageEndpoint.prototype.unsubscribe = function (events$$1) { };
        return LocalStorageEndpoint;
    }());

    function create$3(url$$1, fetchOptions) {
        return new RestfulEndpoint(url$$1, fetchOptions);
    }
    var RestfulEndpoint = (function () {
        function RestfulEndpoint(url$$1, fetchOptions) {
            this.url = url$$1;
            this.fetchOptions = fetchOptions;
        }
        RestfulEndpoint.prototype.create = function (json, options, record) {
            return this.request('POST', this.collectionUrl(record, options), options, json);
        };
        RestfulEndpoint.prototype.update = function (id, json, options, record) {
            return this.request('PUT', this.objectUrl(record, id, options), options, json);
        };
        RestfulEndpoint.prototype.read = function (id, options, record) {
            return this.request('GET', this.objectUrl(record, id, options), options);
        };
        RestfulEndpoint.prototype.destroy = function (id, options, record) {
            return this.request('DELETE', this.objectUrl(record, id, options), options);
        };
        RestfulEndpoint.prototype.list = function (options, collection) {
            return this.request('GET', this.collectionUrl(collection, options), options);
        };
        RestfulEndpoint.prototype.subscribe = function (events$$1) { };
        RestfulEndpoint.prototype.unsubscribe = function (events$$1) { };
        RestfulEndpoint.prototype.isRelativeUrl = function (url$$1) {
            return url$$1.indexOf('./') === 0;
        };
        RestfulEndpoint.prototype.removeTrailingSlash = function (url$$1) {
            var endsWithSlash = url$$1.charAt(url$$1.length - 1) === '/';
            return endsWithSlash ? url$$1.substr(0, url$$1.length - 1) : url$$1;
        };
        RestfulEndpoint.prototype.getRootUrl = function (recordOrCollection) {
            var url$$1 = this.url;
            if (this.isRelativeUrl(url$$1)) {
                var owner = recordOrCollection.getOwner(), ownerUrl = owner.getEndpoint().getUrl(owner);
                return this.removeTrailingSlash(ownerUrl) + '/' + url$$1.substr(2);
            }
            else {
                return url$$1;
            }
        };
        RestfulEndpoint.prototype.getUrl = function (record) {
            var url$$1 = this.getRootUrl(record);
            return record.isNew()
                ? url$$1
                : this.removeTrailingSlash(url$$1) + '/' + record.id;
        };
        RestfulEndpoint.prototype.objectUrl = function (record, id, options) {
            return appendParams(this.getUrl(record), options.params);
        };
        RestfulEndpoint.prototype.collectionUrl = function (collection, options) {
            return appendParams(this.getRootUrl(collection), options.params);
        };
        RestfulEndpoint.prototype.buildRequestOptions = function (method, options, body) {
            var mergedOptions = Object.assign({}, RestfulEndpoint.defaultFetchOptions, this.fetchOptions, options);
            var headers = mergedOptions.headers, rest = __rest(mergedOptions, ["headers"]), resultOptions = __assign({ method: method, headers: __assign({ 'Content-Type': 'application/json' }, headers) }, rest);
            if (body) {
                resultOptions.body = JSON.stringify(body);
            }
            return resultOptions;
        };
        RestfulEndpoint.prototype.request = function (method, url$$1, _a, body) {
            var options = _a.options;
            return fetch(url$$1, this.buildRequestOptions(method, options, body))
                .then(function (response) {
                if (response.ok) {
                    return response.json();
                }
                else {
                    throw new Error(response.statusText);
                }
            });
        };
        RestfulEndpoint.defaultFetchOptions = {
            cache: "no-cache",
            credentials: "same-origin",
            mode: "cors",
            redirect: "error",
        };
        return RestfulEndpoint;
    }());
    function appendParams(url$$1, params) {
        var esc = encodeURIComponent;
        return params
            ? url$$1 + '?' + Object.keys(params)
                .map(function (k) { return esc(k) + '=' + esc(params[k]); })
                .join('&')
            : url$$1;
    }

    var lodash = createCommonjsModule(function (module, exports) {
    (function() {

      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined;

      /** Used as the semantic version number. */
      var VERSION = '4.17.10';

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function';

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG]
      ];

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';

      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/;

      /** Used to match wrap detail comments. */
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      var reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join('|'), 'g');

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];

      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
      typedArrayTags[errorTag] = typedArrayTags[funcTag] =
      typedArrayTags[mapTag] = typedArrayTags[numberTag] =
      typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
      typedArrayTags[setTag] = typedArrayTags[stringTag] =
      typedArrayTags[weakMapTag] = false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
      cloneableTags[boolTag] = cloneableTags[dateTag] =
      cloneableTags[float32Tag] = cloneableTags[float64Tag] =
      cloneableTags[int8Tag] = cloneableTags[int16Tag] =
      cloneableTags[int32Tag] = cloneableTags[mapTag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[setTag] =
      cloneableTags[stringTag] = cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J',  '\u0135': 'j',
        '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't',  '\u0165': 't', '\u0167': 't',
        '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W',  '\u0175': 'w',
        '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
      };

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };

      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      var freeExports = exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      var freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      var nodeUtil = (function() {
        try {
          // Use `util.types` for Node.js 10+.
          var types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

      /* Node.js helper references. */
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      var asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;

        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined) {
            result = result === undefined ? current : (result + current);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      var deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Gets the value at `key`, unless `key` is "__proto__".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function safeGet(object, key) {
        return key == '__proto__'
          ? undefined
          : object[key];
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string)
          ? unicodeSize(string)
          : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      var runInContext = (function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

        /** Used for built-in method references. */
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        var coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        var idCounter = 0;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
            symIterator = Symbol ? Symbol.iterator : undefined,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined;

        var defineProperty = (function() {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }());

        /** Mocked built-ins. */
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        /** Used to lookup unminified function names. */
        var realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined;
            return result;
          };
        }());

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {

          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];

          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;

            var iterIndex = -1,
                value = array[index];

            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          return index < 0 ? undefined : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
              size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values == null ? 0 : values.length;

          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache;
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                   // Safari 9 has enumerable `arguments.length` in strict mode.
                   key == 'length' ||
                   // Node.js 0.10 has enumerable non-index properties on buffers.
                   (isBuff && (key == 'offset' || key == 'parent')) ||
                   // PhantomJS 2 has enumerable non-index properties on typed arrays.
                   (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                   // Skip index properties.
                   isIndex(key, length)
                ))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined && !eq(object[key], value)) ||
              (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = (isFlat || isFunc) ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });

            return result;
          }

          if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });

            return result;
          }

          var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys);

          var props = isArr ? undefined : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            var key = props[length],
                predicate = source[key],
                value = object[key];

            if ((value === undefined && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee == null ? value : iteratee(value);

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;

          while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined
                  ? (current === current && !isSymbol(current))
                  : comparator(current, computed)
                )) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path$$1) {
          path$$1 = castPath(path$$1, object);

          var index = 0,
              length = path$$1.length;

          while (object != null && index < length) {
            object = object[toKey(path$$1[index++])];
          }
          return (index && index == length) ? object : undefined;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }
          return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined;
          }
          array = arrays[0];

          var index = -1,
              seen = caches[0];

          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path$$1, args) {
          path$$1 = castPath(path$$1, object);
          object = parent(object, path$$1);
          var func = object == null ? object : object[toKey(last(path$$1))];
          return func == null ? undefined : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
              result = [];

          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path$$1, srcValue) {
          if (isKey(path$$1) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path$$1), srcValue);
          }
          return function(object) {
            var objValue = get(object, path$$1);
            return (objValue === undefined && objValue === srcValue)
              ? hasIn(object, path$$1)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            if (isObject(srcValue)) {
              stack || (stack = new Stack);
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined;

              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined;

          var isCommon = newValue === undefined;

          if (isCommon) {
            var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              }
              else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              }
              else {
                newValue = [];
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                newValue = initCloneObject(srcValue);
              }
            }
            else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          var index = -1;
          iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });

          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path$$1) {
            return hasIn(object, path$$1);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          var index = -1,
              length = paths.length,
              result = {};

          while (++index < length) {
            var path$$1 = paths[index],
                value = baseGet(object, path$$1);

            if (predicate(value, path$$1)) {
              baseSet(result, castPath(path$$1, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path$$1) {
          return function(object) {
            return baseGet(object, path$$1);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;

          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path$$1, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path$$1 = castPath(path$$1, object);

          var index = -1,
              length = path$$1.length,
              lastIndex = length - 1,
              nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path$$1[index]),
                newValue = value;

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = isObject(objValue)
                  ? objValue
                  : (isIndex(path$$1[index + 1]) ? [] : {});
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;

          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;

          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];

              if (computed !== null && !isSymbol(computed) &&
                  (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);

          var low = 0,
              high = array == null ? 0 : array.length,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined;

          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path$$1) {
          path$$1 = castPath(path$$1, object);
          object = parent(object, path$$1);
          return object == null || delete object[toKey(last(path$$1))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path$$1, updater, customizer) {
          return baseSet(object, path$$1, updater(baseGet(object, path$$1)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
              result = Array(length);

          while (++index < length) {
            var array = arrays[index],
                othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};

          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        var castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);

            var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});

          var index = -1,
              length = props.length;

          while (++index < length) {
            var key = props[index];

            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined;

            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;

            customizer = (assigner.length > 3 && typeof customizer == 'function')
              ? (length--, customizer)
              : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);

            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined;

            var chr = strSymbols
              ? strSymbols[0]
              : string.charAt(0);

            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, undefined,
                args, holders, undefined, undefined, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) { return iteratee(iterable[key], key, iterable); };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;

              if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func))
                  ? wrapper[funcName]()
                  : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result;
            if (value === undefined && other === undefined) {
              return defaultValue;
            }
            if (value !== undefined) {
              result = value;
            }
            if (other !== undefined) {
              if (result === undefined) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined ? ' ' : baseToString(chars);

          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars)
            ? castSlice(stringToArray(result), 0, length).join('')
            : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined,
              newHoldersRight = isCurry ? undefined : holders,
              newPartials = isCurry ? partials : undefined,
              newPartialsRight = isCurry ? undefined : partials;

          bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, argPos, ary, arity
          ];

          var result = wrapFunc.apply(undefined, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func);

          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index = -1,
              result = true,
              seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                result = false;
                break;
              }
            } else if (!(
                  arrValue === othValue ||
                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) ||
                  (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == (other + '');

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);

          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined
                  ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;

          while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined;
          } catch (e) {}

          var result = nativeObjectToString.call(value);
          {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString: return dataViewTag;
                case mapCtorString: return mapTag;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;

          while (++index < length) {
            var data = transforms[index],
                size = data.size;

            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path$$1, hasFunc) {
          path$$1 = castPath(path$$1, object);

          var index = -1,
              length = path$$1.length,
              result = false;

          while (++index < length) {
            var key = toKey(path$$1[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor;

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor;

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return !!length &&
            (type == 'number' ||
              (type != 'symbol' && reIsUint.test(value))) &&
                (value > -1 && value % 1 == 0 && value < length);
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)
              ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' ||
              value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        var isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue &&
              (srcValue !== undefined || (key in Object(object)));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          var isCombo =
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path$$1) {
          return path$$1.length < 2 ? object : baseGet(object, baseSlice(path$$1, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);

          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          var source = (reference + '');
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
              lastCalled = 0;

          return function() {
            var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          var index = -1,
              length = array.length,
              lastIndex = length - 1;

          size = size === undefined ? length : size;
          while (++index < size) {
            var rand = baseRandom(index, lastIndex),
                value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function(string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = '_.' + pair[0];
            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array(length - 1),
              array = arguments[0],
              index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        var difference = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = baseRest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = baseRest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = fromIndex < 0
              ? nativeMax(length + index, 0)
              : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};

          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return (array && array.length) ? array[0] : undefined;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = baseRest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined;
          if (comparator) {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined, comparator)
            : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        var pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);

          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniq(array, getIteratee(iteratee, 2))
            : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        var without = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        var zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };

          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined : this.__values__[this.__index__++];

          return { 'done': done, 'value': value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;

          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        var find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = baseRest(function(collection, path$$1, args) {
          var index = -1,
              isFunc = typeof path$$1 == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value) {
            result[++index] = isFunc ? apply(path$$1, value, args) : baseInvoke(value, path$$1, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
         */
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = ctxNow || function() {
          return root.Date.now();
        };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined : n;
          n = (func && n == null) ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;

            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }

          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
              (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }

          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }

          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }

          function flush() {
            return timerId === undefined ? result : trailingEdge(now());
          }

          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0: return !predicate.call(this);
              case 1: return !predicate.call(this, args[0]);
              case 2: return !predicate.call(this, args[0], args[1]);
              case 3: return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = castRest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0]))
            ? arrayMap(transforms[0], baseUnary(getIteratee()))
            : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        var gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        var lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, '');
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : (value === 0 ? value : 0);
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        var at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var defaults = baseRest(function(object, sources) {
          object = Object(object);

          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (value === undefined ||
                  (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined, customDefaultsMerge);
          return apply(mergeWith, undefined, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path$$1, defaultValue) {
          var result = object == null ? undefined : baseGet(object, path$$1);
          return result === undefined ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path$$1) {
          return object != null && hasPath(object, path$$1, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path$$1) {
          return object != null && hasPath(object, path$$1, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function(object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path$$1) {
            path$$1 = castPath(path$$1, object);
            isDeep || (isDeep = path$$1.length > 1);
            return path$$1;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path$$1) {
            return predicate(value, path$$1[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path$$1, defaultValue) {
          path$$1 = castPath(path$$1, object);

          var index = -1,
              length = path$$1.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined;
          }
          while (++index < length) {
            var value = object == null ? undefined : object[toKey(path$$1[index])];
            if (value === undefined) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path$$1, value) {
          return object == null ? object : baseSet(object, path$$1, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path$$1, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseSet(object, path$$1, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        var toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        var toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor : [];
            }
            else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path$$1) {
          return object == null ? true : baseUnset(object, path$$1);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path$$1, updater) {
          return object == null ? object : baseUpdate(object, path$$1, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path$$1, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseUpdate(object, path$$1, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined) {
            upper = lower;
            lower = undefined;
          }
          if (upper !== undefined) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined;
          }
          if (floating === undefined) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined;
            }
          }
          if (lower === undefined && upper === undefined) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toFinite(lower);
            if (upper === undefined) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('dj vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          var length = string.length;
          position = position === undefined
            ? length
            : baseClamp(toInteger(position), 0, length);

          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (string + createPadding(length - strLength, chars))
            : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (createPadding(length - strLength, chars) + string)
            : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined;
          }
          limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (
                typeof separator == 'string' ||
                (separator != null && !isRegExp(separator))
              )) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null
            ? 0
            : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');

          // Use a sourceURL for easier debugging.
          var sourceURL = '//# sourceURL=' +
            ('sourceURL' in options
              ? options.sourceURL
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';

          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';

          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrim, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimEnd, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end);

          if (separator === undefined) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined : pattern;

          if (pattern === undefined) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();

          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });

          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return (value == null || value !== value) ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         */
        function matchesProperty(path$$1, srcValue) {
          return baseMatchesProperty(path$$1, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        var method = baseRest(function(path$$1, args) {
          return function(object) {
            return baseInvoke(object, path$$1, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = baseRest(function(object, args) {
          return function(path$$1) {
            return baseInvoke(object, path$$1, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);

          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);

          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);

                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         */
        var overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path$$1) {
          return isKey(path$$1) ? baseProperty(toKey(path$$1)) : basePropertyDeep(path$$1);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path$$1) {
            return object == null ? undefined : baseGet(object, path$$1);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseGt)
            : undefined;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
            : undefined;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseLt)
            : undefined;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
            : undefined;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee, 2))
            : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

            var result = (this.__filtered__ && !index)
              ? new LazyWrapper(this)
              : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function(path$$1, args) {
          if (typeof path$$1 == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path$$1, args);
          });
        });

        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);

          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = (lodashFunc.name + ''),
                names = realNames[key] || (realNames[key] = []);

            names.push({ 'name': methodName, 'func': lodashFunc });
          }
        });

        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(commonjsGlobal));
    });

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      return plural(ms, d, 'day') ||
        plural(ms, h, 'hour') ||
        plural(ms, m, 'minute') ||
        plural(ms, s, 'second') ||
        ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }

    var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;

    /**
     * Active `debug` instances.
     */
    exports.instances = [];

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0, i;

      for (i in namespace) {
        hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      var prevTime;

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms$$1 = curr - (prevTime || curr);
        self.diff = ms$$1;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      exports.instances.push(debug);

      return debug;
    }

    function destroy () {
      var index = exports.instances.indexOf(this);
      if (index !== -1) {
        exports.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < exports.instances.length; i++) {
        var instance = exports.instances[i];
        instance.enabled = exports.enabled(instance.namespace);
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    });
    var debug_1 = debug.coerce;
    var debug_2 = debug.disable;
    var debug_3 = debug.enable;
    var debug_4 = debug.enabled;
    var debug_5 = debug.humanize;
    var debug_6 = debug.instances;
    var debug_7 = debug.names;
    var debug_8 = debug.skips;
    var debug_9 = debug.formatters;

    var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
                   && 'undefined' != typeof chrome.storage
                      ? chrome.storage.local
                      : localstorage();

    /**
     * Colors.
     */

    exports.colors = [
      '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
      '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
      '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
      '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
      '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
      '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
      '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
      '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
      '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
      '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
      '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
        // double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console
        && console.log
        && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch(e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
    });
    var browser_1 = browser.log;
    var browser_2 = browser.formatArgs;
    var browser_3 = browser.save;
    var browser_4 = browser.load;
    var browser_5 = browser.useColors;
    var browser_6 = browser.storage;
    var browser_7 = browser.colors;

    var hasFlag = function (flag, argv) {
    	argv = argv || process.argv;

    	var terminatorPos = argv.indexOf('--');
    	var prefix = /^--/.test(flag) ? '' : '--';
    	var pos = argv.indexOf(prefix + flag);

    	return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);
    };

    var support = function (level) {
    	if (level === 0) {
    		return false;
    	}

    	return {
    		level: level,
    		hasBasic: true,
    		has256: level >= 2,
    		has16m: level >= 3
    	};
    };

    var supportLevel = (function () {
    	if (hasFlag('no-color') ||
    		hasFlag('no-colors') ||
    		hasFlag('color=false')) {
    		return 0;
    	}

    	if (hasFlag('color=16m') ||
    		hasFlag('color=full') ||
    		hasFlag('color=truecolor')) {
    		return 3;
    	}

    	if (hasFlag('color=256')) {
    		return 2;
    	}

    	if (hasFlag('color') ||
    		hasFlag('colors') ||
    		hasFlag('color=true') ||
    		hasFlag('color=always')) {
    		return 1;
    	}

    	if (process.stdout && !process.stdout.isTTY) {
    		return 0;
    	}

    	if (process.platform === 'win32') {
    		return 1;
    	}

    	if ('COLORTERM' in process.env) {
    		return 1;
    	}

    	if (process.env.TERM === 'dumb') {
    		return 0;
    	}

    	if (/^xterm-256(?:color)?/.test(process.env.TERM)) {
    		return 2;
    	}

    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return 1;
    	}

    	return 0;
    })();

    if (supportLevel === 0 && 'FORCE_COLOR' in process.env) {
    	supportLevel = 1;
    }

    var supportsColor = process && support(supportLevel);

    var node = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */




    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;

    /**
     * Colors.
     */

    exports.colors = [ 6, 2, 3, 4, 5, 1 ];

    try {
      var supportsColor$$1 = supportsColor;
      if (supportsColor$$1 && supportsColor$$1.level >= 2) {
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
          69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
          135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
          172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
          205, 206, 207, 208, 209, 214, 215, 220, 221
        ];
      }
    } catch (err) {
      // swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // camel-case
      var prop = key
        .substring(6)
        .toLowerCase()
        .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

      // coerce string value into JS value
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === 'null') val = null;
      else val = Number(val);

      obj[prop] = val;
      return obj;
    }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty.isatty(process.stderr.fd);
    }

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts)
        .split('\n').map(function(str) {
          return str.trim()
        }).join(' ');
    };

    /**
     * Map %o to `util.inspect()`, allowing multiple lines if needed.
     */

    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace;
      var useColors = this.useColors;

      if (useColors) {
        var c = this.color;
        var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
        var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }

    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      } else {
        return new Date().toISOString() + ' ';
      }
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init (debug$$1) {
      debug$$1.inspectOpts = {};

      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug$$1.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */

    exports.enable(load());
    });
    var node_1 = node.init;
    var node_2 = node.log;
    var node_3 = node.formatArgs;
    var node_4 = node.save;
    var node_5 = node.load;
    var node_6 = node.useColors;
    var node_7 = node.colors;
    var node_8 = node.inspectOpts;

    var src = createCommonjsModule(function (module) {
    /**
     * Detect Electron renderer process, which is node, but we should
     * treat as a browser.
     */

    if (typeof process === 'undefined' || process.type === 'renderer') {
      module.exports = browser;
    } else {
      module.exports = node;
    }
    });

    var semver = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;

    // The debug function is excluded entirely from the minified version.
    /* nomin */ var debug;
    /* nomin */ if (typeof process === 'object' &&
        /* nomin */ process.env &&
        /* nomin */ process.env.NODE_DEBUG &&
        /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
      /* nomin */ debug = function() {
        /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
        /* nomin */ args.unshift('SEMVER');
        /* nomin */ console.log.apply(console, args);
        /* nomin */ };
    /* nomin */ else
      /* nomin */ debug = function() {};

    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    exports.SEMVER_SPEC_VERSION = '2.0.0';

    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

    // Max safe segment length for coercion.
    var MAX_SAFE_COMPONENT_LENGTH = 16;

    // The actual regexps go on exports.re
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


    // ## Main Version
    // Three dot-separated numeric identifiers.

    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')';

    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.

    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                                '|' + src[NONNUMERICIDENTIFIER] + ')';

    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                     '|' + src[NONNUMERICIDENTIFIER] + ')';


    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                      '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                           '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
                 '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] +
                    src[PRERELEASE] + '?' +
                    src[BUILD] + '?';

    src[FULL] = '^' + FULLPLAIN + '$';

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                     src[PRERELEASELOOSE] + '?' +
                     src[BUILD] + '?';

    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';

    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:' + src[PRERELEASE] + ')?' +
                       src[BUILD] + '?' +
                       ')?)?';

    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:' + src[PRERELEASELOOSE] + ')?' +
                            src[BUILD] + '?' +
                            ')?)?';

    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    var COERCE = R++;
    src[COERCE] = '(?:^|[^\\d])' +
                  '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
                  '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                  '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
                  '(?:$|[^\\d])';

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';

    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';

    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';

    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';

    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                          '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

    // this one has to use the /g flag
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';


    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                       '\\s+-\\s+' +
                       '(' + src[XRANGEPLAIN] + ')' +
                       '\\s*$';

    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s+-\\s+' +
                            '(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s*$';

    // Star ranges basically just allow anything at all.
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';

    // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }

    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;

      if (typeof version !== 'string')
        return null;

      if (version.length > MAX_LENGTH)
        return null;

      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;

      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }


    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH)
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

      if (!(this instanceof SemVer))
        return new SemVer(version, loose);

      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

      if (!m)
        throw new TypeError('Invalid Version: ' + version);

      this.raw = version;

      // these are actually numbers
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError('Invalid major version')

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError('Invalid minor version')

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError('Invalid patch version')

      // numberify any prerelease numeric ids
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split('.').map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num;
          }
          return id;
        });

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function() {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length)
        this.version += '-' + this.prerelease.join('.');
      return this.version;
    };

    SemVer.prototype.toString = function() {
      return this.version;
    };

    SemVer.prototype.compare = function(other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);

      return compareIdentifiers(this.major, other.major) ||
             compareIdentifiers(this.minor, other.minor) ||
             compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);

      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;

      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined)
          return 0;
        else if (b === undefined)
          return 1;
        else if (a === undefined)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i);
    };

    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0)
            this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) // didn't increment anything
              this.prerelease.push(0);
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof(loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre'+key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }

    exports.compareIdentifiers = compareIdentifiers;

    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return (anum && !bnum) ? -1 :
             (bnum && !anum) ? 1 :
             a < b ? -1 :
             a > b ? 1 :
             0;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }

    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }

    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a !== b;
          break;
        case '': case '=': case '==': ret = eq(a, b, loose); break;
        case '!=': ret = neq(a, b, loose); break;
        case '>': ret = gt(a, b, loose); break;
        case '>=': ret = gte(a, b, loose); break;
        case '<': ret = lt(a, b, loose); break;
        case '<=': ret = lte(a, b, loose); break;
        default: throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }

    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }

      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);

      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);

      if (this.semver === ANY)
        this.value = '';
      else
        this.value = this.operator + this.semver.version;

      debug('comp', this);
    }

    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);

      if (!m)
        throw new TypeError('Invalid comparator: ' + comp);

      this.operator = m[1];
      if (this.operator === '=')
        this.operator = '';

      // if it literally is just '>' or '' then allow anything.
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };

    Comparator.prototype.toString = function() {
      return this.value;
    };

    Comparator.prototype.test = function(version) {
      debug('Comparator.test', version, this.loose);

      if (this.semver === ANY)
        return true;

      if (typeof version === 'string')
        version = new SemVer(version, this.loose);

      return cmp(version, this.operator, this.semver, this.loose);
    };

    Comparator.prototype.intersects = function(comp, loose) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      var rangeTmp;

      if (this.operator === '') {
        rangeTmp = new Range(comp.value, loose);
        return satisfies(this.value, rangeTmp, loose);
      } else if (comp.operator === '') {
        rangeTmp = new Range(this.value, loose);
        return satisfies(comp.semver, rangeTmp, loose);
      }

      var sameDirectionIncreasing =
        (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing =
        (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive =
        (this.operator === '>=' || this.operator === '<=') &&
        (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan =
        cmp(this.semver, '<', comp.semver, loose) &&
        ((this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<'));
      var oppositeDirectionsGreaterThan =
        cmp(this.semver, '>', comp.semver, loose) &&
        ((this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>'));

      return sameDirectionIncreasing || sameDirectionDecreasing ||
        (sameSemVer && differentDirectionsInclusive) ||
        oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };


    exports.Range = Range;
    function Range(range, loose) {
      if (range instanceof Range) {
        if (range.loose === loose) {
          return range;
        } else {
          return new Range(range.raw, loose);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, loose);
      }

      if (!(this instanceof Range))
        return new Range(range, loose);

      this.loose = loose;

      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range) {
        return this.parseRange(range.trim());
      }, this).filter(function(c) {
        // throw out any that are not relevant for whatever reason
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function() {
      return this.range;
    };

    Range.prototype.parseRange = function(range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);

      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[TILDETRIM], tildeTrimReplace);

      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[CARETTRIM], caretTrimReplace);

      // normalize spaces
      range = range.split(/\s+/).join(' ');

      // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function(comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });

      return set;
    };

    Range.prototype.intersects = function(range, loose) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, loose);
            });
          });
        });
      });
    };

    // Mostly just for testing and legacy API reasons
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }

    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p))
          // ~1.2 == >=1.2.0 <1.3.0
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        } else
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';

        debug('tilde return', ret);
        return ret;
      });
    }

    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }

    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p)) {
          if (M === '0')
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          else
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + pr +
                  ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + (+M + 1) + '.0.0';
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function(comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }

    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX)
          gtlt = '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // replace X with 0
          if (xm)
            m = 0;
          if (xp)
            p = 0;

          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<';
            if (xm)
              M = +M + 1;
            else
              m = +m + 1;
          }

          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }

        debug('xRange return', ret);

        return ret;
      });
    }

    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re[STAR], '');
    }

    // This function is passed to string.replace(re[HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0
    function hyphenReplace($0,
                           from, fM, fm, fp, fpr, fb,
                           to, tM, tm, tp, tpr, tb) {

      if (isX(fM))
        from = '';
      else if (isX(fm))
        from = '>=' + fM + '.0.0';
      else if (isX(fp))
        from = '>=' + fM + '.' + fm + '.0';
      else
        from = '>=' + from;

      if (isX(tM))
        to = '';
      else if (isX(tm))
        to = '<' + (+tM + 1) + '.0.0';
      else if (isX(tp))
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      else if (tpr)
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      else
        to = '<=' + to;

      return (from + ' ' + to).trim();
    }


    // if ANY of the sets match ALL of its comparators, then pass
    Range.prototype.test = function(version) {
      if (!version)
        return false;

      if (typeof version === 'string')
        version = new SemVer(version, this.loose);

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version))
          return true;
      }
      return false;
    };

    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version))
          return false;
      }

      if (version.prerelease.length) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY)
            continue;

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch)
              return true;
          }
        }

        // Version has a -pre, but it's not one of the ones we like.
        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, loose);
      } catch (er) {
        return null;
      }
      versions.forEach(function (v) {
        if (rangeObj.test(v)) { // satisfies(v, range, loose)
          if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
            max = v;
            maxSV = new SemVer(max, loose);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, loose) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, loose);
      } catch (er) {
        return null;
      }
      versions.forEach(function (v) {
        if (rangeObj.test(v)) { // satisfies(v, range, loose)
          if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
            min = v;
            minSV = new SemVer(min, loose);
          }
        }
      });
      return min;
    }

    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }

    // Determine if version is less than all the versions possible in the range
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }

    // Determine if version is greater than all the versions possible in the range.
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }

    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);

      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      // If it satisifes the range it is not outside
      if (satisfies(version, range, loose)) {
        return false;
      }

      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];

        var high = null;
        var low = null;

        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });

        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }

    exports.prerelease = prerelease;
    function prerelease(version, loose) {
      var parsed = parse(version, loose);
      return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
    }

    exports.intersects = intersects;
    function intersects(r1, r2, loose) {
      r1 = new Range(r1, loose);
      r2 = new Range(r2, loose);
      return r1.intersects(r2)
    }

    exports.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer)
        return version;

      if (typeof version !== 'string')
        return null;

      var match = version.match(re[COERCE]);

      if (match == null)
        return null;

      return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
    }
    });
    var semver_1 = semver.SEMVER_SPEC_VERSION;
    var semver_2 = semver.re;
    var semver_3 = semver.src;
    var semver_4 = semver.parse;
    var semver_5 = semver.valid;
    var semver_6 = semver.clean;
    var semver_7 = semver.SemVer;
    var semver_8 = semver.inc;
    var semver_9 = semver.diff;
    var semver_10 = semver.compareIdentifiers;
    var semver_11 = semver.rcompareIdentifiers;
    var semver_12 = semver.major;
    var semver_13 = semver.minor;
    var semver_14 = semver.patch;
    var semver_15 = semver.compare;
    var semver_16 = semver.compareLoose;
    var semver_17 = semver.rcompare;
    var semver_18 = semver.sort;
    var semver_19 = semver.rsort;
    var semver_20 = semver.gt;
    var semver_21 = semver.lt;
    var semver_22 = semver.eq;
    var semver_23 = semver.neq;
    var semver_24 = semver.gte;
    var semver_25 = semver.lte;
    var semver_26 = semver.cmp;
    var semver_27 = semver.Comparator;
    var semver_28 = semver.Range;
    var semver_29 = semver.toComparators;
    var semver_30 = semver.satisfies;
    var semver_31 = semver.maxSatisfying;
    var semver_32 = semver.minSatisfying;
    var semver_33 = semver.validRange;
    var semver_34 = semver.ltr;
    var semver_35 = semver.gtr;
    var semver_36 = semver.outside;
    var semver_37 = semver.prerelease;
    var semver_38 = semver.intersects;
    var semver_39 = semver.coerce;

    var debug$1 = src('nock.common');


    /**
     * Normalizes the request options so that it always has `host` property.
     *
     * @param  {Object} options - a parsed options object of the request
     */
    var normalizeRequestOptions = function(options) {
      options.proto = options.proto || (options._https_ ? 'https': 'http');
      options.port = options.port || ((options.proto === 'http') ? 80 : 443);
      if (options.host) {
        debug$1('options.host:', options.host);
        if (! options.hostname) {
          if (options.host.split(':').length == 2) {
            options.hostname = options.host.split(':')[0];
          } else {
            options.hostname = options.host;
          }
        }
      }
      debug$1('options.hostname in the end: %j', options.hostname);
      options.host = (options.hostname || 'localhost') + ':' + options.port;
      debug$1('options.host in the end: %j', options.host);

      /// lowercase host names
      ['hostname', 'host'].forEach(function(attr) {
        if (options[attr]) {
          options[attr] = options[attr].toLowerCase();
        }
      });

      return options;
    };

    /**
     * Returns true if the data contained in buffer is binary which in this case means
     * that it cannot be reconstructed from its utf8 representation.
     *
     * @param  {Object} buffer - a Buffer object
     */
    var isBinaryBuffer = function(buffer) {

      if(!Buffer.isBuffer(buffer)) {
        return false;
      }

      //  Test if the buffer can be reconstructed verbatim from its utf8 encoding.
      var utfEncodedBuffer = buffer.toString('utf8');
      var reconstructedBuffer = new Buffer(utfEncodedBuffer, 'utf8');
      var compareBuffers = function(lhs, rhs) {
        if(lhs.length !== rhs.length) {
          return false;
        }

        for(var i = 0; i < lhs.length; ++i) {
          if(lhs[i] !== rhs[i]) {
            return false;
          }
        }

        return true;
      };

      //  If the buffers are *not* equal then this is a "binary buffer"
      //  meaning that it cannot be faitfully represented in utf8.
      return !compareBuffers(buffer, reconstructedBuffer);

    };

    /**
     * If the chunks are Buffer objects then it returns a single Buffer object with the data from all the chunks.
     * If the chunks are strings then it returns a single string value with data from all the chunks.
     *
     * @param  {Array} chunks - an array of Buffer objects or strings
     */
    var mergeChunks = function(chunks) {

      if(lodash.isEmpty(chunks)) {
        return new Buffer(0);
      }

      //  We assume that all chunks are Buffer objects if the first is buffer object.
      var areBuffers = Buffer.isBuffer(lodash.first(chunks));

      if(!areBuffers) {
        //  When the chunks are not buffers we assume that they are strings.
        return chunks.join('');
      }

      //  Merge all the buffers into a single Buffer object.
      return Buffer.concat(chunks);

    };

    //  Array where all information about all the overridden requests are held.
    var requestOverride = [];

    /**
     * Overrides the current `request` function of `http` and `https` modules with
     * our own version which intercepts issues HTTP/HTTPS requests and forwards them
     * to the given `newRequest` function.
     *
     * @param  {Function} newRequest - a function handling requests; it accepts four arguments:
     *   - proto - a string with the overridden module's protocol name (either `http` or `https`)
     *   - overriddenRequest - the overridden module's request function already bound to module's object
     *   - options - the options of the issued request
     *   - callback - the callback of the issued request
     */
    var overrideRequests = function(newRequest) {
      debug$1('overriding requests');

      ['http', 'https'].forEach(function(proto) {
        debug$1('- overriding request for', proto);

        var moduleName = proto, // 1 to 1 match of protocol and module is fortunate :)
            module = {
              http: http,
              https: https
            }[moduleName],
            overriddenRequest = module.request,
            overriddenGet = module.get;

        if(requestOverride[moduleName]) {
          throw new Error('Module\'s request already overridden for ' + moduleName + ' protocol.');
        }

        //  Store the properties of the overridden request so that it can be restored later on.
        requestOverride[moduleName] = {
          module: module,
          request: overriddenRequest,
          get: overriddenGet
        };

        module.request = function(options, callback) {
          // debug('request options:', options);
          return newRequest(proto, overriddenRequest.bind(module), options, callback);
        };

        if (semver.satisfies(process.version, '>=8')) {
          module.get = function(options, callback) {
            var req = newRequest(proto, overriddenRequest.bind(module), options, callback);
            req.end();
            return req;
          };
        }

        debug$1('- overridden request for', proto);
      });
    };

    /**
     * Restores `request` function of `http` and `https` modules to values they
     * held before they were overridden by us.
     */
    var restoreOverriddenRequests = function() {
      debug$1('restoring requests');

      //  Restore any overridden requests.
      lodash(requestOverride).keys().each(function(proto) {
        debug$1('- restoring request for', proto);

        var override = requestOverride[proto];
        if(override) {
          override.module.request = override.request;
          override.module.get = override.get;
          debug$1('- restored request for', proto);
        }
      });
      requestOverride = [];
    };

    /**
     * Get high level information about request as string
     * @param  {Object} options
     * @param  {string} options.method
     * @param  {string} options.port
     * @param  {string} options.proto
     * @param  {string} options.hostname
     * @param  {string} options.path
     * @param  {Object} options.headers
     * @param  {string|object} body
     * @return {string}
     */
    function stringifyRequest(options, body) {
      var method = options.method || 'GET';

      var port = options.port;
      if (! port) port = (options.proto == 'https' ? '443' : '80');

      if (options.proto == 'https' && port == '443' ||
          options.proto == 'http' && port == '80') {
        port = '';
      }

      if (port) port = ':' + port;

      var path$$1 = options.path ? options.path : '';

      var log = {
        method: method,
        url: options.proto + '://' + options.hostname + port + path$$1,
        headers: options.headers
      };

      if (body) {
        log.body = body;
      }

      return JSON.stringify(log, null, 2);
    }

    function isContentEncoded(headers) {
      var contentEncoding = lodash.get(headers, 'content-encoding');
      return lodash.isString(contentEncoding) && contentEncoding !== '';
    }

    function contentEncoding(headers, encoder) {
      var contentEncoding = lodash.get(headers, 'content-encoding');
      return contentEncoding === encoder;
    }

    function isJSONContent(headers) {
      var contentType = lodash.get(headers, 'content-type');
      if (Array.isArray(contentType)) {
        contentType = contentType[0];
      }
      contentType = (contentType || '').toLocaleLowerCase();

      return contentType === 'application/json';
    }

    var headersFieldNamesToLowerCase = function(headers) {
      if(!lodash.isObject(headers)) {
        return headers;
      }

      //  For each key in the headers, delete its value and reinsert it with lower-case key.
      //  Keys represent headers field names.
      var lowerCaseHeaders = {};
      lodash.forOwn(headers, function(fieldVal, fieldName) {
        var lowerCaseFieldName = fieldName.toLowerCase();
        if(!lodash.isUndefined(lowerCaseHeaders[lowerCaseFieldName])) {
          throw new Error('Failed to convert header keys to lower case due to field name conflict: ' + lowerCaseFieldName);
        }
        lowerCaseHeaders[lowerCaseFieldName] = fieldVal;
      });

      return lowerCaseHeaders;
    };

    var headersFieldsArrayToLowerCase = function (headers) {
      return lodash.uniq(lodash.map(headers, function (fieldName) {
        return fieldName.toLowerCase();
      }));
    };

    var headersArrayToObject = function (rawHeaders) {
      if(!lodash.isArray(rawHeaders)) {
        return rawHeaders;
      }

      var headers = {};

      for (var i=0, len=rawHeaders.length; i<len; i=i+2) {
        var key = rawHeaders[i].toLowerCase();
        var value = rawHeaders[i+1];

        if (headers[key]) {
          headers[key] = lodash.isArray(headers[key]) ? headers[key] : [headers[key]];
          headers[key].push(value);
        } else {
          headers[key] = value;
        }
      }

      return headers;
    };

    /**
     * Deletes the given `fieldName` property from `headers` object by performing
     * case-insensitive search through keys.
     *
     * @headers   {Object} headers - object of header field names and values
     * @fieldName {String} field name - string with the case-insensitive field name
     */
    var deleteHeadersField = function(headers, fieldNameToDelete) {

      if(!lodash.isObject(headers) || !lodash.isString(fieldNameToDelete)) {
        return;
      }

      var lowerCaseFieldNameToDelete = fieldNameToDelete.toLowerCase();

      //  Search through the headers and delete all values whose field name matches the given field name.
      lodash(headers).keys().each(function(fieldName) {
        var lowerCaseFieldName = fieldName.toLowerCase();
        if(lowerCaseFieldName === lowerCaseFieldNameToDelete) {
          delete headers[fieldName];
          //  We don't stop here but continue in order to remove *all* matching field names
          //  (even though if seen regorously there shouldn't be any)
        }
      });

    };

    function percentDecode (str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
      } catch (e) {
        return str;
      }
    }

    function percentEncode(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return '%' + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }

    function matchStringOrRegexp(target, pattern) {
      var str = (!lodash.isUndefined(target) && target.toString && target.toString()) || '';

      return pattern instanceof RegExp  ? str.match(pattern) : str === String(pattern);
    }

    /**
     * Formats a query parameter.
     *
     * @param key                The key of the query parameter to format.
     * @param value              The value of the query parameter to format.
     * @param stringFormattingFn The function used to format string values. Can
     *                           be used to encode or decode the query value.
     *
     * @returns the formatted [key, value] pair.
     */
    function formatQueryValue(key, value, stringFormattingFn) {
      switch (true) {
        case lodash.isNumber(value): // fall-through
        case lodash.isBoolean(value):
          value = value.toString();
          break;
        case lodash.isUndefined(value): // fall-through
        case lodash.isNull(value):
          value = '';
          break;
        case lodash.isString(value):
          if(stringFormattingFn) {
            value = stringFormattingFn(value);
          }
          break;
        case (value instanceof RegExp):
          break;
        case lodash.isArray(value):
          var tmpArray = new Array(value.length);
          for (var i = 0; i < value.length; ++i) {
            tmpArray[i] = formatQueryValue(i, value[i], stringFormattingFn)[1];
          }
          value = tmpArray;
          break;
        case lodash.isObject(value):
          var tmpObj = {};
          lodash.forOwn(value, function(subVal, subKey){
            var subPair = formatQueryValue(subKey, subVal, stringFormattingFn);
            tmpObj[subPair[0]] = subPair[1];
          });
          value = tmpObj;
          break;
      }

      if (stringFormattingFn) key = stringFormattingFn(key);
      return [key, value];
    }

    function isStream(obj) {
      return obj &&
          (typeof a !== 'string') &&
          (! Buffer.isBuffer(obj)) &&
          lodash.isFunction(obj.setEncoding);
    }

    var normalizeRequestOptions_1 = normalizeRequestOptions;
    var isBinaryBuffer_1 = isBinaryBuffer;
    var mergeChunks_1 = mergeChunks;
    var overrideRequests_1 = overrideRequests;
    var restoreOverriddenRequests_1 = restoreOverriddenRequests;
    var stringifyRequest_1 = stringifyRequest;
    var isContentEncoded_1 = isContentEncoded;
    var contentEncoding_1 = contentEncoding;
    var isJSONContent_1 = isJSONContent;
    var headersFieldNamesToLowerCase_1 = headersFieldNamesToLowerCase;
    var headersFieldsArrayToLowerCase_1 = headersFieldsArrayToLowerCase;
    var headersArrayToObject_1 = headersArrayToObject;
    var deleteHeadersField_1 = deleteHeadersField;
    var percentEncode_1 = percentEncode;
    var percentDecode_1 = percentDecode;
    var matchStringOrRegexp_1 = matchStringOrRegexp;
    var formatQueryValue_1 = formatQueryValue;
    var isStream_1$1 = isStream;

    var common = {
    	normalizeRequestOptions: normalizeRequestOptions_1,
    	isBinaryBuffer: isBinaryBuffer_1,
    	mergeChunks: mergeChunks_1,
    	overrideRequests: overrideRequests_1,
    	restoreOverriddenRequests: restoreOverriddenRequests_1,
    	stringifyRequest: stringifyRequest_1,
    	isContentEncoded: isContentEncoded_1,
    	contentEncoding: contentEncoding_1,
    	isJSONContent: isJSONContent_1,
    	headersFieldNamesToLowerCase: headersFieldNamesToLowerCase_1,
    	headersFieldsArrayToLowerCase: headersFieldsArrayToLowerCase_1,
    	headersArrayToObject: headersArrayToObject_1,
    	deleteHeadersField: deleteHeadersField_1,
    	percentEncode: percentEncode_1,
    	percentDecode: percentDecode_1,
    	matchStringOrRegexp: matchStringOrRegexp_1,
    	formatQueryValue: formatQueryValue_1,
    	isStream: isStream_1$1
    };

    function propagate(events$$1, source, dest) {
      if (arguments.length < 3) {
        dest = source;
        source = events$$1;
        events$$1 = undefined;
      }

      // events should be an array or object
      var eventsIsObject = typeof events$$1 === 'object';
      if (events$$1 && !eventsIsObject) events$$1 = [events$$1];

      if (eventsIsObject) {
        return explicitPropagate(events$$1, source, dest);
      }

      var oldEmit =  source.emit;

      source.emit = function(eventType) {
        oldEmit.apply(source, arguments);

        if (! events$$1 || ~events$$1.indexOf(eventType)) {
          dest.emit.apply(dest, arguments);
        }
      };

      function end() {
        source.emit = oldEmit;
      }

      return {
        end: end
      };
    }
    var propagate_1 = propagate;

    function explicitPropagate(events$$1, source, dest) {
      var eventsIn;
      var eventsOut;
      if (Array.isArray(events$$1)) {
        eventsIn = events$$1;
        eventsOut = events$$1;
      } else {
        eventsIn = Object.keys(events$$1);
        eventsOut = eventsIn.map(function (key) {
          return events$$1[key]
        });
      }

      var listeners = eventsOut.map(function(event) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          args.unshift(event);
          dest.emit.apply(dest, args);
        }
      });

      listeners.forEach(register);

      return {
        end: end
      };

      function register(listener, i) {
        source.on(eventsIn[i], listener);
      }

      function unregister(listener, i) {
        source.removeListener(eventsIn[i], listener);
      }

      function end() {
        listeners.forEach(unregister);
      }
    }

    /**
     * Creates a stream which becomes the response body of the interceptor when a
     * delay is set. The stream outputs the intended body and EOF after the delay.
     *
     * @param  {String|Buffer|Stream} body - the body to write/pipe out
     * @param  {Integer} ms - The delay in milliseconds
     * @constructor
     */
    var delayed_body = DelayedBody;

    var Transform = stream.Transform;
    var EventEmitter = events.EventEmitter;
    var noop = function () {};



    if (!Transform) {
      // for barebones compatibility for node < 0.10
      var FakeTransformStream = function () {
        EventEmitter.call(this);
      };
      util.inherits(FakeTransformStream, EventEmitter);
      FakeTransformStream.prototype.pause = noop;
      FakeTransformStream.prototype.resume = noop;
      FakeTransformStream.prototype.setEncoding = noop;
      FakeTransformStream.prototype.write = function (chunk, encoding$$1) {
        var self = this;
        process.nextTick(function () {
          self.emit('data', chunk, encoding$$1);
        });
      };
      FakeTransformStream.prototype.end = function (chunk) {
        var self = this;
        if (chunk) {
          self.write(chunk);
        }
        process.nextTick(function () {
          self.emit('end');
        });
      };

      Transform = FakeTransformStream;
    }

    function DelayedBody(ms, body) {
      Transform.call(this);

      var self = this;
      var data = '';
      var ended = false;

      if (common.isStream(body)) {
        body.on('data', function (chunk) {
          data += Buffer.isBuffer(chunk) ? chunk.toString() : chunk;
        });

        body.once('end', function () {
          ended = true;
        });

        body.resume();
      }

      setTimeout(function () {
        if (common.isStream(body) && !ended) {
          body.once('end', function () {
            self.end(data);
          });
        } else {
          self.end(data || body);
        }
      }, ms);
    }
    util.inherits(DelayedBody, Transform);

    DelayedBody.prototype._transform = function (chunk, encoding$$1, cb) {
      this.push(chunk);
      process.nextTick(cb);
    };

    var EventEmitter$1 = events.EventEmitter;
    var debug$2        = src('nock.socket');


    var socket = Socket;

    function Socket(options) {
      if (!(this instanceof Socket)) {
        return new Socket(options);
      }

      EventEmitter$1.apply(this);

      options = options || {};

      if (options.proto === 'https') {
        this.authorized = true;
      }

      this.writable = true;
      this.readable = true;
      this.destroyed = false;
      this.connecting = false;

      this.setNoDelay = noop$1;
      this.setKeepAlive = noop$1;
      this.resume = noop$1;

      // totalDelay that has already been applied to the current
      // request/connection, timeout error will be generated if
      // it is timed-out.
      this.totalDelayMs = 0;
      // Maximum allowed delay. Null means unlimited.
      this.timeoutMs = null;
    }
    util.inherits(Socket, EventEmitter$1);

    Socket.prototype.setTimeout = function setTimeout(timeoutMs, fn) {
      this.timeoutMs = timeoutMs;
      this.timeoutFunction = fn;
    };

    Socket.prototype.applyDelay = function applyDelay(delayMs) {
      this.totalDelayMs += delayMs;

      if (this.timeoutMs && this.totalDelayMs > this.timeoutMs) {
        debug$2('socket timeout');
        if (this.timeoutFunction) {
          this.timeoutFunction();
        }
        else {
          this.emit('timeout');
        }
      }

    };

    Socket.prototype.getPeerCertificate = function getPeerCertificate() {
      return new Buffer((Math.random() * 10000 + Date.now()).toString()).toString('base64');
    };

    Socket.prototype.destroy = function destroy() {
      this.destroyed = true;
      this.readable = this.writable = false;
    };

    function noop$1() {}

    var EventEmitter$2 = events.EventEmitter;

    var global_emitter = new EventEmitter$2();

    var EventEmitter$3     = events.EventEmitter,
        IncomingMessage  = http.IncomingMessage,
        ClientRequest    = http.ClientRequest,
        debug$3            = src('nock.request_overrider'),
        ReadableStream   = stream.Readable;

    function getHeader(request, name) {
      if (!request._headers) {
        return;
      }

      var key = name.toLowerCase();

      return request.getHeader ? request.getHeader(key) : request._headers[key];
    }

    function setHeader(request, name, value) {
      debug$3('setHeader', name, value);

      var key = name.toLowerCase();

      request._headers = request._headers || {};
      request._headerNames = request._headerNames || {};
      request._removedHeader = request._removedHeader || {};

      if (request.setHeader) {
        request.setHeader(key, value);
      } else {
        request._headers[key] = value;
        request._headerNames[key] = name;
      }

      if (name == 'expect' && value == '100-continue') {
        timers.setImmediate(function() {
          debug$3('continue');
          request.emit('continue');
        });
      }
    }

    //  Sets request headers of the given request. This is needed during both matching phase
    //  (in case header filters were specified) and mocking phase (to correctly pass mocked
    //  request headers).
    function setRequestHeaders(req, options, interceptor) {
      //  If a filtered scope is being used we have to use scope's host
      //  in the header, otherwise 'host' header won't match.
      //  NOTE: We use lower-case header field names throught Nock.
      var HOST_HEADER = 'host';
      if(interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {
        if(options && options.headers) {
          options.headers[HOST_HEADER] = interceptor.__nock_scopeHost;
        }
        setHeader(req, HOST_HEADER, interceptor.__nock_scopeHost);
      } else {
        //  For all other cases, we always add host header equal to the
        //  requested host unless it was already defined.
        if (options.host && !getHeader(req, HOST_HEADER)) {
          var hostHeader = options.host;

          if (options.port === 80 || options.port === 443) {
            hostHeader = hostHeader.split(':')[0];
          }

          setHeader(req, HOST_HEADER, hostHeader);
        }
      }

    }

    function RequestOverrider(req, options, interceptors, remove, cb) {
      var response;
      if (IncomingMessage) {
        response = new IncomingMessage(new EventEmitter$3());
      } else {
        response = new ReadableStream();
        response._read = function() {};
      }

      var requestBodyBuffers = [],
          emitError,
          end,
          ended,
          headers;

      //  We may be changing the options object and we don't want those
      //  changes affecting the user so we use a clone of the object.
      options = lodash.clone(options) || {};

      response.req = req;

      if (options.headers) {
        //  We use lower-case header field names throught Nock.
        options.headers = common.headersFieldNamesToLowerCase(options.headers);

        headers = options.headers;
        lodash.forOwn(headers, function(val, key) {
          setHeader(req, key, val);
        });
      }

      /// options.auth
      if (options.auth && (! options.headers || ! options.headers.authorization)) {
        setHeader(req, 'Authorization', 'Basic ' + (new Buffer(options.auth)).toString('base64'));
      }

      if (! req.connection) {
        req.connection = new EventEmitter$3();
      }

      req.path = options.path;

      options.getHeader = function(name) {
        return getHeader(req, name);
      };

      req.socket = response.socket = socket({ proto: options.proto });

      req.write = function(buffer, encoding$$1, callback) {
        debug$3('write', arguments);
        if (!req.aborted) {
          if (buffer) {
            if (!Buffer.isBuffer(buffer)) {
              buffer = new Buffer(buffer, encoding$$1);
            }
            requestBodyBuffers.push(buffer);
          }
          if (typeof callback === 'function') {
            callback();
          }
        }
        else {
          emitError(new Error('Request aborted'));
        }

        timers.setImmediate(function() {
          req.emit('drain');
        });

        return false;
      };

      req.end = function(buffer, encoding$$1, callback) {
        debug$3('req.end');
        if (!req.aborted && !ended) {
          req.write(buffer, encoding$$1, function () {
            if (typeof callback === 'function') {
              callback();
            }
            end(cb);
            req.emit('finish');
            req.emit('end');
          });
        }
        if (req.aborted) {
          emitError(new Error('Request aborted'));
        }
      };

      req.flushHeaders = function() {
        debug$3('req.flushHeaders');
        if (!req.aborted && !ended) {
          end(cb);
        }
        if (req.aborted) {
          emitError(new Error('Request aborted'));
        }
      };

      req.abort = function() {
        if (req.aborted) {
          return;
        }
        debug$3('req.abort');
        req.aborted = Date.now();
        if (!ended) {
          end();
        }
        var err = new Error();
        err.code = 'aborted';
        response.emit('close', err);

        req.socket.destroy();

        req.emit('abort');

        var connResetError = new Error('socket hang up');
        connResetError.code = 'ECONNRESET';
        emitError(connResetError);
      };

      // restify listens for a 'socket' event to
      // be emitted before calling end(), which causes
      // nock to hang with restify. The following logic
      // fakes the socket behavior for restify,
      // Fixes: https://github.com/pgte/nock/issues/79
      req.once = req.on = function(event, listener) {
        // emit a fake socket.
        if (event == 'socket') {
          listener.call(req, req.socket);
          req.socket.emit('connect', req.socket);
          req.socket.emit('secureConnect', req.socket);
        }

        EventEmitter$3.prototype.on.call(this, event, listener);
        return this;
      };

      emitError = function(error) {
        process.nextTick(function () {
          req.emit('error', error);
        });
      };

      end = function(cb) {
        debug$3('ending');
        ended = true;
        var requestBody,
            responseBody,
            responseBuffers,
            interceptor;

        var continued = false;

        //  When request body is a binary buffer we internally use in its hexadecimal representation.
        var requestBodyBuffer = common.mergeChunks(requestBodyBuffers);
        var isBinaryRequestBodyBuffer = common.isBinaryBuffer(requestBodyBuffer);
        if(isBinaryRequestBodyBuffer) {
          requestBody = requestBodyBuffer.toString('hex');
        } else {
          requestBody = requestBodyBuffer.toString('utf8');
        }

        /// put back the path into options
        /// because bad behaving agents like superagent
        /// like to change request.path in mid-flight.
        options.path = req.path;

        // fixes #976
        options.protocol = options.proto + ':';

        interceptors.forEach(function(interceptor) {
          //  For correct matching we need to have correct request headers - if these were specified.
          setRequestHeaders(req, options, interceptor);
        });

        interceptor = lodash.find(interceptors, function(interceptor) {
          return interceptor.match(options, requestBody);
        });

        if (!interceptor) {
          global_emitter.emit('no match', req, options, requestBody);
          // Try to find a hostname match
          interceptor = lodash.find(interceptors, function(interceptor) {
            return interceptor.match(options, requestBody, true);
          });
          if (interceptor && req instanceof ClientRequest) {
            if (interceptor.options.allowUnmocked) {
              var newReq = new ClientRequest(options, cb);
              propagate_1(newReq, req);
              //  We send the raw buffer as we received it, not as we interpreted it.
              newReq.end(requestBodyBuffer);
              return;
            }
          }

          var err = new Error("Nock: No match for request " + common.stringifyRequest(options, requestBody));
          err.statusCode = err.status = 404;
          emitError(err);
          return;
        }

        debug$3('interceptor identified, starting mocking');

        //  We again set request headers, now for our matched interceptor.
        setRequestHeaders(req, options, interceptor);
        interceptor.req = req;
        req.headers = req.getHeaders ? req.getHeaders() : req._headers;

        interceptor.scope.emit('request', req, interceptor, requestBody);

        if (typeof interceptor.errorMessage !== 'undefined') {
          interceptor.interceptionCounter++;
          remove(interceptor);
          interceptor.discard();

          var error;
          if (lodash.isObject(interceptor.errorMessage)) {
            error = interceptor.errorMessage;
          } else {
            error = new Error(interceptor.errorMessage);
          }
          timers.setTimeout(emitError, interceptor.getTotalDelay(), error);
          return;
        }
        response.statusCode = Number(interceptor.statusCode) || 200;

        // Clone headers/rawHeaders to not override them when evaluating later
        response.headers = lodash.extend({}, interceptor.headers);
        response.rawHeaders = (interceptor.rawHeaders || []).slice();
        debug$3('response.rawHeaders:', response.rawHeaders);


        if (typeof interceptor.body === 'function') {
          if (requestBody && common.isJSONContent(req.headers)) {
            if (requestBody && common.contentEncoding(req.headers, 'gzip')) {
              if (typeof zlib.gunzipSync !== 'function') {
                emitError(new Error('Gzip encoding is currently not supported in this version of Node.'));
                return;
              }
              requestBody = String(zlib.gunzipSync(new Buffer(requestBody, 'hex')), 'hex');
            } else if (requestBody && common.contentEncoding(req.headers, 'deflate')) {
              if (typeof zlib.deflateSync !== 'function') {
                emitError(new Error('Deflate encoding is currently not supported in this version of Node.'));
                return;
              }
              requestBody = String(zlib.inflateSync(new Buffer(requestBody, 'hex')), 'hex');
            }

            requestBody = JSON.parse(requestBody);
          }

          // In case we are waiting for a callback
          if (interceptor.body.length === 3) {
            return interceptor.body(options.path, requestBody || '', continueWithResponseBody);
          }

          responseBody = interceptor.body(options.path, requestBody) || '';

        } else {

          //  If the content is encoded we know that the response body *must* be an array
          //  of response buffers which should be mocked one by one.
          //  (otherwise decompressions after the first one fails as unzip expects to receive
          //  buffer by buffer and not one single merged buffer)
          if(common.isContentEncoded(response.headers) && ! common.isStream(interceptor.body)) {

            if (interceptor.delayInMs) {
              emitError(new Error('Response delay is currently not supported with content-encoded responses.'));
              return;
            }

            var buffers = interceptor.body;
            if(!lodash.isArray(buffers)) {
              buffers = [buffers];
            }

            responseBuffers = lodash.map(buffers, function(buffer) {
              return new Buffer(buffer, 'hex');
            });

          } else {

            responseBody = interceptor.body;

            //  If the request was binary then we assume that the response will be binary as well.
            //  In that case we send the response as a Buffer object as that's what the client will expect.
            if(isBinaryRequestBodyBuffer && typeof(responseBody) === 'string') {
              //  Try to create the buffer from the interceptor's body response as hex.
              try {
                responseBody = new Buffer(responseBody, 'hex');
              } catch(err) {
                debug$3('exception during Buffer construction from hex data:', responseBody, '-', err);
              }

              // Creating buffers does not necessarily throw errors, check for difference in size
              if (!responseBody || (interceptor.body.length > 0 && responseBody.length === 0)) {
                //  We fallback on constructing buffer from utf8 representation of the body.
                responseBody = new Buffer(interceptor.body, 'utf8');
              }
            }
          }
        }

        return continueWithResponseBody(null, responseBody);

        function continueWithResponseBody(err, responseBody) {

          if (continued) {
            return;
          }
          continued = true;

          if (err) {
            response.statusCode = 500;
            responseBody = err.stack;
          }

          //  Transform the response body if it exists (it may not exist
          //  if we have `responseBuffers` instead)

          if (responseBody) {
            debug$3('transform the response body');

            if (Array.isArray(responseBody) &&
                responseBody.length >= 2 &&
                responseBody.length <= 3 &&
                typeof responseBody[0] == 'number')
            {
              debug$3('response body is array: %j', responseBody);
              response.statusCode = Number(responseBody[0]);
              debug$3('new headers: %j', responseBody[2]);
              if (! response.headers) response.headers = {};
              lodash.assign(response.headers, responseBody[2] || {});
              debug$3('response.headers after: %j', response.headers);
              responseBody = responseBody[1];

              response.rawHeaders = response.rawHeaders || [];
              Object.keys(response.headers).forEach(function(key) {
                response.rawHeaders.push(key, response.headers[key]);
              });
            }

            if (interceptor.delayInMs) {
              debug$3('delaying the response for', interceptor.delayInMs, 'milliseconds');
              // Because setTimeout is called immediately in DelayedBody(), so we
              // need count in the delayConnectionInMs.
              responseBody = new delayed_body(interceptor.getTotalDelay(), responseBody);
            }

            if (common.isStream(responseBody)) {
              debug$3('response body is a stream');
              responseBody.pause();
              responseBody.on('data', function(d) {
                response.push(d);
              });
              responseBody.on('end', function() {
                response.push(null);
              });
              responseBody.on('error', function(err) {
                response.emit('error', err);
              });
            } else if (responseBody && !Buffer.isBuffer(responseBody)) {
              if (typeof responseBody === 'string') {
                responseBody = new Buffer(responseBody);
              } else {
                responseBody = JSON.stringify(responseBody);
                response.headers['content-type'] = 'application/json';
              }
            }
          }

          interceptor.interceptionCounter++;
          remove(interceptor);
          interceptor.discard();

          if (req.aborted) { return; }

          /// response.client.authorized = true
          /// fixes https://github.com/pgte/nock/issues/158
          response.client = lodash.extend(response.client || {}, {
            authorized: true
          });

          // Account for updates to Node.js response interface
          // cf https://github.com/request/request/pull/1615
          response.socket = lodash.extend(response.socket || {}, {
            authorized: true
          });

          // Evaluate functional headers.
          var evaluatedHeaders = {};
          Object.keys(response.headers).forEach(function (key) {
            var value = response.headers[key];

            if (typeof value === "function") {
              response.headers[key] = evaluatedHeaders[key] = value(req, response, responseBody);
            }
          });

          for(var rawHeaderIndex = 0 ; rawHeaderIndex < response.rawHeaders.length ; rawHeaderIndex += 2) {
            var key = response.rawHeaders[rawHeaderIndex];
            var value = response.rawHeaders[rawHeaderIndex + 1];
            if (typeof value === "function") {
              response.rawHeaders[rawHeaderIndex + 1] = evaluatedHeaders[key.toLowerCase()];
            }
          }


          process.nextTick(respond);

          function respond() {

            if (req.aborted) { return; }

            if (interceptor.socketDelayInMs && interceptor.socketDelayInMs > 0) {
              req.socket.applyDelay(interceptor.socketDelayInMs);
            }

            if (interceptor.delayConnectionInMs && interceptor.delayConnectionInMs > 0) {
              req.socket.applyDelay(interceptor.delayConnectionInMs);
              setTimeout(_respond, interceptor.delayConnectionInMs);
            } else {
              _respond();
            }

            function _respond() {
              if (req.aborted) { return; }

              debug$3('emitting response');

              if (typeof cb === 'function') {
                debug$3('callback with response');
                cb(response);
              }

              if (req.aborted) {
                emitError(new Error('Request aborted'));
              }
              else {
                req.emit('response', response);
              }

              if (common.isStream(responseBody)) {
                debug$3('resuming response stream');
                responseBody.resume();
              }
              else {
                responseBuffers = responseBuffers || [];
                if (typeof responseBody !== "undefined") {
                  debug$3('adding body to buffer list');
                  responseBuffers.push(responseBody);
                }

                // Stream the response chunks one at a time.
                timers.setImmediate(function emitChunk() {
                  var chunk = responseBuffers.shift();

                  if (chunk) {
                    debug$3('emitting response chunk');
                    response.push(chunk);
                    timers.setImmediate(emitChunk);
                  }
                  else {
                    debug$3('ending response stream');
                    response.push(null);
                    interceptor.scope.emit('replied', req, interceptor);
                  }
                });
              }
            }
          }
        }
      };

      return req;
    }

    var request_overrider = RequestOverrider;

    function mixin(a, b) {
    	if (! a) { a = {}; }
    	if (! b) {b = {}; }
    	a = lodash.cloneDeep(a);
    	for(var prop in b) {
    		a[prop] = b[prop];
    	}
    	return a;
    }

    var mixin_1 = mixin;

    var keys$1 = createCommonjsModule(function (module, exports) {
    exports = module.exports = typeof Object.keys === 'function'
      ? Object.keys : shim;

    exports.shim = shim;
    function shim (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    });
    var keys_1 = keys$1.shim;

    var is_arguments = createCommonjsModule(function (module, exports) {
    var supportsArgumentsClass = (function(){
      return Object.prototype.toString.call(arguments)
    })() == '[object Arguments]';

    exports = module.exports = supportsArgumentsClass ? supported : unsupported;

    exports.supported = supported;
    function supported(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    exports.unsupported = unsupported;
    function unsupported(object){
      return object &&
        typeof object == 'object' &&
        typeof object.length == 'number' &&
        Object.prototype.hasOwnProperty.call(object, 'callee') &&
        !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
        false;
    }});
    var is_arguments_1 = is_arguments.supported;
    var is_arguments_2 = is_arguments.unsupported;

    var deepEqual_1 = createCommonjsModule(function (module) {
    var pSlice = Array.prototype.slice;



    var deepEqual = module.exports = function (actual, expected, opts) {
      if (!opts) opts = {};
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;

      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
        return opts.strict ? actual === expected : actual == expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, opts);
      }
    };

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer (x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') return false;
      return true;
    }

    function objEquiv(a, b, opts) {
      var i, key;
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (is_arguments(a)) {
        if (!is_arguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b, opts);
      }
      if (isBuffer(a)) {
        if (!isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) return false;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      try {
        var ka = keys$1(a),
            kb = keys$1(b);
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) return false;
      }
      return typeof a === typeof b;
    }
    });

    var has = Object.prototype.hasOwnProperty;

    var hexTable = (function () {
        var array = [];
        for (var i = 0; i < 256; ++i) {
            array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
        }

        return array;
    }());

    var compactQueue = function compactQueue(queue) {
        var obj;

        while (queue.length) {
            var item = queue.pop();
            obj = item.obj[item.prop];

            if (Array.isArray(obj)) {
                var compacted = [];

                for (var j = 0; j < obj.length; ++j) {
                    if (typeof obj[j] !== 'undefined') {
                        compacted.push(obj[j]);
                    }
                }

                item.obj[item.prop] = compacted;
            }
        }

        return obj;
    };

    var arrayToObject = function arrayToObject(source, options) {
        var obj = options && options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== 'undefined') {
                obj[i] = source[i];
            }
        }

        return obj;
    };

    var merge = function merge(target, source, options) {
        if (!source) {
            return target;
        }

        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            } else if (typeof target === 'object') {
                if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                    target[source] = true;
                }
            } else {
                return [target, source];
            }

            return target;
        }

        if (typeof target !== 'object') {
            return [target].concat(source);
        }

        var mergeTarget = target;
        if (Array.isArray(target) && !Array.isArray(source)) {
            mergeTarget = arrayToObject(target, options);
        }

        if (Array.isArray(target) && Array.isArray(source)) {
            source.forEach(function (item, i) {
                if (has.call(target, i)) {
                    if (target[i] && typeof target[i] === 'object') {
                        target[i] = merge(target[i], item, options);
                    } else {
                        target.push(item);
                    }
                } else {
                    target[i] = item;
                }
            });
            return target;
        }

        return Object.keys(source).reduce(function (acc, key) {
            var value = source[key];

            if (has.call(acc, key)) {
                acc[key] = merge(acc[key], value, options);
            } else {
                acc[key] = value;
            }
            return acc;
        }, mergeTarget);
    };

    var assign$7 = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function (acc, key) {
            acc[key] = source[key];
            return acc;
        }, target);
    };

    var decode = function (str) {
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };

    var encode = function encode(str) {
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }

        var string = typeof str === 'string' ? str : String(str);

        var out = '';
        for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);

            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
            ) {
                out += string.charAt(i);
                continue;
            }

            if (c < 0x80) {
                out = out + hexTable[c];
                continue;
            }

            if (c < 0x800) {
                out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
            out += hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        return out;
    };

    var compact = function compact(value) {
        var queue = [{ obj: { o: value }, prop: 'o' }];
        var refs = [];

        for (var i = 0; i < queue.length; ++i) {
            var item = queue[i];
            var obj = item.obj[item.prop];

            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; ++j) {
                var key = keys[j];
                var val = obj[key];
                if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                    queue.push({ obj: obj, prop: key });
                    refs.push(val);
                }
            }
        }

        return compactQueue(queue);
    };

    var isRegExp = function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    var isBuffer = function isBuffer(obj) {
        if (obj === null || typeof obj === 'undefined') {
            return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };

    var utils$1 = {
        arrayToObject: arrayToObject,
        assign: assign$7,
        compact: compact,
        decode: decode,
        encode: encode,
        isBuffer: isBuffer,
        isRegExp: isRegExp,
        merge: merge
    };

    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;

    var formats = {
        'default': 'RFC3986',
        formatters: {
            RFC1738: function (value) {
                return replace.call(value, percentTwenties, '+');
            },
            RFC3986: function (value) {
                return value;
            }
        },
        RFC1738: 'RFC1738',
        RFC3986: 'RFC3986'
    };

    var arrayPrefixGenerators = {
        brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
            return prefix + '[]';
        },
        indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
            return prefix + '[' + key + ']';
        },
        repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
            return prefix;
        }
    };

    var toISO = Date.prototype.toISOString;

    var defaults$3 = {
        delimiter: '&',
        encode: true,
        encoder: utils$1.encode,
        encodeValuesOnly: false,
        serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
            return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
    };

    var stringify = function stringify( // eslint-disable-line func-name-matching
        object,
        prefix,
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly
    ) {
        var obj = object;
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
            obj = serializeDate(obj);
        } else if (obj === null) {
            if (strictNullHandling) {
                return encoder && !encodeValuesOnly ? encoder(prefix, defaults$3.encoder) : prefix;
            }

            obj = '';
        }

        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils$1.isBuffer(obj)) {
            if (encoder) {
                var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$3.encoder);
                return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$3.encoder))];
            }
            return [formatter(prefix) + '=' + formatter(String(obj))];
        }

        var values = [];

        if (typeof obj === 'undefined') {
            return values;
        }

        var objKeys;
        if (Array.isArray(filter)) {
            objKeys = filter;
        } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];

            if (skipNulls && obj[key] === null) {
                continue;
            }

            if (Array.isArray(obj)) {
                values = values.concat(stringify(
                    obj[key],
                    generateArrayPrefix(prefix, key),
                    generateArrayPrefix,
                    strictNullHandling,
                    skipNulls,
                    encoder,
                    filter,
                    sort,
                    allowDots,
                    serializeDate,
                    formatter,
                    encodeValuesOnly
                ));
            } else {
                values = values.concat(stringify(
                    obj[key],
                    prefix + (allowDots ? '.' + key : '[' + key + ']'),
                    generateArrayPrefix,
                    strictNullHandling,
                    skipNulls,
                    encoder,
                    filter,
                    sort,
                    allowDots,
                    serializeDate,
                    formatter,
                    encodeValuesOnly
                ));
            }
        }

        return values;
    };

    var stringify_1 = function (object, opts) {
        var obj = object;
        var options = opts ? utils$1.assign({}, opts) : {};

        if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
            throw new TypeError('Encoder has to be a function.');
        }

        var delimiter = typeof options.delimiter === 'undefined' ? defaults$3.delimiter : options.delimiter;
        var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults$3.strictNullHandling;
        var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults$3.skipNulls;
        var encode = typeof options.encode === 'boolean' ? options.encode : defaults$3.encode;
        var encoder = typeof options.encoder === 'function' ? options.encoder : defaults$3.encoder;
        var sort = typeof options.sort === 'function' ? options.sort : null;
        var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
        var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults$3.serializeDate;
        var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults$3.encodeValuesOnly;
        if (typeof options.format === 'undefined') {
            options.format = formats['default'];
        } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        var formatter = formats.formatters[options.format];
        var objKeys;
        var filter;

        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        } else if (Array.isArray(options.filter)) {
            filter = options.filter;
            objKeys = filter;
        }

        var keys = [];

        if (typeof obj !== 'object' || obj === null) {
            return '';
        }

        var arrayFormat;
        if (options.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = options.arrayFormat;
        } else if ('indices' in options) {
            arrayFormat = options.indices ? 'indices' : 'repeat';
        } else {
            arrayFormat = 'indices';
        }

        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

        if (!objKeys) {
            objKeys = Object.keys(obj);
        }

        if (sort) {
            objKeys.sort(sort);
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];

            if (skipNulls && obj[key] === null) {
                continue;
            }

            keys = keys.concat(stringify(
                obj[key],
                key,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encode ? encoder : null,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }

        var joined = keys.join(delimiter);
        var prefix = options.addQueryPrefix === true ? '?' : '';

        return joined.length > 0 ? prefix + joined : '';
    };

    var has$1 = Object.prototype.hasOwnProperty;

    var defaults$4 = {
        allowDots: false,
        allowPrototypes: false,
        arrayLimit: 20,
        decoder: utils$1.decode,
        delimiter: '&',
        depth: 5,
        parameterLimit: 1000,
        plainObjects: false,
        strictNullHandling: false
    };

    var parseValues = function parseQueryStringValues(str, options) {
        var obj = {};
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
        var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);

        for (var i = 0; i < parts.length; ++i) {
            var part = parts[i];

            var bracketEqualsPos = part.indexOf(']=');
            var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

            var key, val;
            if (pos === -1) {
                key = options.decoder(part, defaults$4.decoder);
                val = options.strictNullHandling ? null : '';
            } else {
                key = options.decoder(part.slice(0, pos), defaults$4.decoder);
                val = options.decoder(part.slice(pos + 1), defaults$4.decoder);
            }
            if (has$1.call(obj, key)) {
                obj[key] = [].concat(obj[key]).concat(val);
            } else {
                obj[key] = val;
            }
        }

        return obj;
    };

    var parseObject = function (chain, val, options) {
        var leaf = val;

        for (var i = chain.length - 1; i >= 0; --i) {
            var obj;
            var root = chain[i];

            if (root === '[]') {
                obj = [];
                obj = obj.concat(leaf);
            } else {
                obj = options.plainObjects ? Object.create(null) : {};
                var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                var index = parseInt(cleanRoot, 10);
                if (
                    !isNaN(index)
                    && root !== cleanRoot
                    && String(index) === cleanRoot
                    && index >= 0
                    && (options.parseArrays && index <= options.arrayLimit)
                ) {
                    obj = [];
                    obj[index] = leaf;
                } else {
                    obj[cleanRoot] = leaf;
                }
            }

            leaf = obj;
        }

        return leaf;
    };

    var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
        if (!givenKey) {
            return;
        }

        // Transform dot notation to bracket notation
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

        // The regex chunks

        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;

        // Get the parent

        var segment = brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;

        // Stash the parent if it exists

        var keys = [];
        if (parent) {
            // If we aren't using plain objects, optionally prefix keys
            // that would overwrite object prototype properties
            if (!options.plainObjects && has$1.call(Object.prototype, parent)) {
                if (!options.allowPrototypes) {
                    return;
                }
            }

            keys.push(parent);
        }

        // Loop through children appending to the array until we hit depth

        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has$1.call(Object.prototype, segment[1].slice(1, -1))) {
                if (!options.allowPrototypes) {
                    return;
                }
            }
            keys.push(segment[1]);
        }

        // If there's a remainder, just add whatever is left

        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }

        return parseObject(keys, val, options);
    };

    var parse$1 = function (str, opts) {
        var options = opts ? utils$1.assign({}, opts) : {};

        if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
            throw new TypeError('Decoder has to be a function.');
        }

        options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
        options.delimiter = typeof options.delimiter === 'string' || utils$1.isRegExp(options.delimiter) ? options.delimiter : defaults$4.delimiter;
        options.depth = typeof options.depth === 'number' ? options.depth : defaults$4.depth;
        options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults$4.arrayLimit;
        options.parseArrays = options.parseArrays !== false;
        options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults$4.decoder;
        options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults$4.allowDots;
        options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults$4.plainObjects;
        options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults$4.allowPrototypes;
        options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults$4.parameterLimit;
        options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults$4.strictNullHandling;

        if (str === '' || str === null || typeof str === 'undefined') {
            return options.plainObjects ? Object.create(null) : {};
        }

        var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};

        // Iterate over the keys and setup the new object

        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options);
            obj = utils$1.merge(obj, newObj, options);
        }

        return utils$1.compact(obj);
    };

    var lib = {
        formats: formats,
        parse: parse$1,
        stringify: stringify_1
    };

    var match_body =
    function matchBody(spec, body) {
      if (typeof spec === 'undefined') {
        return true;
      }
      var options = this || {};

      if (Buffer.isBuffer(body)) {
        body = body.toString();
      }

      if (Buffer.isBuffer(spec)) {
        if (common.isBinaryBuffer(spec)) {
          spec = spec.toString('hex');
        } else {
          spec = spec.toString('utf8');
        }
      }

      var contentType = (
        options.headers &&
        (options.headers['Content-Type'] || options.headers['content-type']) ||
        ''
      ).toString();

      var isMultipart = contentType.indexOf('multipart') >= 0;
      var isUrlencoded = contentType.indexOf('application/x-www-form-urlencoded') >= 0;

      // try to transform body to json
      var json;
      if (typeof spec === 'object' || typeof spec === 'function') {
        try { json = JSON.parse(body);} catch(err) {}
        if (json !== undefined) {
          body = json;
        } else if (isUrlencoded) {
          body = lib.parse(body, { allowDots: true });
        }
      }

      if (typeof spec === "function") {
        return spec.call(this, body);
      }

      //strip line endings from both so that we get a match no matter what OS we are running on
      //if Content-Type does not contains 'multipart'
      if (!isMultipart && typeof body === "string") {
        body = body.replace(/\r?\n|\r/g, '');
      }

      if (spec instanceof RegExp) {
        if (typeof body === "string") {
          return body.match(spec);
        } else {
          return lib.stringify(body).match(spec);
        }
      }

      if (!isMultipart && typeof spec === "string") {
        spec = spec.replace(/\r?\n|\r/g, '');
      }

      if (isUrlencoded) {
        spec = mapValuesDeep(spec, function(val) {
          if (lodash.isRegExp(val)) {
            return val
          }
          return val + ''
        });
      }

      return deepEqualExtended(spec, body);
    };


    /**
     * Based on lodash issue discussion
     * https://github.com/lodash/lodash/issues/1244
     */
    function mapValuesDeep(obj, cb) {
      if (lodash.isArray(obj)) {
        return obj.map(function(v) {
          return mapValuesDeep(v, cb)
        })
      }
      if (lodash.isPlainObject(obj)) {
        return lodash.mapValues(obj, function(v) {
          return mapValuesDeep(v, cb)
        })
      }
      return cb(obj)
    }

    function deepEqualExtended(spec, body) {
      if (spec && spec.constructor === RegExp) {
        return spec.test(body);
      }
      if (spec && (spec.constructor === Object || spec.constructor === Array) && body) {
        var keys = Object.keys(spec);
        var bodyKeys = Object.keys(body);
        if (keys.length !== bodyKeys.length) {
          return false;
        }
        for (var i = 0; i < keys.length; i++) {
          if (!deepEqualExtended(spec[keys[i]], body[keys[i]])) {
            return false;
          }
        }
        return true;
      }
      return deepEqual_1(spec, body, { strict: true });
    }

    var stringify_1$1 = createCommonjsModule(function (module, exports) {
    exports = module.exports = stringify;
    exports.getSerialize = serializer;

    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }

    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];

      if (cycleReplacer == null) cycleReplacer = function(key, value) {
        if (stack[0] === value) return "[Circular ~]"
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
      };

      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
        }
        else stack.push(value);

        return replacer == null ? value : replacer.call(this, key, value)
      }
    }
    });
    var stringify_2 = stringify_1$1.getSerialize;

    var debug$4 = src('nock.interceptor');

    var fs$1;

    try {
        fs$1 = fs;
    } catch (err) {
        // do nothing, we're in the browser
    }

    var interceptor = Interceptor;

    function Interceptor(scope, uri, method, requestBody, interceptorOptions) {
        this.scope = scope;
        this.interceptorMatchHeaders = [];
        this.method = method.toUpperCase();
        this.uri = uri;
        this._key = this.method + ' ' + scope.basePath + scope.basePathname + (typeof uri === 'string' ? '' : '/') + uri;
        this.basePath = this.scope.basePath;
        this.path = (typeof uri === 'string') ? scope.basePathname + uri : uri;

        this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;
        this.options = interceptorOptions || {};
        this.counter = 1;
        this._requestBody = requestBody;

        //  We use lower-case header field names throughout Nock.
        this.reqheaders = common.headersFieldNamesToLowerCase((scope.scopeOptions && scope.scopeOptions.reqheaders) || {});
        this.badheaders = common.headersFieldsArrayToLowerCase((scope.scopeOptions && scope.scopeOptions.badheaders) || []);


        this.delayInMs = 0;
        this.delayConnectionInMs = 0;

        this.optional = false;
    }

    Interceptor.prototype.optionally = function optionally(value) {
        // The default behaviour of optionally() with no arguments is to make the mock optional.
        value = (typeof value === 'undefined') ? true : value;

        this.optional = value;

        return this;
    };

    Interceptor.prototype.replyWithError = function replyWithError(errorMessage) {
        this.errorMessage = errorMessage;

        lodash.defaults(this.options, this.scope.scopeOptions);

        this.scope.add(this._key, this, this.scope, this.scopeOptions);
        return this.scope;
    };

    Interceptor.prototype.reply = function reply(statusCode, body, rawHeaders) {
        if (arguments.length <= 2 && lodash.isFunction(statusCode)) {
            body = statusCode;
            statusCode = 200;
        }

        this.statusCode = statusCode;

        lodash.defaults(this.options, this.scope.scopeOptions);

        // convert rawHeaders from Array to Object
        var headers = common.headersArrayToObject(rawHeaders);

        if (this.scope._defaultReplyHeaders) {
            headers = headers || {};
            headers = common.headersFieldNamesToLowerCase(headers);
            headers = mixin_1(this.scope._defaultReplyHeaders, headers);
        }

        if (this.scope.date) {
            headers = headers || {};
            headers['date'] = this.scope.date.toUTCString();
        }

        if (headers !== undefined) {
            this.rawHeaders = [];

            // makes sure all keys in headers are in lower case
            for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                    this.rawHeaders.push(key);
                    this.rawHeaders.push(headers[key]);
                }
            }

            //  We use lower-case headers throughout Nock.
            this.headers = common.headersFieldNamesToLowerCase(headers);

            debug$4('reply.headers:', this.headers);
            debug$4('reply.rawHeaders:', this.rawHeaders);
        }

        //  If the content is not encoded we may need to transform the response body.
        //  Otherwise we leave it as it is.
        if (!common.isContentEncoded(this.headers)) {
            if (body && typeof (body) !== 'string' &&
                typeof (body) !== 'function' &&
                !Buffer.isBuffer(body) &&
                !common.isStream(body)) {
                try {
                    body = stringify_1$1(body);
                    if (!this.headers) {
                        this.headers = {};
                    }
                    if (!this.headers['content-type']) {
                        this.headers['content-type'] = 'application/json';
                    }
                    if (this.scope.contentLen) {
                        this.headers['content-length'] = body.length;
                    }
                } catch (err) {
                    throw new Error('Error encoding response body into JSON');
                }
            }
        }

        this.body = body;

        this.scope.add(this._key, this, this.scope, this.scopeOptions);
        return this.scope;
    };

    Interceptor.prototype.replyWithFile = function replyWithFile(statusCode, filePath, headers) {
        if (!fs$1) {
            throw new Error('No fs');
        }
        var readStream = fs$1.createReadStream(filePath);
        readStream.pause();
        this.filePath = filePath;
        return this.reply(statusCode, readStream, headers);
    };

    // Also match request headers
    // https://github.com/pgte/nock/issues/163
    Interceptor.prototype.reqheaderMatches = function reqheaderMatches(options, key) {
        //  We don't try to match request headers if these weren't even specified in the request.
        if (!options.headers) {
            return true;
        }

        var reqHeader = this.reqheaders[key];
        var header = options.headers[key];
        if (header && (typeof header !== 'string') && header.toString) {
            header = header.toString();
        }

        //  We skip 'host' header comparison unless it's available in both mock and actual request.
        //  This because 'host' may get inserted by Nock itself and then get recorder.
        //  NOTE: We use lower-case header field names throughout Nock.
        if (key === 'host' &&
            (lodash.isUndefined(header) ||
                lodash.isUndefined(reqHeader))) {
            return true;
        }

        if (!lodash.isUndefined(reqHeader) && !lodash.isUndefined(header)) {
            if (lodash.isFunction(reqHeader)) {
                return reqHeader(header);
            } else if (common.matchStringOrRegexp(header, reqHeader)) {
                return true;
            }
        }

        debug$4('request header field doesn\'t match:', key, header, reqHeader);
        return false;
    };

    Interceptor.prototype.match = function match(options, body, hostNameOnly) {
        if (debug$4.enabled) {
            debug$4('match %s, body = %s', stringify_1$1(options), stringify_1$1(body));
        }

        if (hostNameOnly) {
            return options.hostname === this.scope.urlParts.hostname;
        }

        var method = (options.method || 'GET').toUpperCase()
            , path$$1 = options.path
            , matches
            , matchKey
            , proto = options.proto;

        if (this.scope.transformPathFunction) {
            path$$1 = this.scope.transformPathFunction(path$$1);
        }
        if (typeof (body) !== 'string') {
            body = body.toString();
        }
        if (this.scope.transformRequestBodyFunction) {
            body = this.scope.transformRequestBodyFunction(body, this._requestBody);
        }

        var checkHeaders = function (header) {
            if (lodash.isFunction(header.value)) {
                return header.value(options.getHeader(header.name));
            }
            return common.matchStringOrRegexp(options.getHeader(header.name), header.value);
        };

        if (!this.scope.matchHeaders.every(checkHeaders) ||
            !this.interceptorMatchHeaders.every(checkHeaders)) {
            this.scope.logger('headers don\'t match');
            return false;
        }

        var reqHeadersMatch =
            !this.reqheaders ||
            Object.keys(this.reqheaders).every(this.reqheaderMatches.bind(this, options));

        if (!reqHeadersMatch) {
            return false;
        }

        function reqheaderContains(header) {
            return lodash.has(options.headers, header);
        }

        var reqContainsBadHeaders =
            this.badheaders &&
            lodash.some(this.badheaders, reqheaderContains);

        if (reqContainsBadHeaders) {
            return false;
        }

        //  If we have a filtered scope then we use it instead reconstructing
        //  the scope from the request options (proto, host and port) as these
        //  two won't necessarily match and we have to remove the scope that was
        //  matched (vs. that was defined).
        if (this.__nock_filteredScope) {
            matchKey = this.__nock_filteredScope;
        } else {
            matchKey = proto + '://' + options.host;
            if (
                options.port && options.host.indexOf(':') < 0 &&
                (options.port !== 80 || options.proto !== 'http') &&
                (options.port !== 443 || options.proto !== 'https')
            ) {
                matchKey += ":" + options.port;
            }
        }

        // Match query strings when using query()
        var matchQueries = true;
        var queryIndex = -1;
        var queryString;
        var queries;

        if (this.queries) {
            queryIndex = path$$1.indexOf('?');
            queryString = (queryIndex !== -1) ? path$$1.slice(queryIndex + 1) : '';
            queries = lib.parse(queryString);

            // Only check for query string matches if this.queries is an object
            if (lodash.isObject(this.queries)) {

                if (lodash.isFunction(this.queries)) {
                    matchQueries = this.queries(queries);
                } else {
                    // Make sure that you have an equal number of keys. We are
                    // looping through the passed query params and not the expected values
                    // if the user passes fewer query params than expected but all values
                    // match this will throw a false positive. Testing that the length of the
                    // passed query params is equal to the length of expected keys will prevent
                    // us from doing any value checking BEFORE we know if they have all the proper
                    // params
                    debug$4('this.queries: %j', this.queries);
                    debug$4('queries: %j', queries);
                    if (lodash.size(this.queries) !== lodash.size(queries)) {
                        matchQueries = false;
                    } else {
                        var self = this;
                        lodash.forOwn(queries, function matchOneKeyVal(val, key) {
                            var expVal = self.queries[key];
                            var isMatch = true;
                            if (val === undefined || expVal === undefined) {
                                isMatch = false;
                            } else if (expVal instanceof RegExp) {
                                isMatch = common.matchStringOrRegexp(val, expVal);
                            } else if (lodash.isArray(expVal) || lodash.isObject(expVal)) {
                                isMatch = lodash.isEqual(val, expVal);
                            } else {
                                isMatch = common.matchStringOrRegexp(val, expVal);
                            }
                            matchQueries = matchQueries && !!isMatch;
                        });
                    }
                    debug$4('matchQueries: %j', matchQueries);
                }
            }

            // Remove the query string from the path
            if (queryIndex !== -1) {
                path$$1 = path$$1.substr(0, queryIndex);
            }
        }

        if (typeof this.uri === 'function') {
            matches = matchQueries &&
                method === this.method &&
                common.matchStringOrRegexp(matchKey, this.basePath) &&
                this.uri.call(this, path$$1);
        } else {
            matches = method === this.method &&
                common.matchStringOrRegexp(matchKey, this.basePath) &&
                common.matchStringOrRegexp(path$$1, this.path) &&
                matchQueries;
        }

        // special logger for query()
        if (queryIndex !== -1) {
            this.scope.logger('matching ' + matchKey + path$$1 + '?' + queryString + ' to ' + this._key +
                ' with query(' + stringify_1$1(this.queries) + '): ' + matches);
        } else {
            this.scope.logger('matching ' + matchKey + path$$1 + ' to ' + this._key + ': ' + matches);
        }

        if (matches) {
            matches = (match_body.call(options, this._requestBody, body));
            if (!matches) {
                this.scope.logger('bodies don\'t match: \n', this._requestBody, '\n', body);
            }
        }

        return matches;
    };

    Interceptor.prototype.matchIndependentOfBody = function matchIndependentOfBody(options) {
        var isRegex = lodash.isRegExp(this.path);
        var isRegexBasePath = lodash.isRegExp(this.scope.basePath);

        var method = (options.method || 'GET').toUpperCase()
            , path$$1 = options.path
            , proto = options.proto;

        // NOTE: Do not split off the query params as the regex could use them
        if (!isRegex) {
            path$$1 = path$$1 ? path$$1.split('?')[0] : '';
        }

        if (this.scope.transformPathFunction) {
            path$$1 = this.scope.transformPathFunction(path$$1);
        }

        var checkHeaders = function (header) {
            return options.getHeader && common.matchStringOrRegexp(options.getHeader(header.name), header.value);
        };

        if (!this.scope.matchHeaders.every(checkHeaders) ||
            !this.interceptorMatchHeaders.every(checkHeaders)) {
            return false;
        }

        var comparisonKey = isRegex ? this.__nock_scopeKey : this._key;
        var matchKey = method + ' ' + proto + '://' + options.host + path$$1;

        if (isRegex && !isRegexBasePath) {
            return !!matchKey.match(comparisonKey) && !!path$$1.match(this.path);
        }

        if(isRegexBasePath) {
            return !!matchKey.match(this.scope.basePath) && !!path$$1.match(this.path);
        }

        return comparisonKey === matchKey;
    };

    Interceptor.prototype.filteringPath = function filteringPath() {
        if (lodash.isFunction(arguments[0])) {
            this.scope.transformFunction = arguments[0];
        }
        return this;
    };

    Interceptor.prototype.discard = function discard() {
        if ((this.scope.shouldPersist() || this.counter > 0) && this.filePath) {
            this.body = fs$1.createReadStream(this.filePath);
            this.body.pause();
        }

        if (!this.scope.shouldPersist() && this.counter < 1) {
            this.scope.remove(this._key, this);
        }
    };

    Interceptor.prototype.matchHeader = function matchHeader(name, value) {
        this.interceptorMatchHeaders.push({ name: name, value: value });
        return this;
    };

    Interceptor.prototype.basicAuth = function basicAuth(options) {
        var username = options['user'];
        var password = options['pass'] || '';
        var name = 'authorization';
        var value = 'Basic ' + new Buffer(username + ':' + password).toString('base64');
        this.interceptorMatchHeaders.push({ name: name, value: value });
        return this;
    };

    /**
     * Set query strings for the interceptor
     * @name query
     * @param Object Object of query string name,values (accepts regexp values)
     * @public
     * @example
     * // Will match 'http://zombo.com/?q=t'
     * nock('http://zombo.com').get('/').query({q: 't'});
     */
    Interceptor.prototype.query = function query(queries) {
        this.queries = this.queries || {};

        // Allow all query strings to match this route
        if (queries === true) {
            this.queries = queries;
            return this;
        }

        if (lodash.isFunction(queries)) {
            this.queries = queries;
            return this;
        }

        var stringFormattingFn;
        if (this.scope.scopeOptions.encodedQueryParams) {
            stringFormattingFn = common.percentDecode;
        }

        for (var key in queries) {
            if (lodash.isUndefined(this.queries[key])) {
                var formattedPair = common.formatQueryValue(key, queries[key], stringFormattingFn);
                this.queries[formattedPair[0]] = formattedPair[1];
            }
        }

        return this;
    };

    /**
     * Set number of times will repeat the interceptor
     * @name times
     * @param Integer Number of times to repeat (should be > 0)
     * @public
     * @example
     * // Will repeat mock 5 times for same king of request
     * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');
     */
    Interceptor.prototype.times = function times(newCounter) {
        if (newCounter < 1) {
            return this;
        }

        this.counter = newCounter;

        return this;
    };

    /**
     * An sugar syntax for times(1)
     * @name once
     * @see {@link times}
     * @public
     * @example
     * nock('http://zombo.com).get('/').once.reply(200, 'Ok');
     */
    Interceptor.prototype.once = function once() {
        return this.times(1);
    };

    /**
     * An sugar syntax for times(2)
     * @name twice
     * @see {@link times}
     * @public
     * @example
     * nock('http://zombo.com).get('/').twice.reply(200, 'Ok');
     */
    Interceptor.prototype.twice = function twice() {
        return this.times(2);
    };

    /**
     * An sugar syntax for times(3).
     * @name thrice
     * @see {@link times}
     * @public
     * @example
     * nock('http://zombo.com).get('/').thrice.reply(200, 'Ok');
     */
    Interceptor.prototype.thrice = function thrice() {
        return this.times(3);
    };

    /**
     * Delay the response by a certain number of ms.
     *
     * @param {(integer|object)} opts - Number of milliseconds to wait, or an object
     * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent
     * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent
     * @return {interceptor} - the current interceptor for chaining
     */
    Interceptor.prototype.delay = function delay(opts) {
        var headDelay = 0;
        var bodyDelay = 0;
        if (lodash.isNumber(opts)) {
            headDelay = opts;
        } else if (lodash.isObject(opts)) {
            headDelay = opts.head || 0;
            bodyDelay = opts.body || 0;
        } else {
            throw new Error("Unexpected input opts" + opts);
        }

        return this.delayConnection(headDelay)
            .delayBody(bodyDelay);
    };

    /**
     * Delay the response body by a certain number of ms.
     *
     * @param {integer} ms - Number of milliseconds to wait before response is sent
     * @return {interceptor} - the current interceptor for chaining
     */
    Interceptor.prototype.delayBody = function delayBody(ms) {
        this.delayInMs += ms;
        return this;
    };

    /**
     * Delay the connection by a certain number of ms.
     *
     * @param  {integer} ms - Number of milliseconds to wait
     * @return {interceptor} - the current interceptor for chaining
     */
    Interceptor.prototype.delayConnection = function delayConnection(ms) {
        this.delayConnectionInMs += ms;
        return this;
    };

    Interceptor.prototype.getTotalDelay = function getTotalDelay() {
        return this.delayInMs + this.delayConnectionInMs;
    };

    /**
     * Make the socket idle for a certain number of ms (simulated).
     *
     * @param  {integer} ms - Number of milliseconds to wait
     * @return {interceptor} - the current interceptor for chaining
     */
    Interceptor.prototype.socketDelay = function socketDelay(ms) {
        this.socketDelayInMs = ms;
        return this;
    };

    /**
     * @module nock/intercepts
     */

    var inherits         = util.inherits,
        parse$2            = url.parse,
        URL              = url.URL,
        debug$5            = src('nock.intercept'),
        EventEmitter$4     = events.EventEmitter;


    /**
     * @name NetConnectNotAllowedError
     * @private
     * @desc Error trying to make a connection when disabled external access.
     * @class
     * @example
     * nock.disableNetConnect();
     * http.get('http://zombo.com');
     * // throw NetConnectNotAllowedError
     */
    function NetConnectNotAllowedError(host, path$$1) {
      Error.call(this);

      this.name    = 'NetConnectNotAllowedError';
      this.code    = 'ENETUNREACH';
      this.message = 'Nock: Not allow net connect for "' + host + path$$1 + '"';

      Error.captureStackTrace(this, this.constructor);
    }

    inherits(NetConnectNotAllowedError, Error);

    var allInterceptors = {},
        allowNetConnect;

    /**
     * Enabled real request.
     * @public
     * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match
     * @example
     * // Enables all real requests
     * nock.enableNetConnect();
     * @example
     * // Enables real requests for url that matches google
     * nock.enableNetConnect('google');
     * @example
     * // Enables real requests for url that matches google and amazon
     * nock.enableNetConnect(/(google|amazon)/);
     */
    function enableNetConnect(matcher) {
      if (lodash.isString(matcher)) {
        allowNetConnect = new RegExp(matcher);
      } else if (lodash.isObject(matcher) && lodash.isFunction(matcher.test)) {
        allowNetConnect = matcher;
      } else {
        allowNetConnect = /.*/;
      }
    }

    function isEnabledForNetConnect(options) {
      common.normalizeRequestOptions(options);

      var enabled = allowNetConnect && allowNetConnect.test(options.host);
      debug$5('Net connect', enabled ? '' : 'not', 'enabled for', options.host);
      return enabled;
    }

    /**
     * Disable all real requests.
     * @public
     * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match
     * @example
     * nock.disableNetConnect();
    */
    function disableNetConnect() {
      allowNetConnect = undefined;
    }

    function isOn() {
      return !isOff();
    }

    function isOff() {
      return process.env.NOCK_OFF === 'true';
    }

    function add(key, interceptor$$1, scope, scopeOptions, host) {
      if (! allInterceptors.hasOwnProperty(key)) {
        allInterceptors[key] = { key: key, scopes: [] };
      }
      interceptor$$1.__nock_scope = scope;

      //  We need scope's key and scope options for scope filtering function (if defined)
      interceptor$$1.__nock_scopeKey = key;
      interceptor$$1.__nock_scopeOptions = scopeOptions;
      //  We need scope's host for setting correct request headers for filtered scopes.
      interceptor$$1.__nock_scopeHost = host;
      interceptor$$1.interceptionCounter = 0;

      if (scopeOptions.allowUnmocked)
        allInterceptors[key].allowUnmocked = true;

      allInterceptors[key].scopes.push(interceptor$$1);
    }

    function remove(interceptor$$1) {
      if (interceptor$$1.__nock_scope.shouldPersist() || --interceptor$$1.counter > 0) {
        return;
      }

      var basePath = interceptor$$1.basePath;
      var interceptors = allInterceptors[basePath] && allInterceptors[basePath].scopes || [];

      interceptors.some(function (thisInterceptor, i) {
        return (thisInterceptor === interceptor$$1) ? interceptors.splice(i, 1) : false;
      });
    }

    function removeAll() {
      Object.keys(allInterceptors).forEach(function(key) {
        allInterceptors[key].scopes.forEach(function(interceptor$$1) {
          interceptor$$1.scope.keyedInterceptors = {};
        });
      });
      allInterceptors = {};
    }

    function interceptorsFor(options) {
      var basePath,
          matchingInterceptor;

      common.normalizeRequestOptions(options);

      debug$5('interceptors for %j', options.host);

      basePath = options.proto + '://' + options.host;

      debug$5('filtering interceptors for basepath', basePath);

      //  First try to use filteringScope if any of the interceptors has it defined.
      lodash.each(allInterceptors, function(interceptor$$1, k) {
        lodash.each(interceptor$$1.scopes, function(scope) {
          var filteringScope = scope.__nock_scopeOptions.filteringScope;

          //  If scope filtering function is defined and returns a truthy value
          //  then we have to treat this as a match.
          if(filteringScope && filteringScope(basePath)) {
            debug$5('found matching scope interceptor');

            //  Keep the filtered scope (its key) to signal the rest of the module
            //  that this wasn't an exact but filtered match.
            scope.__nock_filteredScope = scope.__nock_scopeKey;
            matchingInterceptor = interceptor$$1.scopes;
            //  Break out of _.each for scopes.
            return false;
          }
        });

        if (!matchingInterceptor && common.matchStringOrRegexp(basePath, interceptor$$1.key)) {
          if (interceptor$$1.scopes.length === 0 && interceptor$$1.allowUnmocked) {
            matchingInterceptor = [
              {
                options: { allowUnmocked: true },
                matchIndependentOfBody: function() { return false }
              }
            ];
          } else {
            matchingInterceptor = interceptor$$1.scopes;
          }
          // false to short circuit the .each
          return false;
        }

        //  Returning falsy value here (which will happen if we have found our matching interceptor)
        //  will break out of _.each for all interceptors.
        return !matchingInterceptor;
      });

      return matchingInterceptor;
    }

    function removeInterceptor(options) {
      var baseUrl, key, method, proto;
      if (options instanceof interceptor) {
        baseUrl = options.basePath;
        key = options._key;
      } else {
        proto = options.proto ? options.proto : 'http';

        common.normalizeRequestOptions(options);
        baseUrl = proto + '://' + options.host;
        method = options.method && options.method.toUpperCase() || 'GET';
        key = method + ' ' + baseUrl + (options.path || '/');
      }

      if (allInterceptors[baseUrl] && allInterceptors[baseUrl].scopes.length > 0) {
        if (key) {
          for (var i = 0; i < allInterceptors[baseUrl].scopes.length; i++) {
            var interceptor$$1 = allInterceptors[baseUrl].scopes[i];
            if (interceptor$$1._key === key) {
              allInterceptors[baseUrl].scopes.splice(i, 1);
              interceptor$$1.scope.remove(key, interceptor$$1);
              break;
            }
          }
        } else {
          allInterceptors[baseUrl].scopes.length = 0;
        }

        return true;
      }

      return false;
    }
    //  Variable where we keep the ClientRequest we have overridden
    //  (which might or might not be node's original http.ClientRequest)
    var originalClientRequest;

    function ErroringClientRequest(error) {
      if (http.OutgoingMessage) http.OutgoingMessage.call(this);
      process.nextTick(function() {
        this.emit('error', error);
      }.bind(this));
    }

    if (http.ClientRequest) {
      inherits(ErroringClientRequest, http.ClientRequest);
    }

    function overrideClientRequest() {
      debug$5('Overriding ClientRequest');

      if(originalClientRequest) {
        throw new Error('Nock already overrode http.ClientRequest');
      }

      // ----- Extending http.ClientRequest

      //  Define the overriding client request that nock uses internally.
      function OverriddenClientRequest(options, cb) {
        if (http.OutgoingMessage) http.OutgoingMessage.call(this);

        //  Filter the interceptors per request options.
        var interceptors = interceptorsFor(options);

        if (isOn() && interceptors) {
          debug$5('using', interceptors.length, 'interceptors');

          //  Use filtered interceptors to intercept requests.
          var overrider = request_overrider(this, options, interceptors, remove, cb);
          for(var propName in overrider) {
            if (overrider.hasOwnProperty(propName)) {
              this[propName] = overrider[propName];
            }
          }
        } else {
          debug$5('falling back to original ClientRequest');

          //  Fallback to original ClientRequest if nock is off or the net connection is enabled.
          if(isOff() || isEnabledForNetConnect(options)) {
            originalClientRequest.apply(this, arguments);
          } else {
            timers.setImmediate(function () {
              var error = new NetConnectNotAllowedError(options.host, options.path);
              this.emit('error', error);
            }.bind(this));
          }
        }
      }
      if (http.ClientRequest) {
        inherits(OverriddenClientRequest, http.ClientRequest);
      } else {
        inherits(OverriddenClientRequest, EventEmitter$4);
      }

      //  Override the http module's request but keep the original so that we can use it and later restore it.
      //  NOTE: We only override http.ClientRequest as https module also uses it.
      originalClientRequest = http.ClientRequest;
      http.ClientRequest = OverriddenClientRequest;

      debug$5('ClientRequest overridden');
    }

    function restoreOverriddenClientRequest() {
      debug$5('restoring overridden ClientRequest');

      //  Restore the ClientRequest we have overridden.
      if(!originalClientRequest) {
        debug$5('- ClientRequest was not overridden');
      } else {
        http.ClientRequest = originalClientRequest;
        originalClientRequest = undefined;

        debug$5('- ClientRequest restored');
      }
    }

    function isActive() {

      //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.
      //  This means that Nock has been activated.
      return !lodash.isUndefined(originalClientRequest);

    }

    function interceptorScopes() {
      return lodash.reduce(allInterceptors, function(result, interceptors) {
        for (var interceptor$$1 in interceptors.scopes) {
          result = result.concat(interceptors.scopes[interceptor$$1].__nock_scope);
        }

        return result;
      }, []);
    }

    function isDone() {
      return lodash.every(interceptorScopes(), function(scope) {
        return scope.isDone();
      });
    }

    function pendingMocks() {
      return lodash.flatten(lodash.map(interceptorScopes(), function(scope) {
        return scope.pendingMocks();
      }));
    }

    function activeMocks() {
      return lodash.flatten(lodash.map(interceptorScopes(), function(scope) {
        return scope.activeMocks();
      }));
    }

    function activate() {

      if(originalClientRequest) {
        throw new Error('Nock already active');
      }

      overrideClientRequest();

      // ----- Overriding http.request and https.request:

      common.overrideRequests(function(proto, overriddenRequest, options, callback) {
        //  NOTE: overriddenRequest is already bound to its module.
        var req,
            res;

        if (typeof options === 'string') {
          options = parse$2(options);
        } else if (URL && options instanceof URL) {
          options = parse$2(options.toString());
        }
        options.proto = proto;

        var interceptors = interceptorsFor(options);

        if (isOn() && interceptors) {
          var matches = false,
              allowUnmocked = false;

          matches = !! lodash.find(interceptors, function(interceptor$$1) {
            return interceptor$$1.matchIndependentOfBody(options);
          });

          allowUnmocked = !! lodash.find(interceptors, function(interceptor$$1) {
            return interceptor$$1.options.allowUnmocked;
          });

          if (! matches && allowUnmocked) {
            if (proto === 'https') {
              var ClientRequest = http.ClientRequest;
              http.ClientRequest = originalClientRequest;
              req = overriddenRequest(options, callback);
              http.ClientRequest = ClientRequest;
            } else {
              req = overriddenRequest(options, callback);
            }
            global_emitter.emit('no match', req);
            return req;
          }

          //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing
          //    our own OverriddenClientRequest.
          req = new http.ClientRequest(options);

          res = request_overrider(req, options, interceptors, remove);
          if (callback) {
            res.on('response', callback);
          }
          return req;
        } else {
          global_emitter.emit('no match', options);
          if (isOff() || isEnabledForNetConnect(options)) {
            return overriddenRequest(options, callback);
          } else {
            var error = new NetConnectNotAllowedError(options.host, options.path);
            return new ErroringClientRequest(error);
          }
        }
      });

    }

    activate();

    var intercept = add;
    var removeAll_1 = removeAll;
    var removeInterceptor_1 = removeInterceptor;
    var isOn_1 = isOn;
    var activate_1 = activate;
    var isActive_1 = isActive;
    var isDone_1 = isDone;
    var pendingMocks_1 = pendingMocks;
    var activeMocks_1 = activeMocks;
    var enableNetConnect_1 = enableNetConnect;
    var disableNetConnect_1 = disableNetConnect;
    var overrideClientRequest_1 = overrideClientRequest;
    var restoreOverriddenClientRequest_1 = restoreOverriddenClientRequest;
    intercept.removeAll = removeAll_1;
    intercept.removeInterceptor = removeInterceptor_1;
    intercept.isOn = isOn_1;
    intercept.activate = activate_1;
    intercept.isActive = isActive_1;
    intercept.isDone = isDone_1;
    intercept.pendingMocks = pendingMocks_1;
    intercept.activeMocks = activeMocks_1;
    intercept.enableNetConnect = enableNetConnect_1;
    intercept.disableNetConnect = disableNetConnect_1;
    intercept.overrideClientRequest = overrideClientRequest_1;
    intercept.restoreOverriddenClientRequest = restoreOverriddenClientRequest_1;

    var inspect$1 = util.inspect;
    var parse$3 = url.parse;


    var debug$6 = src('nock.recorder');

    var URL$1 = url;



    var SEPARATOR = '\n<<<<<<-- cut here -->>>>>>\n';
    var recordingInProgress = false;
    var outputs = [];

    function getScope(options) {

      common.normalizeRequestOptions(options);

      var scope = [];
      if (options._https_) {
        scope.push('https://');
      } else {
        scope.push('http://');
      }

      scope.push(options.host);

      //  If a non-standard port wasn't specified in options.host, include it from options.port.
      if(options.host.indexOf(':') === -1 &&
         options.port &&
         ((options._https_ && options.port.toString() !== '443') ||
           (!options._https_ && options.port.toString() !== '80'))) {
        scope.push(':');
        scope.push(options.port);
      }

      return scope.join('');

    }

    function getMethod(options) {

      return (options.method || 'GET');

    }

    var getBodyFromChunks = function(chunks, headers) {

      //  If we have headers and there is content-encoding it means that
      //  the body shouldn't be merged but instead persisted as an array
      //  of hex strings so that the responses can be mocked one by one.
      if(common.isContentEncoded(headers)) {
        return {
          body: lodash.map(chunks, function(chunk) {
            if(!Buffer.isBuffer(chunk)) {
              if (typeof chunk === 'string') {
                chunk = new Buffer(chunk);
              } else {
                throw new Error('content-encoded responses must all be binary buffers');
              }
            }

            return chunk.toString('hex');
          })
        };
      }

      var mergedBuffer = common.mergeChunks(chunks);

      //  The merged buffer can be one of three things:
      //    1.  A binary buffer which then has to be recorded as a hex string.
      //    2.  A string buffer which represents a JSON object.
      //    3.  A string buffer which doesn't represent a JSON object.

      var isBinary = common.isBinaryBuffer(mergedBuffer);
      if(isBinary) {
        return {
          body: mergedBuffer.toString('hex'),
          isBinary: true
        }
      } else {
        var maybeStringifiedJson = mergedBuffer.toString('utf8');
        try {
          return {
            body: JSON.parse(maybeStringifiedJson),
            isBinary: false
          };
        } catch(err) {
          return {
            body: maybeStringifiedJson,
            isBinary: false
          };
        }
      }
    };

    function generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks) {

      var response = getBodyFromChunks(dataChunks, res.headers);
      options.path = req.path;

      var nockDef = {
        scope:    getScope(options),
        method:   getMethod(options),
        path:     options.path,
        body:     getBodyFromChunks(bodyChunks).body,
        status:   res.statusCode,
        response: response.body,
        rawHeaders: res.rawHeaders || res.headers,
        reqheaders: req._headers
      };

      if (response.isBinary) {
        nockDef.responseIsBinary = true;
      }

      return nockDef;
    }

    function generateRequestAndResponse(req, bodyChunks, options, res, dataChunks) {

      var requestBody = getBodyFromChunks(bodyChunks).body;
      var responseBody = getBodyFromChunks(dataChunks, res.headers).body;

      // Remove any query params from options.path so they can be added in the query() function
      var path$$1 = options.path;
      var queryIndex = 0;
      var queryObj = {};
      if ((queryIndex = req.path.indexOf('?')) !== -1) {
        // Remove the query from the path
        path$$1 = path$$1.substring(0, queryIndex);

        // Create the query() object
        var queryStr = req.path.slice(queryIndex + 1);
        queryObj = lib.parse(queryStr);
      }
      // Always encoding the query parameters when recording.
      var encodedQueryObj = {};
      for (var key in queryObj) {
        var formattedPair = common.formatQueryValue(key, queryObj[key], common.percentEncode);
        encodedQueryObj[formattedPair[0]] = formattedPair[1];
      }

      var ret = [];
      ret.push('\nnock(\'');
      ret.push(getScope(options));
      ret.push('\', ');
      ret.push(JSON.stringify({ encodedQueryParams: true }));
      ret.push(')\n');
      ret.push('  .');
      ret.push(getMethod(options).toLowerCase());
      ret.push('(\'');
      ret.push(path$$1);
      ret.push("'");
      if (requestBody) {
        ret.push(', ');
        ret.push(JSON.stringify(requestBody));
      }
      ret.push(")\n");
      if (req.headers) {
        for (var k in req.headers) {
          ret.push('  .matchHeader(' + JSON.stringify(k) + ', ' + JSON.stringify(req.headers[k]) + ')\n');
        }
      }

      if (queryIndex !== -1) {
        ret.push('  .query(');
        ret.push(JSON.stringify(encodedQueryObj));
        ret.push(')\n');
      }

      ret.push('  .reply(');
      ret.push(res.statusCode.toString());
      ret.push(', ');
      ret.push(JSON.stringify(responseBody));
      if (res.rawHeaders) {
        ret.push(', ');
        ret.push(inspect$1(res.rawHeaders));
      } else if (res.headers) {
        ret.push(', ');
        ret.push(inspect$1(res.headers));
      }
      ret.push(');\n');

      return ret.join('');
    }

    //  This module variable is used to identify a unique recording ID in order to skip
    //  spurious requests that sometimes happen. This problem has been, so far,
    //  exclusively detected in nock's unit testing where 'checks if callback is specified'
    //  interferes with other tests as its t.end() is invoked without waiting for request
    //  to finish (which is the point of the test).
    var currentRecordingId = 0;

    function record(rec_options) {

      //  Set the new current recording ID and capture its value in this instance of record().
      currentRecordingId = currentRecordingId + 1;
      var thisRecordingId = currentRecordingId;

      debug$6('start recording', thisRecordingId, JSON.stringify(rec_options));

      //  Trying to start recording with recording already in progress implies an error
      //  in the recording configuration (double recording makes no sense and used to lead
      //  to duplicates in output)
      if(recordingInProgress) {
        throw new Error('Nock recording already in progress');
      }

      recordingInProgress = true;

      //  Originaly the parameters was a dont_print boolean flag.
      //  To keep the existing code compatible we take that case into account.
      var optionsIsObject = typeof rec_options === 'object';
      var dont_print = (typeof rec_options === 'boolean' && rec_options) ||
          (optionsIsObject && rec_options.dont_print);
      var output_objects = optionsIsObject && rec_options.output_objects;
      var enable_reqheaders_recording = optionsIsObject && rec_options.enable_reqheaders_recording;
      // eslint-disable-next-line no-console
      var logging = (optionsIsObject && rec_options.logging) || console.log;
      var use_separator = true;
      if (optionsIsObject && lodash.has(rec_options, 'use_separator')) {
        use_separator = rec_options.use_separator;
      }

      debug$6(thisRecordingId, 'restoring overridden requests before new overrides');
      //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)
      //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)
      //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct
      //    behavior in the face of other modules also overriding ClientRequest.
      common.restoreOverriddenRequests();
      //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)
      intercept.restoreOverriddenClientRequest();

      //  We override the requests so that we can save information on them before executing.
      common.overrideRequests(function(proto, overriddenRequest, options, callback) {

        var bodyChunks = [];

        if (typeof options == 'string') {
          var url$$1 = URL$1.parse(options);
          options = {
            hostname: url$$1.hostname,
            method: 'GET',
            port: url$$1.port,
            path: url$$1.path
          };
        }

        // Node 0.11 https.request calls http.request -- don't want to record things
        // twice.
        if (options._recording) {
          return overriddenRequest(options, callback);
        }
        options._recording = true;

        var req = overriddenRequest(options, function(res) {

          debug$6(thisRecordingId, 'intercepting', proto, 'request to record');

          if (typeof options === 'string') {
            options = parse$3(options);
          }

          //  We put our 'end' listener to the front of the listener array.
          res.once('end', function() {
            debug$6(thisRecordingId, proto, 'intercepted request ended');

            var out;
            if(output_objects) {
              out = generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks);
              if(out.reqheaders) {
                //  We never record user-agent headers as they are worse than useless -
                //  they actually make testing more difficult without providing any benefit (see README)
                common.deleteHeadersField(out.reqheaders, 'user-agent');

                //  Remove request headers completely unless it was explicitly enabled by the user (see README)
                if(!enable_reqheaders_recording) {
                  delete out.reqheaders;
                }
              }
            } else {
              out = generateRequestAndResponse(req, bodyChunks, options, res, dataChunks);
            }

            debug$6('out:', out);

            //  Check that the request was made during the current recording.
            //  If it hasn't then skip it. There is no other simple way to handle
            //  this as it depends on the timing of requests and responses. Throwing
            //  will make some recordings/unit tests faily randomly depending on how
            //  fast/slow the response arrived.
            //  If you are seeing this error then you need to make sure that all
            //  the requests made during a single recording session finish before
            //  ending the same recording session.
            if(thisRecordingId !== currentRecordingId) {
              debug$6('skipping recording of an out-of-order request', out);
              return;
            }

            outputs.push(out);

            if (!dont_print) {
              if (use_separator) {
                if (typeof out !== 'string') {
                  out = JSON.stringify(out, null, 2);
                }
                logging(SEPARATOR + out + SEPARATOR);
              } else {
                logging(out);
              }
            }
          });

          var dataChunks = [];
          var encoding$$1;

          // We need to be aware of changes to the stream's encoding so that we
          // don't accidentally mangle the data.
          var setEncoding = res.setEncoding;
          res.setEncoding = function (newEncoding) {
            encoding$$1 = newEncoding;
            return setEncoding.apply(this, arguments);
          };

          // Replace res.push with our own implementation that stores chunks
          var origResPush = res.push;
          res.push = function(data) {
            if (data) {
              if (encoding$$1) {
                data = new Buffer(data, encoding$$1);
              }
              dataChunks.push(data);
            }

            return origResPush.call(res, data);
          };

          if (callback) {
            callback(res, options, callback);
          } else {
            res.resume();
          }

          debug$6('finished setting up intercepting');

          if (proto === 'https') {
            options._https_ = true;
          }

        });

        var oldWrite = req.write;
        req.write = function(data, encoding$$1) {
          if ('undefined' !== typeof(data)) {
            if (data) {
              debug$6(thisRecordingId, 'new', proto, 'body chunk');
              if (! Buffer.isBuffer(data)) {
                data = new Buffer(data, encoding$$1);
              }
              bodyChunks.push(data);
            }
            oldWrite.apply(req, arguments);
          }
        };

        // in Node 8, res.end() does not call res.write() directly
        if (semver.satisfies(process.version, '>=8')) {
          var oldEnd = req.end;
          req.end = function(data, encoding$$1) {
            if (data) {
              debug$6(thisRecordingId, 'new', proto, 'body chunk');
              if (! Buffer.isBuffer(data)) {
                data = new Buffer(data, encoding$$1);
              }
              bodyChunks.push(data);
            }
            oldEnd.apply(req, arguments);
          };
        }

        return req;
      });
    }

    //  Restores *all* the overridden http/https modules' properties.
    function restore() {
      debug$6(currentRecordingId, 'restoring all the overridden http/https properties');

      common.restoreOverriddenRequests();
      intercept.restoreOverriddenClientRequest();
      recordingInProgress = false;
    }

    function clear() {
      outputs = [];
    }

    var record_1 = record;
    var outputs_1 = function() {
      return outputs;
    };
    var restore_1 = restore;
    var clear_1 = clear;

    var recorder = {
    	record: record_1,
    	outputs: outputs_1,
    	restore: restore_1,
    	clear: clear_1
    };

    var scope = createCommonjsModule(function (module) {
    /* eslint-disable strict */
    /**
     * @module nock/scope
     */
    var debug           = src('nock.scope')
      , EventEmitter    = events.EventEmitter ;

    var fs$$1;

    try {
      fs$$1 = fs;
    } catch(err) {
      // do nothing, we're in the browser
    }

    function startScope(basePath, options) {
      return new Scope(basePath, options);
    }

    function Scope(basePath, options) {
      if (!(this instanceof Scope)) {
        return new Scope(basePath, options);
      }

      EventEmitter.apply(this);
      this.keyedInterceptors = {};
      this.interceptors = [];
      this.transformPathFunction = null;
      this.transformRequestBodyFunction = null;
      this.matchHeaders = [];
      this.logger = debug;
      this.scopeOptions = options || {};
      this.urlParts = {};
      this._persist = false;
      this.contentLen = false;
      this.date = null;
      this.basePath = basePath;
      this.basePathname = '';
      this.port = null;

      if (!(basePath instanceof RegExp)) {
        this.urlParts = url.parse(basePath);
        this.port = this.urlParts.port || ((this.urlParts.protocol === 'http:') ? 80 : 443);
        this.basePathname = this.urlParts.pathname.replace(/\/$/, '');
        this.basePath = this.urlParts.protocol + '//' + this.urlParts.hostname + ':' + this.port;
      }
    }

    util.inherits(Scope, EventEmitter);

    Scope.prototype.add = function add(key, interceptor$$1, scope) {
      if (! this.keyedInterceptors.hasOwnProperty(key)) {
        this.keyedInterceptors[key] = [];
      }
      this.keyedInterceptors[key].push(interceptor$$1);
      intercept(this.basePath,
          interceptor$$1,
          this,
          this.scopeOptions,
          this.urlParts.hostname);
    };

    Scope.prototype.remove = function remove(key, interceptor$$1) {
      if (this._persist) {
        return;
      }
      var arr = this.keyedInterceptors[key];
      if (arr) {
        arr.splice(arr.indexOf(interceptor$$1), 1);
        if (arr.length === 0) {
          delete this.keyedInterceptors[key];
        }
      }
    };

    Scope.prototype.intercept = function intercept$$1(uri, method, requestBody, interceptorOptions) {
      var ic = new interceptor(this, uri, method, requestBody, interceptorOptions);

      this.interceptors.push(ic);
      return ic;
    };

    Scope.prototype.get = function get(uri, requestBody, options) {
      return this.intercept(uri, 'GET', requestBody, options);
    };

    Scope.prototype.post = function post(uri, requestBody, options) {
      return this.intercept(uri, 'POST', requestBody, options);
    };

    Scope.prototype.put = function put(uri, requestBody, options) {
      return this.intercept(uri, 'PUT', requestBody, options);
    };

    Scope.prototype.head = function head(uri, requestBody, options) {
      return this.intercept(uri, 'HEAD', requestBody, options);
    };

    Scope.prototype.patch = function patch(uri, requestBody, options) {
      return this.intercept(uri, 'PATCH', requestBody, options);
    };

    Scope.prototype.merge = function merge(uri, requestBody, options) {
      return this.intercept(uri, 'MERGE', requestBody, options);
    };

    Scope.prototype.delete = function _delete(uri, requestBody, options) {
      return this.intercept(uri, 'DELETE', requestBody, options);
    };

    Scope.prototype.options = function _options(uri, requestBody, options) {
      return this.intercept(uri, 'OPTIONS', requestBody, options);
    };

    Scope.prototype.pendingMocks = function pendingMocks() {
      var self = this;

      var pendingInterceptorKeys = Object.keys(this.keyedInterceptors).filter(function (key) {
        var interceptorList = self.keyedInterceptors[key];
        var pendingInterceptors = interceptorList.filter(function (interceptor$$1) {
          // TODO: This assumes that completed mocks are removed from the keyedInterceptors list
          // (when persistence is off). We should change that (and this) in future.
          var persistedAndUsed = self._persist && interceptor$$1.interceptionCounter > 0;
          return !persistedAndUsed && !interceptor$$1.optional;
        });
        return pendingInterceptors.length > 0;
      });

      return pendingInterceptorKeys;
    };

    // Returns all keyedInterceptors that are active.
    // This incomplete interceptors, persisted but complete interceptors, and
    // optional interceptors, but not non-persisted and completed interceptors.
    Scope.prototype.activeMocks = function activeMocks() {
      return Object.keys(this.keyedInterceptors);
    };

    Scope.prototype.isDone = function isDone() {
      // if nock is turned off, it always says it's done
      if (! intercept.isOn()) { return true; }

      return this.pendingMocks().length === 0;
    };

    Scope.prototype.done = function done() {
      assert.ok(this.isDone(), "Mocks not yet satisfied:\n" + this.pendingMocks().join("\n"));
    };

    Scope.prototype.buildFilter = function buildFilter() {
      var filteringArguments = arguments;

      if (arguments[0] instanceof RegExp) {
        return function(candidate) {
          if (candidate) {
            candidate = candidate.replace(filteringArguments[0], filteringArguments[1]);
          }
          return candidate;
        };
      } else if (lodash.isFunction(arguments[0])) {
        return arguments[0];
      }
    };

    Scope.prototype.filteringPath = function filteringPath() {
      this.transformPathFunction = this.buildFilter.apply(this, arguments);
      if (!this.transformPathFunction) {
        throw new Error('Invalid arguments: filtering path should be a function or a regular expression');
      }
      return this;
    };

    Scope.prototype.filteringRequestBody = function filteringRequestBody() {
      this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments);
      if (!this.transformRequestBodyFunction) {
        throw new Error('Invalid arguments: filtering request body should be a function or a regular expression');
      }
      return this;
    };

    Scope.prototype.matchHeader = function matchHeader(name, value) {
      //  We use lower-case header field names throughout Nock.
      this.matchHeaders.push({ name: name.toLowerCase(), value: value });
      return this;
    };

    Scope.prototype.defaultReplyHeaders = function defaultReplyHeaders(headers) {
      this._defaultReplyHeaders = common.headersFieldNamesToLowerCase(headers);
      return this;
    };

    Scope.prototype.log = function log(newLogger) {
      this.logger = newLogger;
      return this;
    };

    Scope.prototype.persist = function persist(flag) {
      this._persist = flag == null ? true : flag;
      if (typeof this._persist !== 'boolean') {
        throw new Error('Invalid arguments: argument should be a boolean');
      }
      return this;
    };

    Scope.prototype.shouldPersist = function shouldPersist() {
      return this._persist;
    };

    Scope.prototype.replyContentLength = function replyContentLength() {
      this.contentLen = true;
      return this;
    };

    Scope.prototype.replyDate = function replyDate(d) {
      this.date = d || new Date();
      return this;
    };




    function cleanAll() {
      intercept.removeAll();
      return module.exports;
    }

    function loadDefs(path$$1) {
      if (! fs$$1) {
        throw new Error('No fs');
      }

      var contents = fs$$1.readFileSync(path$$1);
      return JSON.parse(contents);
    }

    function load(path$$1) {
      return define(loadDefs(path$$1));
    }

    function getStatusFromDefinition(nockDef) {
      //  Backward compatibility for when `status` was encoded as string in `reply`.
      if (!lodash.isUndefined(nockDef.reply)) {
        //  Try parsing `reply` property.
        var parsedReply = parseInt(nockDef.reply, 10);
        if (lodash.isNumber(parsedReply)) {
          return parsedReply;
        }
      }

      var DEFAULT_STATUS_OK = 200;
      return nockDef.status || DEFAULT_STATUS_OK;
    }

    function getScopeFromDefinition(nockDef) {

      //  Backward compatibility for when `port` was part of definition.
      if (!lodash.isUndefined(nockDef.port)) {
        //  Include `port` into scope if it doesn't exist.
        var options = url.parse(nockDef.scope);
        if (lodash.isNull(options.port)) {
          return nockDef.scope + ':' + nockDef.port;
        } else {
          if (parseInt(options.port) !== parseInt(nockDef.port)) {
            throw new Error('Mismatched port numbers in scope and port properties of nock definition.');
          }
        }
      }

      return nockDef.scope;
    }

    function tryJsonParse(string) {
      try {
        return JSON.parse(string);
      } catch(err) {
        return string;
      }
    }

    function define(nockDefs) {

      var nocks     = [];

      nockDefs.forEach(function(nockDef) {

        var nscope     = getScopeFromDefinition(nockDef)
          , npath      = nockDef.path
          , method     = nockDef.method.toLowerCase() || "get"
          , status     = getStatusFromDefinition(nockDef)
          , rawHeaders = nockDef.rawHeaders || []
          , reqheaders = nockDef.reqheaders || {}
          , badheaders = nockDef.badheaders || []
          , body       = nockDef.body       || ''
          , options    = nockDef.options    || {};

        //  We use request headers for both filtering (see below) and mocking.
        //  Here we are setting up mocked request headers but we don't want to
        //  be changing the user's options object so we clone it first.
        options = lodash.clone(options) || {};
        options.reqheaders = reqheaders;
        options.badheaders = badheaders;

        //  Response is not always JSON as it could be a string or binary data or
        //  even an array of binary buffers (e.g. when content is enconded)
        var response;
        if (!nockDef.response) {
          response = '';
        } else if (nockDef.responseIsBinary) {
          response = Buffer.from(nockDef.response, 'hex');
        } else {
          response = lodash.isString(nockDef.response) ? tryJsonParse(nockDef.response) : nockDef.response;
        }

        var nock;
        if (body==="*") {
          nock = startScope(nscope, options).filteringRequestBody(function() {
            return "*";
          })[method](npath, "*").reply(status, response, rawHeaders);
        } else {
          nock = startScope(nscope, options);
          //  If request headers were specified filter by them.
          if (lodash.size(reqheaders) > 0) {
            for (var k in reqheaders) {
              nock.matchHeader(k, reqheaders[k]);
            }
          }
          if (nockDef.filteringRequestBody) {
            nock.filteringRequestBody(nockDef.filteringRequestBody);
          }
          nock.intercept(npath, method, body).reply(status, response, rawHeaders);
        }

        nocks.push(nock);

      });

      return nocks;
    }

    module.exports = Object.assign(startScope, {
      cleanAll: cleanAll,
      activate: intercept.activate,
      isActive: intercept.isActive,
      isDone: intercept.isDone,
      pendingMocks: intercept.pendingMocks,
      activeMocks: intercept.activeMocks,
      removeInterceptor: intercept.removeInterceptor,
      disableNetConnect: intercept.disableNetConnect,
      enableNetConnect: intercept.enableNetConnect,
      load: load,
      loadDefs: loadDefs,
      define: define,
      emitter: global_emitter,
    });
    });

    var _0777 = parseInt('0777', 8);

    var mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;

                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made);
                        else cb(null, made);
                    });
                    break;
            }
        });
    }

    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;

        p = path.resolve(p);

        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;

                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }

        return made;
    };

    var back = createCommonjsModule(function (module, exports) {

    /* global Promise */





    var format = util.format;

    var expect = chai$1.expect;
    var debug = src('nock.back');

    var _mode = null;

    var fs$$1;

    try {
      fs$$1 = fs;
    } catch(err) {
      // do nothing, probably in browser
    }

    var mkdirp$$1;
    try {
      mkdirp$$1 = mkdirp;
    } catch(err) {
      // do nothing, probably in browser
    }


    /**
     * nock the current function with the fixture given
     *
     * @param {string}   fixtureName  - the name of the fixture, e.x. 'foo.json'
     * @param {object}   options      - [optional] extra options for nock with, e.x. `{ assert: true }`
     * @param {function} nockedFn     - [optional] callback function to be executed with the given fixture being loaded;
     *                                  if defined the function will be called with context `{ scopes: loaded_nocks || [] }`
     *                                  set as `this` and `nockDone` callback function as first and only parameter;
     *                                  if not defined a promise resolving to `{nockDone, context}` where `context` is
     *                                  aforementioned `{ scopes: loaded_nocks || [] }`
     *
     * List of options:
     *
     * @param {function} before       - a preprocessing function, gets called before nock.define
     * @param {function} after        - a postprocessing function, gets called after nock.define
     * @param {function} afterRecord  - a postprocessing function, gets called after recording. Is passed the array
     *                                  of scopes recorded and should return the array scopes to save to the fixture
     * @param {function} recorder     - custom options to pass to the recorder
     *
     */
    function Back (fixtureName, options, nockedFn) {
      if(!Back.fixtures) {
        throw new Error(  'Back requires nock.back.fixtures to be set\n' +
                          'Ex:\n' +
                          '\trequire(nock).back.fixtures = \'/path/to/fixures/\'');
      }

      if (!lodash.isString(fixtureName)) {
        throw new Error('Parameter fixtureName must be a string');
      }

      if( arguments.length === 1 ) {
        options = {};
      } else if( arguments.length === 2 ) {
        // If 2nd parameter is a function then `options` has been omitted
        // otherwise `options` haven't been omitted but `nockedFn` was.
        if (lodash.isFunction(options)) {
          nockedFn = options;
          options = {};
        }
      }

      _mode.setup();

      var fixture = path.join(Back.fixtures, fixtureName)
        , context = _mode.start(fixture, options);


      var nockDone = function () {
        _mode.finish(fixture, options, context);
      };

      debug('context:', context);

      // If nockedFn is a function then invoke it, otherwise return a promise resolving to nockDone.
      if (lodash.isFunction(nockedFn)) {
        nockedFn.call(context, nockDone);
      } else {
        return Promise.resolve({nockDone: nockDone, context: context});
      }
    }




    /*******************************************************************************
    *                                    Modes                                     *
    *******************************************************************************/


    var wild = {


      setup: function () {
        scope.cleanAll();
        recorder.restore();
        scope.activate();
        scope.enableNetConnect();
      },


      start: function () {
        return load(); //don't load anything but get correct context
      },


      finish: function () {
        //nothing to do
      }


    };




    var dryrun = {


      setup: function () {
        recorder.restore();
        scope.cleanAll();
        scope.activate();
        //  We have to explicitly enable net connectivity as by default it's off.
        scope.enableNetConnect();
      },


      start: function (fixture, options) {
        var contexts = load(fixture, options);

        scope.enableNetConnect();
        return contexts;
      },


      finish: function () {
        //nothing to do
      }


    };




    var record = {


      setup: function () {
        recorder.restore();
        recorder.clear();
        scope.cleanAll();
        scope.activate();
        scope.disableNetConnect();
      },


      start: function (fixture, options) {
        if (! fs$$1) {
          throw new Error('no fs');
        }
        var context = load(fixture, options);

        if( !context.isLoaded ) {
          recorder.record(lodash.assign({
            dont_print: true,
            output_objects: true
          }, options && options.recorder));

          context.isRecording = true;
        }

        return context;
      },


      finish: function (fixture, options, context) {
        if( context.isRecording ) {
          var outputs = recorder.outputs();

          if( typeof options.afterRecord === 'function' ) {
            outputs = options.afterRecord(outputs);
          }

          outputs = JSON.stringify(outputs, null, 4);
          debug('recorder outputs:', outputs);

          mkdirp$$1.sync(path.dirname(fixture));
          fs$$1.writeFileSync(fixture, outputs);
        }
      }


    };




    var lockdown = {


      setup: function () {
        recorder.restore();
        recorder.clear();
        scope.cleanAll();
        scope.activate();
        scope.disableNetConnect();
      },


      start: function (fixture, options) {
        return load(fixture, options);
      },


      finish: function () {
        //nothing to do
      }


    };




    function load (fixture, options) {
      var context = {
        scopes : [],
        assertScopesFinished: function () {
          assertScopes(this.scopes, fixture);
        }
      };

      if( fixture && fixtureExists(fixture) ) {
        var scopes = scope.loadDefs(fixture);
        applyHook(scopes, options.before);

        scopes = scope.define(scopes);
        applyHook(scopes, options.after);

        context.scopes = scopes;
        context.isLoaded = true;
      }


      return context;
    }




    function applyHook(scopes, fn) {
      if( !fn ) {
        return;
      }

      if( typeof fn !== 'function' ) {
        throw new Error ('processing hooks must be a function');
      }

      scopes.forEach(fn);
    }




    function fixtureExists(fixture) {
      if (! fs$$1) {
        throw new Error('no fs');
      }

      return fs$$1.existsSync(fixture);
    }




    function assertScopes (scopes, fixture) {
      scopes.forEach(function (scope$$1) {
        expect( scope$$1.isDone() )
        .to.be.equal(
          true,
          format('%j was not used, consider removing %s to rerecord fixture', scope$$1.pendingMocks(), fixture)
        );
      });
    }




    var Modes = {

      wild: wild, //all requests go out to the internet, dont replay anything, doesnt record anything

      dryrun: dryrun, //use recorded nocks, allow http calls, doesnt record anything, useful for writing new tests (default)

      record: record, //use recorded nocks, record new nocks

      lockdown: lockdown, //use recorded nocks, disables all http calls even when not nocked, doesnt record

    };





    Back.setMode = function(mode) {
      if( !Modes.hasOwnProperty(mode) ) {
        throw new Error ('Unknown mode: ' + mode);
      }

      Back.currentMode = mode;
      debug('New nock back mode:', Back.currentMode);

      _mode = Modes[mode];
      _mode.setup();
    };




    Back.fixtures = null;
    Back.currentMode = null;
    Back.setMode(process.env.NOCK_BACK_MODE || 'dryrun');

    module.exports = exports = Back;
    });

    var nock = scope;

    var recorder_1 = {
        rec  : recorder.record
      , clear   : recorder.clear
      , play : recorder.outputs
    };

    var back$1 = back;
    var restore$1 = recorder.restore;
    nock.recorder = recorder_1;
    nock.back = back$1;
    nock.restore = restore$1;

    describe('IO', function () {
        describe('memory endpoint', function () {
            var testData = [
                { name: "John" }
            ];
            var User = (function (_super) {
                __extends(User, _super);
                function User() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                User.endpoint = create(testData);
                __decorate([
                    attr,
                    __metadata("design:type", String)
                ], User.prototype, "name", void 0);
                User = __decorate([
                    define
                ], User);
                return User;
            }(Record));
            it('loads the test data', function (done) {
                var users = new User.Collection();
                users.fetch()
                    .then(function () {
                    chai_1$1(users.length).to.eql(1);
                    chai_1$1(users.first().name).to.eql('John');
                    done();
                });
            });
            it('create', function (done) {
                var x = new User({ name: "test" });
                x.save().then(function () {
                    chai_1$1(x.id).to.eql("1");
                    done();
                });
            });
            it('read', function (done) {
                var x = (new User({ id: "1" })).fetch().then(function (x) {
                    chai_1$1(x.name).to.eql("test");
                    done();
                });
            });
            it('update', function (done) {
                var x = new User({ id: "1" });
                x.fetch()
                    .then(function () {
                    x.name = "Mike";
                    return x.save();
                })
                    .then(function () {
                    var y = new User({ id: "1" });
                    return y.fetch();
                })
                    .then(function (y) {
                    chai_1$1(y.name).to.eql('Mike');
                    done();
                });
            });
            it('list', function (done) {
                var users = new User.Collection();
                users.fetch()
                    .then(function () {
                    chai_1$1(users.length).to.eql(2);
                    chai_1$1(users.first().name).to.eql("John");
                    chai_1$1(users.last().name).to.eql("Mike");
                    done();
                });
            });
            it("destroy", function (done) {
                var x = new User({ id: "1" });
                x.destroy()
                    .then(function () {
                    var users = new User.Collection();
                    return users.fetch();
                })
                    .then(function (users) {
                    chai_1$1(users.length).to.eql(1);
                    chai_1$1(users.first().name).to.eql("John");
                    done();
                });
            });
        });
        it('can override endpoint with .has.endpoint', function (done) {
            var NoEndpoint = (function (_super) {
                __extends(NoEndpoint, _super);
                function NoEndpoint() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                NoEndpoint.attributes = {
                    type: 'no endpoint'
                };
                NoEndpoint = __decorate([
                    define
                ], NoEndpoint);
                return NoEndpoint;
            }(Record));
            var HasEndpoint = (function (_super) {
                __extends(HasEndpoint, _super);
                function HasEndpoint() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                HasEndpoint.endpoint = create([{ id: 666 }]);
                HasEndpoint.attributes = {
                    type: 'has endpoint'
                };
                HasEndpoint = __decorate([
                    define
                ], HasEndpoint);
                return HasEndpoint;
            }(Record));
            var TestStore = (function (_super) {
                __extends(TestStore, _super);
                function TestStore() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                TestStore.endpoint = create$1();
                TestStore.attributes = {
                    a: type(NoEndpoint.Collection).endpoint(create([{ id: "777" }])),
                    b: HasEndpoint.Collection,
                    c: type(HasEndpoint.Collection).endpoint(create([{ id: "555" }]))
                };
                TestStore = __decorate([
                    define
                ], TestStore);
                return TestStore;
            }(Store));
            var s = new TestStore();
            s.fetch().then(function () {
                chai_1$1(s.a.first().id).to.eql("777");
                chai_1$1(s.b.first().id).to.eql(666);
                chai_1$1(s.c.first().id).to.eql("555");
                done();
            });
        });
        describe("restful endpoint", function () {
            describe('Base test', function () {
                var usersStorage = {
                    models: [],
                    counter: 0
                };
                var USER_REGEX = /\/users\/(\w+)/;
                function getUserId(uri) {
                    return uri.match(USER_REGEX)[1];
                }
                function getUser(id) {
                    return usersStorage.models.filter(function (u) { return u.id == id; })[0];
                }
                function cloneUser(_a) {
                    var id = _a.id, name = _a.name;
                    return { id: id, name: name };
                }
                nock.cleanAll();
                nock('http://restful.basic')
                    .persist()
                    .get('/users')
                    .reply(200, function () {
                    return usersStorage.models.map(cloneUser);
                })
                    .get(USER_REGEX)
                    .reply(function (uri) {
                    var user = getUser(getUserId(uri));
                    if (user) {
                        return [200, cloneUser(user)];
                    }
                    else {
                        console.warn("GET: NOT FOUND", uri);
                        return [404];
                    }
                })
                    .post('/users')
                    .reply(200, function (uri, requestBody) {
                    var id = ++usersStorage.counter, user = __assign({ id: String(id) }, requestBody);
                    usersStorage.models.push(user);
                    return cloneUser(user);
                })
                    .put(USER_REGEX)
                    .reply(function (uri, requestBody) {
                    var user = getUser(getUserId(uri));
                    if (user) {
                        user.name = requestBody.name;
                        return [200, cloneUser(user)];
                    }
                    else {
                        console.warn("PUT: NOT FOUND", uri);
                        return [404];
                    }
                })
                    .delete(USER_REGEX)
                    .reply(function (uri) {
                    var user = getUser(getUserId(uri));
                    if (user) {
                        var idx = usersStorage.models.indexOf(user);
                        usersStorage.models.splice(idx, 1);
                        return [200];
                    }
                    else {
                        console.warn("DELETE: NOT FOUND", uri);
                        return [404];
                    }
                });
                testEndpoint(create$3('http://restful.basic/users'))();
            });
            describe('Relative urls', function () {
                var User = (function (_super) {
                    __extends(User, _super);
                    function User() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    User.endpoint = create$3('./users');
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], User.prototype, "name", void 0);
                    User = __decorate([
                        define
                    ], User);
                    return User;
                }(Record));
                var Store$$1 = (function (_super) {
                    __extends(Store$$1, _super);
                    function Store$$1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Store$$1.endpoint = create$3('./store');
                    __decorate([
                        attr,
                        __metadata("design:type", String)
                    ], Store$$1.prototype, "name", void 0);
                    __decorate([
                        prop(User),
                        __metadata("design:type", User)
                    ], Store$$1.prototype, "user", void 0);
                    Store$$1 = __decorate([
                        define
                    ], Store$$1);
                    return Store$$1;
                }(Record));
                var Root = (function (_super) {
                    __extends(Root, _super);
                    function Root() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Root.endpoint = create$3('http://restful.relative/');
                    __decorate([
                        prop(User.Collection),
                        __metadata("design:type", Collection)
                    ], Root.prototype, "users", void 0);
                    __decorate([
                        prop(Store$$1),
                        __metadata("design:type", Store$$1)
                    ], Root.prototype, "store", void 0);
                    Root = __decorate([
                        define
                    ], Root);
                    return Root;
                }(Record));
                var root = new Root();
                root.store.id = 99;
                root.store.user.id = 1000;
                nock('http://restful.relative')
                    .get('/users')
                    .reply(200, [{ id: 10, name: 'John' }, { id: 11, name: 'Jack' }])
                    .get('/store/99')
                    .reply(200, { id: 99, name: 'something' })
                    .get('/store/99/users/1000')
                    .reply(200, { id: 1000, name: 'special' });
                it('resolves in simple case', function (done) {
                    root.store.fetch().then(function () {
                        chai_1$1(root.store.name).to.eql('something');
                        done();
                    });
                });
                it('resolves for collection', function (done) {
                    root.users.fetch().then(function () {
                        chai_1$1(root.users.map(function (u) { return u.id; })).deep.equal([10, 11]);
                        done();
                    });
                });
                it('nested resolve', function (done) {
                    var user = root.store.user;
                    user.fetch().then(function () {
                        chai_1$1(user.name).to.equal('special');
                        done();
                    });
                });
            });
            describe("Merging options", function () {
                RestfulEndpoint.defaultFetchOptions = {
                    cache: "force-cache",
                    credentials: "omit",
                    mode: "navigate",
                    redirect: "manual",
                };
                it("uses default options", function () {
                    var io = create$3(""), options = io.buildRequestOptions("get");
                    chai_1$1(options.cache).to.equal("force-cache");
                    chai_1$1(options.credentials).to.equal("omit");
                    chai_1$1(options.mode).to.equal("navigate");
                    chai_1$1(options.redirect).to.equal("manual");
                });
                it("Overrides at ctor", function () {
                    var io = create$3("", { credentials: "include", cache: "reload" }), options = io.buildRequestOptions("get");
                    chai_1$1(options.cache).to.equal("reload");
                    chai_1$1(options.credentials).to.equal("include");
                });
                it("Overrides at call", function () {
                    var io = create$3("", { credentials: "include", cache: "reload" }), options = io.buildRequestOptions("get", { cache: "no-store", credentials: "same-origin" });
                    chai_1$1(options.cache).to.equal("no-store");
                    chai_1$1(options.credentials).to.equal("same-origin");
                });
            });
        });
        if (typeof localStorage !== 'undefined')
            describe('localStorage endpoint', testEndpoint(create$2("/test")));
    });
    function testEndpoint(endpoint) {
        return function () {
            var User = (function (_super) {
                __extends(User, _super);
                function User() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                User.endpoint = endpoint;
                __decorate([
                    attr,
                    __metadata("design:type", String)
                ], User.prototype, "name", void 0);
                User = __decorate([
                    define
                ], User);
                return User;
            }(Record));
            var generatedId;
            it('create', function (done) {
                var x = new User({ name: "test" });
                x.save().then(function () {
                    generatedId = x.id;
                    chai_1$1(x.id).to.be.not.empty;
                    done();
                });
            });
            it('read', function (done) {
                var x = new User({ id: generatedId });
                x.fetch().then(function () {
                    chai_1$1(x.name).to.eql("test");
                    done();
                });
            });
            it('update', function (done) {
                var x = new User({ id: generatedId });
                x.fetch()
                    .then(function () {
                    x.name = "Mike";
                    return x.save();
                })
                    .then(function () {
                    var y = new User({ id: generatedId });
                    return y.fetch();
                })
                    .then(function (y) {
                    chai_1$1(y.name).to.eql('Mike');
                    done();
                });
            });
            it('list', function (done) {
                var users = new User.Collection();
                users.fetch()
                    .then(function () {
                    chai_1$1(users.length).to.eql(1);
                    chai_1$1(users.last().name).to.eql("Mike");
                    done();
                });
            });
            it("destroy", function (done) {
                var x = new User({ id: generatedId });
                x.destroy()
                    .then(function () {
                    var users = new User.Collection();
                    return users.fetch();
                })
                    .then(function (users) {
                    chai_1$1(users.length).to.eql(0);
                    done();
                });
            });
        };
    }

})));
//# sourceMappingURL=index.js.map
